<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.2"
    />
    <meta
      name="keywords"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.2"
    />
    <title>
      Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.2
    </title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/highlight.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="js/jquery.min.js"></script>
    <script src="js/footnotes.js"></script>
    <script src="js/browsertest.js"></script>
  </head>
  <body>
    <section>
      <span class="top jump"><a href="#pagetop" accesskey="t">⇡</a></span>
      <a id="pagetop"></a>
      <nav class="header">
        <p>
          Próximo:
          <a href="1_002e3.html#g_t1_002e3" accesskey="n" rel="next">1.3</a>,
          Anterior:
          <a href="1_002e1.html#g_t1_002e1" accesskey="p" rel="prev">1.1</a>,
          Acima: <a href="#g_t1_002e2" accesskey="u" rel="prev">1.2</a> [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Sumário</a
          >]
        </p>
      </nav>
      <a id="g_t1_002e2"></a>
      <h3 class="section">
        <span class="secnum">1.2</span>
        <span class="sectitle"
          >Procedimentos e os Processos que Eles Geram</span
        >
      </h3>

      <p>
        Agora consideramos os elementos da programação: usamos operações
        aritméticas primitivas, combinamos essas operações e abstraímos essas
        operações compostas definindo-as como procedimentos compostos. Mas isso
        não é suficiente para nos permitir dizer que sabemos programar. Nossa
        situação é análoga à de alguém que aprendeu as regras de como as peças
        se movem no xadrez, mas não sabe nada sobre aberturas típicas, táticas
        ou estratégias. Como o jogador iniciante de xadrez, ainda não conhecemos
        os padrões comuns de uso no domínio. Falta-nos o conhecimento de quais
        movimentos valem a pena fazer (quais procedimentos valem a pena
        definir). Falta-nos a experiência para prever as consequências de fazer
        um movimento (executar um procedimento).
      </p>
      <p>
        A capacidade de visualizar as consequências das ações em consideração é
        crucial para se tornar um programador especialista, assim como é em
        qualquer atividade criativa e sintética. Para se tornar um fotógrafo
        especialista, por exemplo, é preciso aprender a olhar para uma cena e
        saber quão escura cada região aparecerá em uma impressão para cada
        possível escolha de exposição e condições de desenvolvimento. Somente
        então podemos raciocinar de trás para frente, planejando o
        enquadramento, a iluminação, a exposição e o desenvolvimento para obter
        os efeitos desejados. O mesmo acontece com a programação, onde estamos
        planejando o curso de ação a ser tomado por um processo e onde
        controlamos o processo por meio de um programa. Para nos tornarmos
        especialistas, devemos aprender a visualizar os processos gerados por
        vários tipos de procedimentos. Somente depois de desenvolver essa
        habilidade podemos aprender a construir programas que exibam o
        comportamento desejado de forma confiável.
      </p>
      <p>
        Um procedimento é um padrão para a <a id="index-local-evolution"></a>
        <em>evolução local</em> de um processo computacional. Ele especifica
        como cada estágio do processo é construído sobre o estágio anterior.
        Gostaríamos de ser capazes de fazer afirmações sobre o comportamento
        <a id="index-global"></a> <em>global</em> de um processo cuja evolução
        local foi especificada por um procedimento. Isso é muito difícil de
        fazer em geral, mas podemos pelo menos tentar descrever alguns padrões
        típicos de evolução de processos.
      </p>
      <p>
        Nesta seção, examinaremos algumas "formas" comuns para processos gerados
        por procedimentos simples. Também investigaremos as taxas nas quais
        esses processos consomem os importantes recursos computacionais de tempo
        e espaço. Os procedimentos que consideraremos são muito simples. Seu
        papel é semelhante ao desempenhado por padrões de teste em fotografia:
        como padrões prototípicos super simplificados, em vez de exemplos
        práticos por si só.
      </p>

      <a id="g_t1_002e2_002e1"></a>
      <a id="Linear-Recursion-and-Iteration"></a>
      <h4 class="subsection">
        <span class="secnum">1.2.1</span>
        <span class="sectitle">Recursão Linear e Iteração</span>
      </h4>

      <p>
        Começamos considerando a função fatorial, definida por

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mi>n</mi>
          <mo>!</mo>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>⋅</mo>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>⋅</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>2</mn>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>⋯</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
            <mo>⋅</mo>
            <mn>2</mn>
            <mo>⋅</mo>
            <mn>1.</mn>
          </mrow>
        </math>

        Existem muitas maneiras de calcular fatoriais. Uma delas é usar a
        observação de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow>
        </math>
        é igual a
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        vezes
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
            <mo>!</mo>
          </mrow>
        </math>
        para qualquer inteiro positivo
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>:

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mi>n</mi>
          <mo>!</mo>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>⋅</mo>
            <mo stretchy="false">[</mo>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>⋅</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>2</mn>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>⋯</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
            <mo>⋅</mo>
            <mn>2</mn>
            <mo>⋅</mo>
            <mn>1</mn>
            <mo stretchy="false">]</mo>
          </mrow>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>⋅</mo>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
            <mo>!</mo>
            <mo>.</mo>
          </mrow>
        </math>

        Assim, podemos calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow>
        </math>
        calculando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>−</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
            <mo>!</mo>
          </mrow>
        </math>
        e multiplicando o resultado por
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>. Se
        adicionarmos a estipulação de que 1! é igual a 1, essa observação se
        traduz diretamente em um procedimento:
      </p>
      <pre><code class="language-scheme">
(define (factorial n)
  (if (= n 1) 
      1 
      (* n (factorial (- n 1)))))
        </code></pre>

      <p>
        Podemos usar o modelo de substituição de
        <a href="1_002e1.html#g_t1_002e1_002e5">1.1.5</a> para observar esse
        procedimento em ação calculando 6!, como mostrado em
        <a href="#Figure-1_002e3">Figura 1.3</a>.
      </p>
      <figure class="float">
        <a id="Figure-1_002e3"></a>
        <object
          style="width: 52.58ex; height: 31.43ex"
          data="fig/chap1/Fig1.3d.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 1.3:</strong> Um processo recursivo linear para
            calcular 6!.
          </p>
        </figcaption>
      </figure>

      <p>
        Agora, vamos adotar uma perspectiva diferente sobre o cálculo de
        fatoriais. Poderíamos descrever uma regra para calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow>
        </math>
        especificando que primeiro multiplicamos 1 por 2, depois multiplicamos o
        resultado por 3, depois por 4, e assim por diante até atingirmos
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Mais formalmente, mantemos um produto acumulado, juntamente com um
        contador que conta de 1 até
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Podemos descrever a computação dizendo que o contador e o produto mudam
        simultaneamente de um passo para o próximo de acordo com a regra
      </p>
      <div class="example">
        <pre class="example">
produto <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo stretchy="false">←</mo>
</math> contador * produto
contador <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo stretchy="false">←</mo>
</math> contador + 1
</pre>
      </div>

      <p>
        e estipulando que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow>
        </math>
        é o valor do produto quando o contador excede
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
      </p>
      <p>
        Mais uma vez, podemos reformular nossa descrição como um procedimento
        para calcular fatoriais:<a
          class="footnote_link"
          id="DOCF29"
          href="#FOOT29"
          ><sup>29</sup></a
        >
      </p>
      <pre><code class="language-scheme">
(define (factorial n) 
  (fact-iter 1 1 n))

(define (fact-iter produto contador max-contador)
  (if (> contador max-contador)
      produto
      (fact-iter (* contador produto)
                  (+ contador 1)
                  max-contador)))
        </code></pre>

      <p>
        Como antes, podemos usar o modelo de substituição para visualizar o
        processo de cálculo de 6!, como mostrado em
        <a href="#Figure-1_002e4">Figura 1.4</a>.
      </p>
      <figure class="float">
        <a id="Figure-1_002e4"></a>
        <object
          style="width: 23.4ex; height: 23.31ex"
          data="fig/chap1/Fig1.4d.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 1.4:</strong> Um processo iterativo linear para
            calcular 6!.
          </p>
        </figcaption>
      </figure>

      <p>
        Compare os dois processos. De um ponto de vista, eles parecem quase
        iguais. Ambos calculam a mesma função matemática no mesmo domínio, e
        cada um requer um número de passos proporcional a
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        para calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow> </math
        >. De fato, ambos os processos até realizam a mesma sequência de
        multiplicações, obtendo a mesma sequência de produtos parciais. Por
        outro lado, quando consideramos as "formas" dos dois processos,
        descobrimos que eles evoluem de maneira bastante diferente.
      </p>
      <p>
        Considere o primeiro processo. O modelo de substituição revela uma forma
        de expansão seguida de contração, indicada pela seta em
        <a href="#Figure-1_002e3">Figura 1.3</a>. A expansão ocorre à medida que
        o processo constrói uma cadeia de <a id="index-deferred-operations"></a>
        <em>operações adiadas</em>
        (neste caso, uma cadeia de multiplicações). A contração ocorre quando as
        operações são realmente realizadas. Esse tipo de processo, caracterizado
        por uma cadeia de operações adiadas, é chamado de
        <a id="index-recursive-process"></a> <em>processo recursivo</em>. A
        execução desse processo exige que o interpretador mantenha o controle
        das operações a serem realizadas posteriormente. No cálculo de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow> </math
        >, o comprimento da cadeia de multiplicações adiadas, e, portanto, a
        quantidade de informações necessárias para mantê-la, cresce linearmente
        com
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        (é proporcional a
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>),
        assim como o número de passos. Esse processo é chamado de
        <a id="index-linear-recursive-process"></a>
        <em>processo recursivo linear</em>.
      </p>
      <p>
        Em contraste, o segundo processo não cresce e diminui. A cada passo,
        tudo o que precisamos manter, para qualquer
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
        são os valores atuais das variáveis <code>produto</code>,
        <code>contador</code> e <code>max-contador</code>. Chamamos isso de
        <a id="index-iterative-process"></a>
        <em>processo iterativo</em>. Em geral, um processo iterativo é aquele
        cujo estado pode ser resumido por um número fixo de
        <a id="index-state-variables"></a> <em>variáveis de estado</em>,
        juntamente com uma regra fixa que descreve como as variáveis de estado
        devem ser atualizadas à medida que o processo passa de um estado para
        outro e um teste de fim (opcional) que especifica as condições sob as
        quais o processo deve terminar. No cálculo de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>!</mo>
          </mrow> </math
        >, o número de passos necessários cresce linearmente com
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Esse processo é chamado de
        <a id="index-linear-iterative-process"></a>
        <em>processo iterativo linear</em>.
      </p>
      <p>
        O contraste entre os dois processos pode ser visto de outra maneira. No
        caso iterativo, as variáveis do programa fornecem uma descrição completa
        do estado do processo em qualquer ponto. Se pararmos a computação entre
        os passos, tudo o que precisamos fazer para retomar a computação é
        fornecer ao interpretador os valores das três variáveis do programa.
        Isso não acontece com o processo recursivo. Nesse caso, há algumas
        informações "ocultas" adicionais, mantidas pelo interpretador e não
        contidas nas variáveis do programa, que indicam "onde o processo está"
        na negociação da cadeia de operações adiadas. Quanto mais longa a
        cadeia, mais informações devem ser mantidas.<a
          class="footnote_link"
          id="DOCF30"
          href="#FOOT30"
          ><sup>30</sup></a
        >
      </p>
      <p>
        Ao contrastar iteração e recursão, devemos ter cuidado para não
        confundir a noção de um processo <a id="index-process"></a>
        <em>recursivo</em> com a noção de um procedimento
        <a id="index-procedure"></a>
        <em>recursivo</em>. Quando descrevemos um procedimento como recursivo,
        estamos nos referindo ao fato sintático de que a definição do
        procedimento se refere (direta ou indiretamente) ao próprio
        procedimento. Mas quando descrevemos um processo como seguindo um padrão
        que é, digamos, linearmente recursivo, estamos falando sobre como o
        processo evolui, não sobre a sintaxe de como um procedimento é escrito.
        Pode parecer perturbador que nos refiramos a um procedimento recursivo
        como <code>fact-iter</code> como gerando um processo iterativo. No
        entanto, o processo realmente é iterativo: seu estado é completamente
        capturado por suas três variáveis de estado, e um interpretador precisa
        manter o controle de apenas três variáveis para executar o processo.
      </p>
      <p>
        Uma razão pela qual a distinção entre processo e procedimento pode ser
        confusa é que a maioria das implementações de linguagens comuns
        (incluindo Ada, Pascal e C) é projetada de tal forma que a interpretação
        de qualquer procedimento recursivo consome uma quantidade de memória que
        cresce com o número de chamadas de procedimento, mesmo quando o processo
        descrito é, em princípio, iterativo. Como consequência, essas linguagens
        podem descrever processos iterativos apenas recorrendo a construções
        especiais de "looping", como <code>do</code>, <code>repeat</code>,
        <code>until</code>, <code>for</code> e <code>while</code>. A
        implementação de Scheme que consideraremos em
        <a href="Chapter-5.html#Chapter-5">Capítulo 5</a> não compartilha essa
        deficiência. Ela executará um processo iterativo em espaço constante,
        mesmo se o processo iterativo for descrito por um procedimento
        recursivo. Uma implementação com essa propriedade é chamada
        <a id="index-tail_002drecursive"></a> <em>recursão de cauda</em>. Com
        uma implementação de recursão de cauda, a iteração pode ser expressa
        usando o mecanismo comum de chamada de procedimento, de modo que
        construções especiais de iteração são úteis apenas como açúcar
        sintático.<a class="footnote_link" id="DOCF31" href="#FOOT31"
          ><sup>31</sup></a
        >
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e9"></a>Exercício 1.9:</strong> Cada um
          dos seguintes dois procedimentos define um método para adicionar dois
          inteiros positivos em termos dos procedimentos <code>inc</code>, que
          incrementa seu argumento em 1, e <code>dec</code>, que decrementa seu
          argumento em 1.
        </p>
        <pre><code class="language-scheme">
(define (+ a b)
  (if (= a 0) 
      b 
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0) 
      b 
      (+ (dec a) (inc b))))
            </code></pre>

        <p>
          Usando o modelo de substituição, ilustre o processo gerado por cada
          procedimento ao avaliar <code>(+ 4 5)</code>. Esses processos são
          iterativos ou recursivos?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e10"></a>Exercício 1.10:</strong> O
          seguinte procedimento calcula uma função matemática chamada função de
          Ackermann.
        </p>
        <pre><code class="language-scheme">
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
            </code></pre>

        <p>Quais são os valores das seguintes expressões?</p>
        <pre><code class="language-scheme">
(A 1 10)
(A 2 4)
(A 3 3)
            </code></pre>

        <p>
          Considere os seguintes procedimentos, onde <code>A</code> é o
          procedimento definido acima:
        </p>
        <pre><code class="language-scheme">
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
            </code></pre>

        <p>
          Dê definições matemáticas concisas para as funções computadas pelos
          procedimentos <code>f</code>, <code>g</code> e <code>h</code> para
          valores inteiros positivos de
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
          Por exemplo, <code>(k n)</code> computa
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mn>5</mn>
              <msup>
                <mi>n</mi>
                <mn>2</mn>
              </msup>
            </mrow> </math
          >.
        </p>
      </blockquote>

      <a id="g_t1_002e2_002e2"></a>
      <a id="Tree-Recursion"></a>
      <h4 class="subsection">
        <span class="secnum">1.2.2</span>
        <span class="sectitle">Recursão em Árvore</span>
      </h4>

      <p>
        Outro padrão comum de computação é chamado
        <a id="index-tree-recursion"></a> <em>recursão em árvore</em>. Como
        exemplo, considere o cálculo da sequência de números de Fibonacci, em
        que cada número é a soma dos dois anteriores:
      </p>
      <div style="text-align: center">0, 1, 1, 2, 3, 5, 8, 13, 21, ….</div>
      <p>
        Em geral, os números de Fibonacci podem ser definidos pela regra

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtext>Fib</mtext>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
          <mspace width="thickmathspace" />
          <mo>=</mo>
          <mspace width="thickmathspace" />
          <mrow>
            <mo>{</mo>
            <mtable
              columnalign="left left"
              rowspacing="4pt"
              columnspacing="1em"
            >
              <mtr>
                <mtd>
                  <mn>0</mn>
                </mtd>
                <mtd>
                  <mspace width="thickmathspace" />
                  <mtext>se</mtext>
                  <mspace width="thickmathspace" />
                  <mspace width="thickmathspace" />
                  <mi>n</mi>
                  <mo>=</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mn>1</mn>
                </mtd>
                <mtd>
                  <mspace width="thickmathspace" />
                  <mtext>se</mtext>
                  <mspace width="thickmathspace" />
                  <mspace width="thickmathspace" />
                  <mi>n</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mtext>Fib</mtext>
                  <mo stretchy="false">(</mo>
                  <mi>n</mi>
                  <mo>−</mo>
                  <mn>1</mn>
                  <mo stretchy="false">)</mo>
                  <mo>+</mo>
                  <mtext>Fib</mtext>
                  <mo stretchy="false">(</mo>
                  <mi>n</mi>
                  <mo>−</mo>
                  <mn>2</mn>
                  <mo stretchy="false">)</mo>
                </mtd>
                <mtd>
                  <mspace width="thickmathspace" />
                  <mtext>caso contrário</mtext>
                  <mo>.</mo>
                </mtd>
              </mtr>
            </mtable>
          </mrow>
        </math>

        Podemos traduzir imediatamente essa definição em um procedimento
        recursivo para calcular números de Fibonacci:
      </p>
      <pre><code class="language-scheme">
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
        </code></pre>

      <p>
        Considere o padrão dessa computação. Para calcular
        <code>(fib 5)</code>, calculamos <code>(fib 4)</code> e
        <code>(fib 3)</code>. Para calcular <code>(fib 4)</code>, calculamos
        <code>(fib 3)</code> e <code>(fib 2)</code>. Em geral, o processo
        evoluído se parece com uma árvore, como mostrado em
        <a href="#Figure-1_002e5">Figura 1.5</a>. Observe que os ramos se
        dividem em dois a cada nível (exceto na base); isso reflete o fato de
        que o procedimento <code>fib</code> chama a si mesmo duas vezes cada vez
        que é invocado.
      </p>
      <figure class="float">
        <a id="Figure-1_002e5"></a>
        <object
          style="width: 58.07ex; height: 36.18ex"
          data="fig/chap1/Fig1.5d.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 1.5:</strong> O processo recursivo em árvore gerado
            ao calcular <code>(fib 5)</code>.
          </p>
        </figcaption>
      </figure>

      <p>
        Esse procedimento é instrutivo como um protótipo de recursão em árvore,
        mas é uma maneira terrível de calcular números de Fibonacci porque faz
        muita computação redundante. Observe em
        <a href="#Figure-1_002e5">Figura 1.5</a> que toda a computação de
        <code>(fib 3)</code>—quase metade do trabalho—é duplicada. De fato, não
        é difícil mostrar que o número de vezes que o procedimento calculará
        <code>(fib 1)</code> ou <code>(fib 0)</code> (o número de folhas na
        árvore acima, em geral) é precisamente
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. Para ter uma ideia de quão ruim isso é, pode-se mostrar que o valor
        de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        cresce exponencialmente com
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Mais precisamente (veja
        <a href="#Exercise-1_002e13">Exercício 1.13</a>),
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        é o inteiro mais próximo de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msup>
              <mi>φ</mi>
              <mi>n</mi>
            </msup>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <msqrt>
              <mn>5</mn>
            </msqrt>
          </mrow> </math
        >, onde

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mi>φ</mi>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mfrac>
            <mrow>
              <mn>1</mn>
              <mo>+</mo>
              <msqrt>
                <mn>5</mn>
              </msqrt>
            </mrow>
            <mn>2</mn>
          </mfrac>
          <mspace width="thinmathspace" />
          <mo>≈</mo>
          <mspace width="thinmathspace" />
          <mn>1.6180</mn>
        </math>

        é a <a id="index-golden-ratio"></a> <em>razão áurea</em>, que satisfaz a
        equação

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <msup>
            <mi>φ</mi>
            <mn>2</mn>
          </msup>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mi>φ</mi>
            <mo>+</mo>
            <mn>1.</mn>
          </mrow>
        </math>

        Assim, o processo usa um número de passos que cresce exponencialmente
        com a entrada. Por outro lado, o espaço necessário cresce apenas
        linearmente com a entrada, porque precisamos manter o controle apenas de
        quais nós estão acima de nós na árvore em qualquer ponto da computação.
        Em geral, o número de passos necessários para um processo recursivo em
        árvore será proporcional ao número de nós na árvore, enquanto o espaço
        necessário será proporcional à profundidade máxima da árvore.
      </p>
      <p>
        Também podemos formular um processo iterativo para calcular os números
        de Fibonacci. A ideia é usar um par de inteiros
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi> </math>,
        inicializados para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib(1) = 1</mtext>
          </mrow>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib(0) = 0</mtext>
          </mrow> </math
        >, e aplicar repetidamente as transformações simultâneas
      </p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mtable columnalign="left" rowspacing="4pt" columnspacing="1em">
          <mtr>
            <mtd>
              <mi>a</mi>
              <mspace width="thickmathspace" />
              <mo stretchy="false">←</mo>
              <mspace width="thickmathspace" />
              <mi>a</mi>
              <mo>+</mo>
              <mi>b</mi>
              <mo>,</mo>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mi>b</mi>
              <mspace width="thickmathspace" />
              <mo stretchy="false">←</mo>
              <mspace width="thickmathspace" />
              <mi>a</mi>
              <mo>.</mo>
            </mtd>
          </mtr>
        </mtable>
      </math>

      <p>
        Não é difícil mostrar que, após aplicar essa transformação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        vezes,
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        serão iguais, respectivamente, a
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. Assim, podemos calcular os números de Fibonacci iterativamente usando
        o procedimento
      </p>
      <pre><code class="language-scheme">
(define (fib n) 
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
        </code></pre>

      <p>
        Este segundo método para calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        é uma iteração linear. A diferença no número de passos necessários pelos
        dois métodos—um linear em
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
        outro crescendo tão rápido quanto
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        —é enorme, mesmo para entradas pequenas.
      </p>
      <p>
        Não se deve concluir disso que os processos recursivos em árvore são
        inúteis. Quando consideramos processos que operam em dados
        hierarquicamente estruturados em vez de números, descobrimos que a
        recursão em árvore é uma ferramenta natural e poderosa.<a
          class="footnote_link"
          id="DOCF32"
          href="#FOOT32"
          ><sup>32</sup></a
        >
        Mas mesmo em operações numéricas, os processos recursivos em árvore
        podem ser úteis para nos ajudar a entender e projetar programas. Por
        exemplo, embora o primeiro procedimento <code>fib</code> seja muito
        menos eficiente que o segundo, ele é mais direto, sendo pouco mais do
        que uma tradução para Lisp da definição da sequência de Fibonacci. Para
        formular o algoritmo iterativo, foi necessário perceber que a computação
        poderia ser reformulada como uma iteração com três variáveis de estado.
      </p>
      <a id="Example_003a-Counting-change"></a>
      <h5 class="subsubheading">Exemplo: Contando troco</h5>

      <p>
        É preciso apenas um pouco de engenhosidade para chegar ao algoritmo
        iterativo de Fibonacci. Em contraste, considere o seguinte problema: De
        quantas maneiras diferentes podemos fazer o troco de $1,00, usando
        meio-dólar, quartos, moedas de dez centavos, moedas de cinco centavos e
        moedas de um centavo? Mais geralmente, podemos escrever um procedimento
        para calcular o número de maneiras de trocar qualquer quantia de
        dinheiro?
      </p>
      <p>
        Esse problema tem uma solução simples como um procedimento recursivo.
        Suponha que pensemos nos tipos de moedas disponíveis como dispostos em
        alguma ordem. Então, a seguinte relação é válida:
      </p>
      <p>
        O número de maneiras de trocar a quantia
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        usando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        tipos de moedas é igual a
      </p>
      <ul>
        <li>
          o número de maneiras de trocar a quantia
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          usando todos, exceto o primeiro tipo de moeda, mais
        </li>
        <li>
          o número de maneiras de trocar a quantia
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mo>−</mo>
              <mi>d</mi>
            </mrow>
          </math>
          usando todos os
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          tipos de moedas, onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>d</mi>
          </math>
          é a denominação do primeiro tipo de moeda.
        </li>
      </ul>

      <p>
        Para ver por que isso é verdade, observe que as maneiras de fazer o
        troco podem ser divididas em dois grupos: aquelas que não usam nenhuma
        moeda do primeiro tipo e aquelas que usam. Portanto, o número total de
        maneiras de fazer o troco para uma quantia é igual ao número de maneiras
        de fazer o troco sem usar nenhuma moeda do primeiro tipo, mais o número
        de maneiras de fazer o troco assumindo que usamos uma moeda do primeiro
        tipo. Mas este último número é igual ao número de maneiras de fazer o
        troco para a quantia que resta após usar uma moeda do primeiro tipo.
      </p>
      <p>
        Assim, podemos reduzir recursivamente o problema de trocar uma quantia
        dada ao problema de trocar quantias menores usando menos tipos de
        moedas. Considere essa regra de redução cuidadosamente e convença-se de
        que podemos usá-la para descrever um algoritmo se especificarmos os
        seguintes casos degenerados:<a
          class="footnote_link"
          id="DOCF33"
          href="#FOOT33"
          ><sup>33</sup></a
        >
      </p>
      <ul>
        <li>
          Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          for exatamente 0, devemos contar isso como 1 maneira de fazer o troco.
        </li>
        <li>
          Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          for menor que 0, devemos contar isso como 0 maneiras de fazer o troco.
        </li>
        <li>
          Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          for 0, devemos contar isso como 0 maneiras de fazer o troco.
        </li>
      </ul>

      <p>
        Podemos facilmente traduzir essa descrição em um procedimento recursivo:
      </p>
      <pre><code class="language-scheme">
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) 
             (= kinds-of-coins 0)) 
         0)
        (else 
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination 
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
        </code></pre>

      <p>
        (O procedimento <code>first-denomination</code> recebe como entrada o
        número de tipos de moedas disponíveis e retorna a denominação do
        primeiro tipo. Aqui estamos pensando nas moedas como dispostas em ordem
        do maior para o menor, mas qualquer ordem serviria.) Podemos agora
        responder à nossa pergunta original sobre trocar um dólar:
      </p>
      <pre><code class="language-scheme">
(count-change 100)
292
        </code></pre>

      <p>
        <code>Count-change</code> gera um processo recursivo em árvore com
        redundâncias semelhantes às da nossa primeira implementação de
        <code>fib</code>. (Vai demorar bastante para que 292 seja computado.)
        Por outro lado, não é óbvio como projetar um algoritmo melhor para
        computar o resultado, e deixamos esse problema como um desafio. A
        observação de que um processo recursivo em árvore pode ser altamente
        ineficiente, mas muitas vezes fácil de especificar e entender, levou as
        pessoas a propor que se poderia obter o melhor dos dois mundos
        projetando um "compilador inteligente" que pudesse transformar
        procedimentos recursivos em árvore em procedimentos mais eficientes que
        computam o mesmo resultado.<a
          class="footnote_link"
          id="DOCF34"
          href="#FOOT34"
          ><sup>34</sup></a
        >
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e11"></a>Exercício 1.11:</strong> Uma
          função
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é definida pela regra que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
              <mo>=</mo>
              <mi>n</mi>
            </mrow>
          </math>
          se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>&lt;</mo>
              <mn>3</mn>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>−</mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mn>2</mn>
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>−</mo>
              <mn>2</mn>
              <mo stretchy="false">)</mo>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mn>3</mn>
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>−</mo>
              <mn>3</mn>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>≥</mo>
              <mn>3</mn>
            </mrow> </math
          >. Escreva um procedimento que computa
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          por meio de um processo recursivo. Escreva um procedimento que computa
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          por meio de um processo iterativo.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e12"></a>Exercício 1.12:</strong> O
          seguinte padrão de números é chamado
          <a id="index-Pascal_0027s-triangle"></a> <em>Triângulo de Pascal</em>.
        </p>
        <div class="example">
          <pre class="example">
         1
       1   1
     1   2   1
   1   3   3   1
 1   4   6   4   1
       . . .
</pre
          >
        </div>

        <p>
          Os números nas bordas do triângulo são todos 1, e cada número dentro
          do triângulo é a soma dos dois números acima dele.<a
            class="footnote_link"
            id="DOCF35"
            href="#FOOT35"
            ><sup>35</sup></a
          >
          Escreva um procedimento que computa elementos do Triângulo de Pascal
          por meio de um processo recursivo.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e13"></a>Exercício 1.13:</strong> Prove
          que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mtext>Fib</mtext>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          é o inteiro mais próximo de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>φ</mi>
                <mi>n</mi>
              </msup>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <msqrt>
                <mn>5</mn>
              </msqrt>
            </mrow> </math
          >, onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>φ</mi>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mn>1</mn>
              <mo>+</mo>
              <msqrt>
                <mn>5</mn>
              </msqrt>
              <mo stretchy="false">)</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mn>2</mn>
            </mrow> </math
          >. Dica: Seja
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>ψ</mi>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mn>1</mn>
              <mo>−</mo>
              <msqrt>
                <mn>5</mn>
              </msqrt>
              <mo stretchy="false">)</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mn>2</mn>
            </mrow> </math
          >. Use indução e a definição dos números de Fibonacci (veja
          <a href="#g_t1_002e2_002e2">1.2.2</a>) para provar que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mtext>Fib</mtext>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msup>
                <mi>φ</mi>
                <mi>n</mi>
              </msup>
              <mo>−</mo>
              <msup>
                <mi>ψ</mi>
                <mi>n</mi>
              </msup>
              <mo stretchy="false">)</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <msqrt>
                <mn>5</mn>
              </msqrt>
            </mrow> </math
          >.
        </p>
      </blockquote>

      <a id="g_t1_002e2_002e3"></a>
      <a id="Orders-of-Growth"></a>
      <h4 class="subsection">
        <span class="secnum">1.2.3</span
        ><span class="sectitle">Ordens de Crescimento</span>
      </h4>

      <p>
        Os exemplos anteriores ilustram que os processos podem diferir
        consideravelmente nas taxas em que consomem recursos computacionais. Uma
        maneira conveniente de descrever essa diferença é usar a noção de
        <a id="index-order-of-growth"></a> <em>ordem de crescimento</em> para
        obter uma medida grosseira dos recursos necessários para um processo à
        medida que as entradas aumentam.
      </p>
      <p>
        Seja
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        um parâmetro que mede o tamanho do problema, e seja
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>R</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        a quantidade de recursos que o processo requer para um problema de
        tamanho
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>. Em
        nossos exemplos anteriores, tomamos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        como o número para o qual uma determinada função deve ser calculada, mas
        há outras possibilidades. Por exemplo, se nosso objetivo é calcular uma
        aproximação para a raiz quadrada de um número, podemos tomar
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        como o número de dígitos de precisão necessários. Para a multiplicação
        de matrizes, podemos tomar
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        como o número de linhas nas matrizes. Em geral, há várias propriedades
        do problema em relação às quais será desejável analisar um determinado
        processo. Da mesma forma,
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>R</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        pode medir o número de registros de armazenamento interno usados, o
        número de operações elementares da máquina realizadas, e assim por
        diante. Em computadores que realizam apenas um número fixo de operações
        por vez, o tempo necessário será proporcional ao número de operações
        elementares da máquina realizadas.
      </p>
      <p>
        Dizemos que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>R</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        tem ordem de crescimento
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, escrito
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>R</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>=</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        (pronunciado “teta de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >”), se existirem constantes positivas
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>k</mi>
            <mn>1</mn>
          </msub>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>k</mi>
            <mn>2</mn>
          </msub>
        </math>
        independentes de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        tais que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msub>
              <mi>k</mi>
              <mn>1</mn>
            </msub>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>≤<!-- ≤ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>R</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>≤<!-- ≤ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <msub>
              <mi>k</mi>
              <mn>2</mn>
            </msub>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        para qualquer valor suficientemente grande de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        (Em outras palavras, para valores grandes de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>, o
        valor
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>R</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        está "sanduichado" entre
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msub>
              <mi>k</mi>
              <mn>1</mn>
            </msub>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msub>
              <mi>k</mi>
              <mn>2</mn>
            </msub>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >.)
      </p>
      <p>
        Por exemplo, com o processo recursivo linear para calcular o fatorial
        descrito em <a href="#g_t1_002e2_002e1">1.2.1</a>, o número de passos
        cresce proporcionalmente à entrada
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Assim, os passos necessários para esse processo crescem como
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. Também vimos que o espaço necessário cresce como
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. Para o fatorial iterativo, o número de passos ainda é
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        mas o espaço é
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >—ou seja, constante.<a class="footnote_link" id="DOCF36" href="#FOOT36"
          ><sup>36</sup></a
        >
        A computação recursiva em árvore de Fibonacci requer
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <msup>
              <mi>φ<!-- φ --></mi>
              <mi>n</mi>
            </msup>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        passos e espaço
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, onde
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>φ<!-- φ --></mi>
        </math>
        é a razão áurea descrita em <a href="#g_t1_002e2_002e2">1.2.2</a>.
      </p>
      <p>
        As ordens de crescimento fornecem apenas uma descrição grosseira do
        comportamento de um processo. Por exemplo, um processo que requer
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>n</mi>
            <mn>2</mn>
          </msup>
        </math>
        passos e um processo que requer
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1000</mn>
            <msup>
              <mi>n</mi>
              <mn>2</mn>
            </msup>
          </mrow>
        </math>
        passos e um processo que requer
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
            <msup>
              <mi>n</mi>
              <mn>2</mn>
            </msup>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>10</mn>
            <mi>n</mi>
          </mrow>
          <mo>+</mo>
          <mn>17</mn>
        </math>
        passos todos têm
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <msup>
              <mi>n</mi>
              <mn>2</mn>
            </msup>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        como ordem de crescimento. Por outro lado, a ordem de crescimento
        fornece uma indicação útil de como podemos esperar que o comportamento
        do processo mude à medida que alteramos o tamanho do problema. Para um
        processo
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        (linear), dobrar o tamanho do problema aproximadamente dobrará a
        quantidade de recursos usados. Para um processo exponencial, cada
        incremento no tamanho do problema multiplicará a utilização de recursos
        por um fator constante. No restante de
        <a href="#g_t1_002e2">1.2</a>, examinaremos dois algoritmos cuja ordem
        de crescimento é logarítmica, de modo que dobrar o tamanho do problema
        aumenta a necessidade de recursos por uma quantidade constante.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e14"></a>Exercício 1.14:</strong> Desenhe
          a árvore que ilustra o processo gerado pelo procedimento
          <code>count-change</code> de
          <a href="#g_t1_002e2_002e2">1.2.2</a>
          ao fazer o troco para 11 centavos. Quais são as ordens de crescimento
          do espaço e do número de passos usados por esse processo à medida que
          a quantidade a ser trocada aumenta?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e15"></a>Exercício 1.15:</strong> O seno
          de um ângulo (especificado em radianos) pode ser calculado usando a
          aproximação
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>sin</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>x</mi>
              <mo>≈<!-- ≈ --></mo>
              <mi>x</mi>
            </mrow>
          </math>
          se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>x</mi>
          </math>
          for suficientemente pequeno, e a identidade trigonométrica

          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>sin</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>x</mi>
            </mrow>
            <mspace width="thinmathspace" />
            <mo>=</mo>
            <mspace width="thinmathspace" />
            <mrow class="MJX-TeXAtom-ORD">
              <mn>3</mn>
              <mi>sin</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mfrac>
                <mi>x</mi>
                <mn>3</mn>
              </mfrac>
            </mrow>
            <mspace width="thinmathspace" />
            <mo>−<!-- − --></mo>
            <mspace width="thinmathspace" />
            <mrow class="MJX-TeXAtom-ORD">
              <mn>4</mn>
              <msup>
                <mi>sin</mi>
                <mn>3</mn>
              </msup>
              <mo>⁡<!-- ⁡ --></mo>
              <mfrac>
                <mi>x</mi>
                <mn>3</mn>
              </mfrac>
            </mrow>
          </math>

          para reduzir o tamanho do argumento de sin. (Para os propósitos deste
          exercício, um ângulo é considerado “suficientemente pequeno” se sua
          magnitude não for maior que 0,1 radianos.) Essas ideias são
          incorporadas nos seguintes procedimentos:
        </p>
        <pre><code class="language-scheme">
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))
                </code></pre>

        <ol>
          <li>
            Quantas vezes o procedimento <code>p</code> é aplicado quando
            <code>(sine 12.15)</code> é avaliado?
          </li>
          <li>
            Qual é a ordem de crescimento em espaço e número de passos (como uma
            função de
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math
            >) usados pelo processo gerado pelo procedimento
            <code>sine</code> quando <code>(sine a)</code> é avaliado?
          </li>
        </ol>
      </blockquote>

      <a id="g_t1_002e2_002e4"></a>
      <a id="Exponentiation"></a>
      <h4 class="subsection">
        <span class="secnum">1.2.4</span
        ><span class="sectitle">Exponenciação</span>
      </h4>

      <p>
        Considere o problema de calcular a exponencial de um número dado.
        Gostaríamos de um procedimento que receba como argumentos uma base
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        e um expoente inteiro positivo
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        e calcule
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>b</mi>
            <mi>n</mi>
          </msup> </math
        >. Uma maneira de fazer isso é via a definição recursiva

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable columnalign="left" rowspacing="4pt" columnspacing="1em">
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mi>n</mi>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <mi>b</mi>
                <mo>⋅<!-- ⋅ --></mo>
                <msup>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>n</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msup>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mn>0</mn>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <mn>1</mn>
                <mo>,</mo>
              </mtd>
            </mtr>
          </mtable>
        </math>

        que se traduz facilmente no procedimento
      </p>
      <pre><code class="language-scheme">
(define (expt b n)
  (if (= n 0) 
      1 
      (* b (expt b (- n 1)))))
              </code></pre>

      <p>
        Este é um processo recursivo linear, que requer
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        passos e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        espaço. Assim como com o fatorial, podemos facilmente formular uma
        iteração linear equivalente:
      </p>
      <pre><code class="language-scheme">
(define (expt b n) 
  (expt-iter b n 1))
  
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
              </code></pre>

      <p>
        Esta versão requer
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        passos e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        espaço.
      </p>
      <p>
        Podemos calcular exponenciais em menos passos usando quadrados
        sucessivos. Por exemplo, em vez de calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>b</mi>
            <mn>8</mn>
          </msup>
        </math>
        como

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>b</mi>
            <mo>⋅<!-- ⋅ --></mo>
            <mo stretchy="false">(</mo>
            <mi>b</mi>
            <mo>⋅<!-- ⋅ --></mo>
            <mo stretchy="false">(</mo>
            <mi>b</mi>
          </mrow>
          <mo>⋅<!-- ⋅ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>b</mi>
            <mo>⋅<!-- ⋅ --></mo>
            <mo stretchy="false">(</mo>
            <mi>b</mi>
            <mo>⋅<!-- ⋅ --></mo>
            <mo stretchy="false">(</mo>
            <mi>b</mi>
          </mrow>
          <mo>⋅<!-- ⋅ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>b</mi>
            <mo>⋅<!-- ⋅ --></mo>
            <mi>b</mi>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo>,</mo>
          </mrow>
        </math>

        podemos calculá-lo usando três multiplicações:

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable columnalign="left" rowspacing="4pt" columnspacing="1em">
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mn>2</mn>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <mi>b</mi>
                <mo>⋅<!-- ⋅ --></mo>
                <mi>b</mi>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mn>4</mn>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <msup>
                  <mi>b</mi>
                  <mn>2</mn>
                </msup>
                <mo>⋅<!-- ⋅ --></mo>
                <msup>
                  <mi>b</mi>
                  <mn>2</mn>
                </msup>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mn>8</mn>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <msup>
                  <mi>b</mi>
                  <mn>4</mn>
                </msup>
                <mo>⋅<!-- ⋅ --></mo>
                <msup>
                  <mi>b</mi>
                  <mn>4</mn>
                </msup>
                <mo>.</mo>
              </mtd>
            </mtr>
          </mtable>
        </math>

        Este método funciona bem para expoentes que são potências de 2. Também
        podemos aproveitar os quadrados sucessivos para calcular exponenciais em
        geral, se usarmos a regra

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable columnalign="left left" rowspacing="4pt" columnspacing="1em">
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mi>n</mi>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <mo stretchy="false">(</mo>
                <msup>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>n</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mo>/</mo>
                    </mrow>
                    <mn>2</mn>
                  </mrow>
                </msup>
                <msup>
                  <mo stretchy="false">)</mo>
                  <mn>2</mn>
                </msup>
              </mtd>
              <mtd>
                <mtext>se</mtext>
                <mspace width="thickmathspace" />
                <mi>n</mi>
                <mspace width="thickmathspace" />
                <mtext>for par</mtext>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msup>
                  <mi>b</mi>
                  <mi>n</mi>
                </msup>
                <mspace width="thinmathspace" />
                <mo>=</mo>
                <mspace width="thinmathspace" />
                <mi>b</mi>
                <mo>⋅<!-- ⋅ --></mo>
                <msup>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>n</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msup>
              </mtd>
              <mtd>
                <mtext>se</mtext>
                <mspace width="thickmathspace" />
                <mi>n</mi>
                <mspace width="thickmathspace" />
                <mtext>for ímpar</mtext>
                <mo>.</mo>
              </mtd>
            </mtr>
          </mtable>
        </math>

        Podemos expressar esse método como um procedimento:
      </p>
      <pre><code class="language-scheme">
(define (fast-expt b n)
  (cond ((= n 0) 
          1)
        ((even? n) 
          (square (fast-expt b (/ n 2))))
        (else 
          (* b (fast-expt b (- n 1))))))
              </code></pre>

      <p>
        onde o predicado para testar se um inteiro é par é definido em termos do
        procedimento primitivo <code>remainder</code> por
      </p>
      <pre><code class="language-scheme">
(define (even? n)
  (= (remainder n 2) 0))
              </code></pre>

      <p>
        O processo evoluído por <code>fast-expt</code> cresce logaritmicamente
        com
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        tanto em espaço quanto em número de passos. Para ver isso, observe que
        calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>b</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mn>2</mn>
              <mi>n</mi>
            </mrow>
          </msup>
        </math>
        usando <code>fast-expt</code> requer apenas uma multiplicação a mais do
        que calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>b</mi>
            <mi>n</mi>
          </msup> </math
        >. O tamanho do expoente que podemos calcular, portanto, dobra
        (aproximadamente) a cada nova multiplicação permitida. Assim, o número
        de multiplicações necessárias para um expoente de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        cresce aproximadamente tão rápido quanto o logaritmo de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        na base 2. O processo tem
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        de crescimento.<a class="footnote_link" id="DOCF37" href="#FOOT37"
          ><sup>37</sup></a
        >
      </p>
      <p>
        A diferença entre
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        de crescimento e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        de crescimento torna-se impressionante à medida que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        aumenta. Por exemplo, <code>fast-expt</code> para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        = 1000 requer apenas 14 multiplicações.<a
          class="footnote_link"
          id="DOCF38"
          href="#FOOT38"
          ><sup>38</sup></a
        >
        Também é possível usar a ideia de quadrados sucessivos para criar um
        algoritmo iterativo que calcula exponenciais com um número logarítmico
        de passos (veja
        <a href="#Exercise-1_002e16">Exercício 1.16</a>), embora, como é comum
        com algoritmos iterativos, isso não seja tão direto quanto o algoritmo
        recursivo.<a class="footnote_link" id="DOCF39" href="#FOOT39"
          ><sup>39</sup></a
        >
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e16"></a>Exercício 1.16:</strong> Projete
          um procedimento que evolua um processo de exponenciação iterativa que
          use quadrados sucessivos e um número logarítmico de passos, como o
          <code>fast-expt</code>. (Dica: Usando a observação de que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msup>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>n</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo>/</mo>
                  </mrow>
                  <mn>2</mn>
                </mrow>
              </msup>
              <msup>
                <mo stretchy="false">)</mo>
                <mn>2</mn>
              </msup>
            </mrow>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msup>
                <mi>b</mi>
                <mn>2</mn>
              </msup>
              <msup>
                <mo stretchy="false">)</mo>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>n</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo>/</mo>
                  </mrow>
                  <mn>2</mn>
                </mrow>
              </msup>
            </mrow> </math
          >, mantenha, junto com o expoente
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          e a base
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi> </math>,
          uma variável de estado adicional
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>,
          e defina a transformação de estado de tal forma que o produto
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <msup>
                <mi>b</mi>
                <mi>n</mi>
              </msup>
            </mrow>
          </math>
          permaneça inalterado de estado para estado. No início do processo,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          é tomado como 1, e a resposta é dada pelo valor de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          no final do processo. Em geral, a técnica de definir uma
          <a id="index-invariant-quantity"></a>
          <em>quantidade invariante</em> que permanece inalterada de estado para
          estado é uma maneira poderosa de pensar sobre o projeto de algoritmos
          iterativos.)
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e17"></a>Exercício 1.17:</strong> Os
          algoritmos de exponenciação nesta seção são baseados na realização de
          exponenciação por meio de multiplicação repetida. De maneira
          semelhante, pode-se realizar a multiplicação de inteiros por meio de
          adição repetida. O seguinte procedimento de multiplicação (no qual se
          assume que nossa linguagem só pode somar, não multiplicar) é análogo
          ao procedimento <code>expt</code>:
        </p>
        <pre><code class="language-scheme">
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
                </code></pre>

        <p>
          Este algoritmo leva um número de passos que é linear em
          <code>b</code>. Agora suponha que incluamos, junto com a adição,
          operações <code>double</code>, que dobra um inteiro, e
          <code>halve</code>, que divide um inteiro (par) por 2. Usando essas
          operações, projete um procedimento de multiplicação análogo ao
          <code>fast-expt</code> que use um número logarítmico de passos.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e18"></a>Exercício 1.18:</strong> Usando
          os resultados de <a href="#Exercise-1_002e16">Exercício 1.16</a> e
          <a href="#Exercise-1_002e17">Exercício 1.17</a>, crie um procedimento
          que gere um processo iterativo para multiplicar dois inteiros em
          termos de adição, dobra e divisão por dois, e use um número
          logarítmico de passos.<a
            class="footnote_link"
            id="DOCF40"
            href="#FOOT40"
            ><sup>40</sup></a
          >
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e19"></a>Exercício 1.19:</strong> Existe
          um algoritmo inteligente para calcular os números de Fibonacci em um
          número logarítmico de passos. Lembre-se da transformação das variáveis
          de estado
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi>
          </math>
          no processo <code>fib-iter</code> de
          <a href="#g_t1_002e2_002e2">1.2.2</a>:
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
            <mo stretchy="false">←<!-- ← --></mo>
            <mi>a</mi>
            <mo>+</mo>
            <mi>b</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi>
            <mo stretchy="false">←<!-- ← --></mo>
            <mi>a</mi> </math
          >. Chame essa transformação de
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>T</mi> </math>,
          e observe que aplicar
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>T</mi>
          </math>
          repetidamente
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          vezes, começando com 1 e 0, produz o par
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mtext>Fib</mtext>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>+</mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mtext>Fib</mtext>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. Em outras palavras, os números de Fibonacci são produzidos
          aplicando
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>T</mi>
              <mi>n</mi>
            </msup> </math
          >, a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>ésima</mtext>
              </mrow>
            </msup>
          </math>
          potência da transformação
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>T</mi> </math>,
          começando com o par (1, 0). Agora considere
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>T</mi>
          </math>
          como o caso especial de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>p</mi>
              <mo>=</mo>
              <mn>0</mn>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>q</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
          </math>
          em uma família de transformações
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>T</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>p</mi>
                <mi>q</mi>
              </mrow>
            </msub> </math
          >, onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>T</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>p</mi>
                <mi>q</mi>
              </mrow>
            </msub>
          </math>
          transforma o par
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>a</mi>
              <mo>,</mo>
              <mi>b</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          de acordo com
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
            <mo stretchy="false">←<!-- ← --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>b</mi>
              <mi>q</mi>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mi>q</mi>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mi>p</mi>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi>
            <mo stretchy="false">←<!-- ← --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>b</mi>
              <mi>p</mi>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mi>q</mi>
            </mrow> </math
          >. Mostre que, se aplicarmos tal transformação
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>T</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>p</mi>
                <mi>q</mi>
              </mrow>
            </msub>
          </math>
          duas vezes, o efeito é o mesmo que usar uma única transformação
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>T</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <msup>
                  <mi>p</mi>
                  <mo>′</mo>
                </msup>
                <msup>
                  <mi>q</mi>
                  <mo>′</mo>
                </msup>
              </mrow>
            </msub>
          </math>
          da mesma forma, e calcule
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>p</mi>
              <mo>′</mo>
            </msup>
            <mspace width="negativethinmathspace" />
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>q</mi>
              <mo>′</mo>
            </msup>
            <mspace width="negativethinmathspace" />
          </math>
          em termos de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>p</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>q</mi> </math>.
          Isso nos dá uma maneira explícita de elevar essas transformações ao
          quadrado, e assim podemos calcular
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>T</mi>
              <mi>n</mi>
            </msup>
          </math>
          usando quadrados sucessivos, como no procedimento
          <code>fast-expt</code>. Junte tudo isso para completar o seguinte
          procedimento, que é executado em um número logarítmico de passos:<a
            class="footnote_link"
            id="DOCF41"
            href="#FOOT41"
            ><sup>41</sup></a
          >
        </p>
        <pre><code class="language-scheme">
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) 
          b)
        ((even? count)
          (fib-iter a
                    b
                    ⟨??⟩  ;compute p'
                    ⟨??⟩  ;compute q'
                    (/ count 2)))
        (else 
          (fib-iter (+ (* b q) 
                      (* a q) 
                      (* a p))
                    (+ (* b p) 
                      (* a q))
                    p
                    q
                    (- count 1)))))
                </code></pre>
      </blockquote>
      <a id="g_t1_002e2_002e5"></a>
      <a id="Greatest-Common-Divisors"></a>
      <h4 class="subsection">
        <span class="secnum">1.2.5</span
        ><span class="sectitle">Máximo Divisor Comum</span>
      </h4>

      <p>
        O máximo divisor comum (<abbr>MDC</abbr>) de dois inteiros
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        é definido como o maior inteiro que divide ambos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        sem deixar resto. Por exemplo, o <abbr>MDC</abbr> de 16 e 28 é 4. Em
        <a href="Chapter-2.html#Chapter-2">Capítulo 2</a>, quando investigarmos
        como implementar a aritmética de números racionais, precisaremos ser
        capazes de calcular <abbr>MDC</abbr>s para reduzir números racionais à
        sua forma mais simples. (Para reduzir um número racional à sua forma
        mais simples, devemos dividir tanto o numerador quanto o denominador
        pelo seu <abbr>MDC</abbr>. Por exemplo, 16/28 reduz-se a 4/7.) Uma
        maneira de encontrar o <abbr>MDC</abbr> de dois inteiros é fatorá-los e
        procurar por fatores comuns, mas existe um algoritmo famoso que é muito
        mais eficiente.
      </p>
      <p>
        A ideia do algoritmo é baseada na observação de que, se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>r</mi>
        </math>
        é o resto quando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        é dividido por
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi> </math>,
        então os divisores comuns de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        são exatamente os mesmos que os divisores comuns de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>r</mi> </math>.
        Assim, podemos usar a equação
      </p>
      <div class="example">
        <pre class="example">
        MDC(a,b) = MDC(b,r)
        </pre>
      </div>

      <p>
        para reduzir sucessivamente o problema de calcular um
        <abbr>MDC</abbr> ao problema de calcular o <abbr>MDC</abbr> de pares de
        inteiros cada vez menores. Por exemplo,
      </p>
      <div class="example">
        <pre class="example">
        MDC(206,40) = MDC(40,6)
                    = MDC(6,4)
                    = MDC(4,2)
                    = MDC(2,0) = 2
        </pre>
      </div>

      <p>
        reduz <abbr>MDC</abbr>(206, 40) a <abbr>MDC</abbr>(2, 0), que é 2. É
        possível mostrar que, começando com quaisquer dois inteiros positivos e
        realizando reduções repetidas, sempre se chegará eventualmente a um par
        onde o segundo número é 0. Então, o <abbr>MDC</abbr> é o outro número no
        par. Esse método para calcular o <abbr>MDC</abbr> é conhecido como
        <a id="index-Euclid_0027s-Algorithm"></a>
        <em>Algoritmo de Euclides</em>.<a
          class="footnote_link"
          id="DOCF42"
          href="#FOOT42"
          ><sup>42</sup></a
        >
      </p>
      <p>É fácil expressar o Algoritmo de Euclides como um procedimento:</p>
      <pre><code class="language-scheme">
(define (gcd a b)
  (if (= b 0)
    a
    (gcd b (remainder a b))))
              </code></pre>

      <p>
        Isso gera um processo iterativo, cujo número de passos cresce como o
        logaritmo dos números envolvidos.
      </p>
      <p>
        O fato de que o número de passos necessários para o Algoritmo de
        Euclides ter crescimento logarítmico tem uma relação interessante com os
        números de Fibonacci:
      </p>
      <blockquote>
        <p>
          <strong>Teorema de Lamé:</strong> Se o Algoritmo de Euclides requer
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>k</mi>
          </math>
          passos para calcular o <abbr>MDC</abbr> de algum par, então o menor
          número no par deve ser maior ou igual ao
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>k</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>ésimo</mtext>
              </mrow>
            </msup>
          </math>
          número de Fibonacci.<a
            class="footnote_link"
            id="DOCF43"
            href="#FOOT43"
            ><sup>43</sup></a
          >
        </p>
      </blockquote>

      <p>
        Podemos usar esse teorema para obter uma estimativa da ordem de
        crescimento do Algoritmo de Euclides. Seja
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        o menor dos dois números de entrada para o procedimento. Se o processo
        leva
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>k</mi>
        </math>
        passos, então devemos ter
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
          <mo>≥<!-- ≥ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mtext>Fib</mtext>
            <mo stretchy="false">(</mo>
            <mi>k</mi>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>≈<!-- ≈ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <msup>
              <mi>φ<!-- φ --></mi>
              <mi>k</mi>
            </msup>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <msqrt>
              <mn>5</mn>
            </msqrt>
          </mrow> </math
        >. Portanto, o número de passos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>k</mi>
        </math>
        cresce como o logaritmo (na base
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>φ<!-- φ --></mi> </math
        >) de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Assim, a ordem de crescimento é
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e20"></a>Exercício 1.20:</strong> O
          processo que um procedimento gera é, é claro, dependente das regras
          usadas pelo interpretador. Como exemplo, considere o procedimento
          iterativo <code>gcd</code> dado acima. Suponha que interpretássemos
          esse procedimento usando avaliação de ordem normal, como discutido em
          <a href="1_002e1.html#g_t1_002e1_002e5">1.1.5</a>. (A regra de
          avaliação de ordem normal para <code>if</code> é descrita em
          <a href="1_002e1.html#Exercise-1_002e5">Exercício 1.5</a>.) Usando o
          método de substituição (para ordem normal), ilustre o processo gerado
          na avaliação de <code>(gcd 206 40)</code> e indique as operações
          <code>remainder</code> que são realmente realizadas. Quantas operações
          <code>remainder</code> são realmente realizadas na avaliação de ordem
          normal de <code>(gcd 206 40)</code>? E na avaliação de ordem
          aplicativa?
        </p>
      </blockquote>

      <a id="g_t1_002e2_002e6"></a>
      <a id="Example_003a-Testing-for-Primality"></a>
      <h4 class="subsection">
        <span class="secnum">1.2.6</span
        ><span class="sectitle">Exemplo: Teste de Primalidade</span>
      </h4>

      <p>
        Esta seção descreve dois métodos para verificar a primalidade de um
        inteiro
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>, um
        com ordem de crescimento
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <msqrt>
              <mi>n</mi>
            </msqrt>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, e um algoritmo “probabilístico” com ordem de crescimento
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. Os exercícios no final desta seção sugerem projetos de programação
        baseados nesses algoritmos.
      </p>
      <a id="Searching-for-divisors"></a>
      <h5 class="subsubheading">Buscando por divisores</h5>

      <p>
        Desde os tempos antigos, os matemáticos têm sido fascinados por
        problemas relacionados a números primos, e muitas pessoas trabalharam no
        problema de determinar maneiras de testar se números são primos. Uma
        maneira de testar se um número é primo é encontrar os divisores do
        número. O seguinte programa encontra o menor divisor inteiro (maior que
        1) de um número dado
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        Ele faz isso de maneira direta, testando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        para divisibilidade por inteiros sucessivos começando com 2.
      </p>
      <pre><code class="language-scheme">
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) 
        n)
      ((divides? test-divisor n) 
        test-divisor)
      (else (find-divisor 
              n 
              (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))
              </code></pre>

      <p>
        Podemos testar se um número é primo da seguinte forma:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        é primo se e somente se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        for seu próprio menor divisor.
      </p>
      <pre><code class="language-scheme">
(define (prime? n)
  (= n (smallest-divisor n)))
              </code></pre>

      <p>
        O teste final para <code>find-divisor</code> é baseado no fato de que,
        se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        não for primo, ele deve ter um divisor menor ou igual a
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msqrt>
            <mi>n</mi>
          </msqrt> </math
        >.<a class="footnote_link" id="DOCF44" href="#FOOT44"><sup>44</sup></a>
        Isso significa que o algoritmo precisa testar apenas divisores entre 1 e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msqrt>
            <mi>n</mi>
          </msqrt> </math
        >. Consequentemente, o número de passos necessários para identificar
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        como primo terá ordem de crescimento
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <msqrt>
              <mi>n</mi>
            </msqrt>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >.
      </p>
      <a id="The-Fermat-test"></a>
      <h5 class="subsubheading">O teste de Fermat</h5>

      <p>
        O teste de primalidade com ordem de crescimento
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        é baseado em um resultado da teoria dos números conhecido como o Pequeno
        Teorema de Fermat.<a class="footnote_link" id="DOCF45" href="#FOOT45"
          ><sup>45</sup></a
        >
      </p>
      <blockquote>
        <p>
          <strong>Pequeno Teorema de Fermat:</strong> Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          é um número primo e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          é qualquer inteiro positivo menor que
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
          então
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          elevado à
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>ésima</mtext>
              </mrow>
            </msup>
          </math>
          potência é congruente a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
        </p>
      </blockquote>

      <p>
        (Dois números são ditos <a id="index-congruent-modulo"></a>
        <em>congruentes módulo</em>
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        se ambos têm o mesmo resto quando divididos por
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>. O
        resto de um número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        quando dividido por
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        também é referido como o <a id="index-remainder-of"></a>
        <em>resto de</em>
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        <a id="index-modulo"></a>
        <em>módulo</em>
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>, ou
        simplesmente como
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        <a id="index-modulo-1"></a> <em>módulo</em>
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.)
      </p>
      <p>
        Se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        não for primo, então, em geral, a maioria dos números
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>a</mi>
            <mo>&lt;</mo>
            <mi>n</mi>
          </mrow>
        </math>
        não satisfará a relação acima. Isso leva ao seguinte algoritmo para
        testar primalidade: Dado um número
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
        escolha um número aleatório
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>a</mi>
            <mo>&lt;</mo>
            <mi>n</mi>
          </mrow>
        </math>
        e calcule o resto de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>a</mi>
            <mi>n</mi>
          </msup>
        </math>
        módulo
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>. Se
        o resultado não for igual a
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>,
        então
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        certamente não é primo. Se for
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>,
        então as chances são boas de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        seja primo. Agora escolha outro número aleatório
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e teste-o com o mesmo método. Se ele também satisfizer a equação, então
        podemos ter ainda mais confiança de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        é primo. Ao tentar mais e mais valores de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>,
        podemos aumentar nossa confiança no resultado. Esse algoritmo é
        conhecido como o teste de Fermat.
      </p>
      <p>
        Para implementar o teste de Fermat, precisamos de um procedimento que
        calcule a exponencial de um número módulo outro número:
      </p>
      <pre><code class="language-scheme">
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
          (remainder 
          (square (expmod base (/ exp 2) m))
          m))
        (else
          (remainder 
          (* base (expmod base (- exp 1) m))
          m))))
              </code></pre>

      <p>
        Isso é muito semelhante ao procedimento <code>fast-expt</code> de
        <a href="#g_t1_002e2_002e4">1.2.4</a>. Ele usa quadrados sucessivos, de
        modo que o número de passos cresce logaritmicamente com o expoente.<a
          class="footnote_link"
          id="DOCF46"
          href="#FOOT46"
          ><sup>46</sup></a
        >
      </p>
      <p>
        O teste de Fermat é realizado escolhendo aleatoriamente um número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        entre 1 e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>−<!-- − --></mo>
            <mn>1</mn>
          </mrow>
        </math>
        inclusive e verificando se o resto módulo
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        da
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>n</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mtext>ésima</mtext>
            </mrow>
          </msup>
        </math>
        potência de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        é igual a
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>. O
        número aleatório
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        é escolhido usando o procedimento <code>random</code>, que assumimos
        estar incluído como primitivo no Scheme. <code>Random</code> retorna um
        inteiro não negativo menor que sua entrada inteira. Portanto, para obter
        um número aleatório entre 1 e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>−<!-- − --></mo>
            <mn>1</mn>
          </mrow> </math
        >, chamamos <code>random</code> com uma entrada de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
            <mo>−<!-- − --></mo>
            <mn>1</mn>
          </mrow>
        </math>
        e adicionamos 1 ao resultado:
      </p>
      <pre><code class="language-scheme">
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
              </code></pre>

      <p>
        O seguinte procedimento executa o teste um número determinado de vezes,
        como especificado por um parâmetro. Seu valor é verdadeiro se o teste
        for bem-sucedido todas as vezes, e falso caso contrário.
      </p>
      <pre><code class="language-scheme">
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) 
          (fast-prime? n (- times 1)))
        (else false)))
              </code></pre>

      <a id="Probabilistic-methods"></a>
      <h5 class="subsubheading">Métodos probabilísticos</h5>

      <p>
        O teste de Fermat difere em caráter da maioria dos algoritmos
        familiares, nos quais se calcula uma resposta que é garantidamente
        correta. Aqui, a resposta obtida é apenas provavelmente correta. Mais
        precisamente, se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        falhar no teste de Fermat, podemos ter certeza de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        não é primo. Mas o fato de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        passar no teste, embora seja uma indicação extremamente forte, ainda não
        é uma garantia de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        seja primo. O que gostaríamos de dizer é que, para qualquer número
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>, se
        realizarmos o teste suficientes vezes e descobrirmos que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        sempre passa no teste, então a probabilidade de erro em nosso teste de
        primalidade pode ser tão pequena quanto desejarmos.
      </p>
      <p>
        Infelizmente, essa afirmação não é totalmente correta. Existem números
        que enganam o teste de Fermat: números
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        que não são primos e ainda têm a propriedade de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>a</mi>
            <mi>n</mi>
          </msup>
        </math>
        é congruente a
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        módulo
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        para todos os inteiros
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>a</mi>
            <mo>&lt;</mo>
            <mi>n</mi>
          </mrow> </math
        >. Tais números são extremamente raros, então o teste de Fermat é
        bastante confiável na prática.<a
          class="footnote_link"
          id="DOCF47"
          href="#FOOT47"
          ><sup>47</sup></a
        >
      </p>
      <p>
        Existem variações do teste de Fermat que não podem ser enganadas. Nesses
        testes, assim como no método de Fermat, testa-se a primalidade de um
        inteiro
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        escolhendo um inteiro aleatório
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>a</mi>
            <mo>&lt;</mo>
            <mi>n</mi>
          </mrow>
        </math>
        e verificando alguma condição que depende de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>.
        (Veja <a href="#Exercise-1_002e28">Exercício 1.28</a> para um exemplo de
        tal teste.) Por outro lado, em contraste com o teste de Fermat, pode-se
        provar que, para qualquer
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>, a
        condição não se mantém para a maioria dos inteiros
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>a</mi>
            <mo>&lt;</mo>
            <mi>n</mi>
          </mrow>
        </math>
        a menos que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        seja primo. Assim, se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        passar no teste para alguma escolha aleatória de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>, as
        chances são melhores do que 50% de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        seja primo. Se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        passar no teste para duas escolhas aleatórias de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>, as
        chances são melhores do que 75% de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>n</mi>
        </math>
        seja primo. Ao executar o teste com mais e mais valores escolhidos
        aleatoriamente de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi> </math
        >, podemos tornar a probabilidade de erro tão pequena quanto desejarmos.
      </p>
      <p>
        A existência de testes para os quais se pode provar que a chance de erro
        se torna arbitrariamente pequena despertou interesse em algoritmos desse
        tipo, que passaram a ser conhecidos como
        <a id="index-probabilistic-algorithms"></a>
        <em>algoritmos probabilísticos</em>. Há muita atividade de pesquisa
        nessa área, e algoritmos probabilísticos têm sido aplicados com sucesso
        em muitos campos.<a class="footnote_link" id="DOCF48" href="#FOOT48"
          ><sup>48</sup></a
        >
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e21"></a>Exercício 1.21:</strong> Use o
          procedimento <code>smallest-divisor</code> para encontrar o menor
          divisor de cada um dos seguintes números: 199, 1999, 19999.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e22"></a>Exercício 1.22:</strong> A
          maioria das implementações de Lisp inclui uma primitiva chamada
          <code>runtime</code> que retorna um inteiro que especifica a
          quantidade de tempo que o sistema está em execução (medido, por
          exemplo, em microssegundos). O seguinte procedimento
          <code>timed-prime-test</code>, quando chamado com um inteiro
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
          imprime
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          e verifica se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          é primo. Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          for primo, o procedimento imprime três asteriscos seguidos pela
          quantidade de tempo usada para realizar o teste.
        </p>
        <pre><code class="language-scheme">
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) 
                        start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
                </code></pre>

        <p>
          Usando esse procedimento, escreva um procedimento
          <code>search-for-primes</code> que verifique a primalidade de números
          ímpares consecutivos em um intervalo especificado. Use seu
          procedimento para encontrar os três menores primos maiores que 1000;
          maiores que 10.000; maiores que 100.000; maiores que 1.000.000.
          Observe o tempo necessário para testar cada primo. Como o algoritmo de
          teste tem ordem de crescimento de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi mathvariant="normal">Θ<!-- Θ --></mi>
              <mo stretchy="false">(</mo>
              <msqrt>
                <mi>n</mi>
              </msqrt>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >, você deve esperar que o teste para primos próximos de 10.000 leve
          cerca de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msqrt>
              <mn>10</mn>
            </msqrt>
          </math>
          vezes mais tempo do que o teste para primos próximos de 1000. Seus
          dados de tempo confirmam isso? Quão bem os dados para 100.000 e
          1.000.000 suportam a previsão de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi mathvariant="normal">Θ<!-- Θ --></mi>
              <mo stretchy="false">(</mo>
              <msqrt>
                <mi>n</mi>
              </msqrt>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          ? Seu resultado é compatível com a noção de que os programas em sua
          máquina são executados em tempo proporcional ao número de passos
          necessários para a computação?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e23"></a>Exercício 1.23:</strong> O
          procedimento <code>smallest-divisor</code> mostrado no início desta
          seção faz muitos testes desnecessários: depois de verificar se o
          número é divisível por 2, não há sentido em verificar se ele é
          divisível por qualquer número par maior. Isso sugere que os valores
          usados para <code>test-divisor</code> não devem ser 2, 3, 4, 5, 6, …,
          mas sim 2, 3, 5, 7, 9, …. Para implementar essa mudança, defina um
          procedimento <code>next</code> que retorne 3 se sua entrada for igual
          a 2 e, caso contrário, retorne sua entrada mais 2. Modifique o
          procedimento <code>smallest-divisor</code> para usar
          <code>(next test-divisor)</code> em vez de
          <code>(+ test-divisor 1)</code>. Com
          <code>timed-prime-test</code> incorporando essa versão modificada de
          <code>smallest-divisor</code>, execute o teste para cada um dos 12
          primos encontrados em <a href="#Exercise-1_002e22">Exercício 1.22</a>.
          Como essa modificação reduz o número de passos de teste pela metade,
          você deve esperar que ele execute cerca de duas vezes mais rápido.
          Essa expectativa é confirmada? Se não, qual é a razão observada entre
          as velocidades dos dois algoritmos, e como você explica o fato de que
          ela é diferente de 2?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e24"></a>Exercício 1.24:</strong>
          Modifique o procedimento <code>timed-prime-test</code> de
          <a href="#Exercise-1_002e22">Exercício 1.22</a> para usar
          <code>fast-prime?</code> (o método de Fermat) e teste cada um dos 12
          primos que você encontrou naquele exercício. Como o teste de Fermat
          tem ordem de crescimento
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi mathvariant="normal">Θ<!-- Θ --></mi>
              <mo stretchy="false">(</mo>
              <mi>log</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          , como você esperaria que o tempo para testar primos próximos de
          1.000.000 se comparasse ao tempo necessário para testar primos
          próximos de 1000? Seus dados confirmam isso? Você consegue explicar
          qualquer discrepância que encontrar?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e25"></a>Exercício 1.25:</strong> Alyssa
          P. Hacker reclama que fizemos muito trabalho extra ao escrever
          <code>expmod</code>. Afinal, ela diz, já sabemos como calcular
          exponenciais, então poderíamos simplesmente ter escrito
        </p>
        <pre><code class="language-scheme">
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
                </code></pre>

        <p>
          Ela está correta? Esse procedimento serviria tão bem para nosso teste
          de primalidade rápido? Explique.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e26"></a>Exercício 1.26:</strong> Louis
          Reasoner está tendo grande dificuldade em fazer
          <a href="#Exercise-1_002e24">Exercício 1.24</a>. Seu teste
          <code>fast-prime?</code> parece ser mais lento que o teste
          <code>prime?</code>. Louis chama sua amiga Eva Lu Ator para ajudar.
          Quando eles examinam o código de Louis, descobrem que ele reescreveu o
          procedimento <code>expmod</code> para usar uma multiplicação
          explícita, em vez de chamar <code>square</code>:
        </p>
        <pre><code class="language-scheme">
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
          (remainder 
          (* (expmod base (/ exp 2) m)
              (expmod base (/ exp 2) m))
          m))
        (else
          (remainder 
          (* base 
              (expmod base (- exp 1) m))
          m))))
                </code></pre>

        <p>
          “Eu não vejo que diferença isso faz,” diz Louis. “Eu vejo,” diz Eva.
          “Ao escrever o procedimento dessa forma, você transformou o processo
          de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi mathvariant="normal">Θ<!-- Θ --></mi>
              <mo stretchy="false">(</mo>
              <mi>log</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          em um processo de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi mathvariant="normal">Θ<!-- Θ --></mi>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          .” Explique.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e27"></a>Exercício 1.27:</strong>
          Demonstre que os números de Carmichael listados em
          <a href="#Footnote-47">Nota de rodapé 47</a> realmente enganam o teste
          de Fermat. Ou seja, escreva um procedimento que receba um inteiro
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          e teste se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>a</mi>
              <mi>n</mi>
            </msup>
          </math>
          é congruente a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          para todo
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mo>&lt;</mo>
              <mi>n</mi>
            </mrow> </math
          >, e tente seu procedimento nos números de Carmichael fornecidos.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e28"></a>Exercício 1.28:</strong> Uma
          variante do teste de Fermat que não pode ser enganada é chamada de
          <a id="index-Miller_002dRabin-test"></a>
          <em>teste de Miller-Rabin</em> (<a href="References.html#Miller-1976"
            >Miller 1976</a
          >; <a href="References.html#Rabin-1980">Rabin 1980</a>). Ele começa a
          partir de uma forma alternativa do Pequeno Teorema de Fermat, que
          afirma que, se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          é um número primo e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          é qualquer inteiro positivo menor que
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
          então
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          elevado à
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>−<!-- − --></mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >-ésima potência é congruente a 1 módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
          Para testar a primalidade de um número
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          pelo teste de Miller-Rabin, escolhemos um número aleatório
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mo>&lt;</mo>
              <mi>n</mi>
            </mrow>
          </math>
          e elevamos
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          à
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>−<!-- − --></mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >-ésima potência módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          usando o procedimento <code>expmod</code>. No entanto, sempre que
          realizamos o passo de elevar ao quadrado em <code>expmod</code>,
          verificamos se descobrimos uma “raiz quadrada não trivial de 1 módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,”
          ou seja, um número diferente de 1 ou
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>−<!-- − --></mo>
              <mn>1</mn>
            </mrow>
          </math>
          cujo quadrado é igual a 1 módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
          É possível provar que, se tal raiz quadrada não trivial de 1 existir,
          então
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          não é primo. Também é possível provar que, se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          for um número ímpar que não é primo, então, para pelo menos metade dos
          números
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mo>&lt;</mo>
              <mi>n</mi>
            </mrow> </math
          >, calcular
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>a</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mo>−<!-- − --></mo>
                <mn>1</mn>
              </mrow>
            </msup>
          </math>
          dessa maneira revelará uma raiz quadrada não trivial de 1 módulo
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>.
          (É por isso que o teste de Miller-Rabin não pode ser enganado.)
          Modifique o procedimento <code>expmod</code> para sinalizar se ele
          descobre uma raiz quadrada não trivial de 1, e use isso para
          implementar o teste de Miller-Rabin com um procedimento análogo a
          <code>fermat-test</code>. Verifique seu procedimento testando vários
          primos e não primos conhecidos. Dica: Uma maneira conveniente de fazer
          <code>expmod</code> sinalizar é fazê-lo retornar 0.
        </p>
      </blockquote>
      <div class="footnote">
        <h4 class="footnotes-heading">Notas de rodapé</h4>

        <div id="FOOT29">
          <p>
            <a class="footnote_backlink" href="#DOCF29"><sup>29</sup></a>
            Em um programa real, provavelmente usaríamos a estrutura de blocos
            introduzida na última seção para esconder a definição de
            <code>fact-iter</code>:
          </p>
          <pre><code class="language">
        (define (factorial n)
          (define (iter product counter)
            (if (> counter n)
                product
                (iter (* counter product)
                      (+ counter 1))))
          (iter 1 1))
                  </code></pre>

          <p>
            Evitamos fazer isso aqui para minimizar o número de coisas a serem
            consideradas de uma só vez.
          </p>
        </div>
        <div id="FOOT30">
          <p>
            <a class="footnote_backlink" href="#DOCF30"><sup>30</sup></a> Quando
            discutimos a implementação de procedimentos em máquinas de
            registradores em <a href="Chapter-5.html#Chapter-5">Capítulo 5</a>,
            veremos que qualquer processo iterativo pode ser realizado “em
            hardware” como uma máquina que tem um conjunto fixo de registradores
            e nenhuma memória auxiliar. Em contraste, a realização de um
            processo recursivo requer uma máquina que usa uma estrutura de dados
            auxiliar conhecida como <a id="index-stack"></a> <em>pilha</em>.
          </p>
        </div>
        <div id="FOOT31">
          <p>
            <a class="footnote_backlink" href="#DOCF31"><sup>31</sup></a> A
            recursão em cauda é conhecida há muito tempo como uma otimização de
            compilador. Uma base semântica coerente para a recursão em cauda foi
            fornecida por Carl
            <a href="References.html#Hewitt-_00281977_0029">Hewitt (1977)</a>,
            que a explicou em termos do modelo de computação de “passagem de
            mensagens” que discutiremos em
            <a href="Chapter-3.html#Chapter-3">Capítulo 3</a>. Inspirados por
            isso, Gerald Jay Sussman e Guy Lewis Steele Jr. (veja
            <a href="References.html#Steele-and-Sussman-1975"
              >Steele e Sussman 1975</a
            >) construíram um interpretador de recursão em cauda para Scheme.
            Steele mais tarde mostrou como a recursão em cauda é uma
            consequência natural da maneira de compilar chamadas de procedimento
            (<a href="References.html#Steele-1977">Steele 1977</a>). O padrão
            <abbr>IEEE</abbr> para Scheme exige que implementações de Scheme
            sejam recursivas em cauda.
          </p>
        </div>
        <div id="FOOT32">
          <p>
            <a class="footnote_backlink" href="#DOCF32"><sup>32</sup></a> Um
            exemplo disso foi sugerido em
            <a href="1_002e1.html#g_t1_002e1_002e3">1.1.3</a>. O próprio
            interpretador avalia expressões usando um processo recursivo em
            árvore.
          </p>
        </div>
        <div id="FOOT33">
          <p>
            <a class="footnote_backlink" href="#DOCF33"><sup>33</sup></a> Por
            exemplo, trabalhe detalhadamente como a regra de redução se aplica
            ao problema de dar troco para 10 centavos usando moedas de um e
            cinco centavos.
          </p>
        </div>
        <div id="FOOT34">
          <p>
            <a class="footnote_backlink" href="#DOCF34"><sup>34</sup></a> Uma
            abordagem para lidar com computações redundantes é organizar as
            coisas de modo que automaticamente construamos uma tabela de valores
            à medida que eles são computados. Cada vez que somos solicitados a
            aplicar o procedimento a algum argumento, primeiro verificamos se o
            valor já está armazenado na tabela, caso em que evitamos realizar a
            computação redundante. Essa estratégia, conhecida como
            <a id="index-tabulation"></a> <em>tabela</em> ou
            <a id="index-memoization"></a> <em>memorização</em>, pode ser
            implementada de maneira direta. A tabela pode às vezes ser usada
            para transformar processos que requerem um número exponencial de
            passos (como <code>count-change</code>) em processos cujos
            requisitos de espaço e tempo crescem linearmente com a entrada. Veja
            <a href="3_002e3.html#Exercise-3_002e27">Exercício 3.27</a>.
          </p>
        </div>
        <div id="FOOT35">
          <p>
            <a class="footnote_backlink" href="#DOCF35"><sup>35</sup></a> Os
            elementos do triângulo de Pascal são chamados de
            <a id="index-binomial-coefficients"></a>
            <em>coeficientes binomiais</em>, porque a
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msup>
                  <mi>n</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mtext>ésima</mtext>
                  </mrow>
                </msup>
              </mrow>
            </math>
            linha consiste nos coeficientes dos termos na expansão de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <mi>x</mi>
                <mo>+</mo>
                <mi>y</mi>
                <msup>
                  <mo stretchy="false">)</mo>
                  <mi>n</mi>
                </msup>
              </mrow> </math
            >. Esse padrão para calcular os coeficientes apareceu no trabalho
            seminal de Blaise Pascal sobre teoria da probabilidade,
            <cite>Traité du triangle arithmétique</cite>, de 1653. De acordo com
            <a href="References.html#Knuth-_00281973_0029">Knuth (1973)</a>, o
            mesmo padrão aparece no <cite>Szu-yuen Yü-chien</cite> (“O Espelho
            Precioso dos Quatro Elementos”), publicado pelo matemático chinês
            Chu Shih-chieh em 1303, nas obras do poeta e matemático persa Omar
            Khayyam do século XII, e nas obras do matemático hindu Bháscara
            Áchárya do século XII.
          </p>
        </div>
        <div id="FOOT36">
          <p>
            <a class="footnote_backlink" href="#DOCF36"><sup>36</sup></a> Essas
            afirmações mascaram uma grande quantidade de simplificação. Por
            exemplo, se contarmos os passos do processo como “operações de
            máquina”, estamos assumindo que o número de operações de máquina
            necessárias para realizar, digamos, uma multiplicação é independente
            do tamanho dos números a serem multiplicados, o que é falso se os
            números forem suficientemente grandes. Observações semelhantes valem
            para as estimativas de espaço. Assim como o projeto e a descrição de
            um processo, a análise de um processo pode ser realizada em vários
            níveis de abstração.
          </p>
        </div>
        <div id="FOOT37">
          <p>
            <a class="footnote_backlink" href="#DOCF37"><sup>37</sup></a> Mais
            precisamente, o número de multiplicações necessárias é igual a 1
            menos o logaritmo na base 2 de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>n</mi>
            </math>
            mais o número de uns na representação binária de
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math
            >. Esse total é sempre menor que duas vezes o logaritmo na base 2 de
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math
            >. As constantes arbitrárias
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>k</mi>
                <mn>1</mn>
              </msub>
            </math>
            e
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>k</mi>
                <mn>2</mn>
              </msub>
            </math>
            na definição da notação de ordem implicam que, para um processo
            logarítmico, a base à qual os logaritmos são tomados não importa,
            então todos esses processos são descritos como
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi mathvariant="normal">Θ<!-- Θ --></mi>
                <mo stretchy="false">(</mo>
                <mi>log</mi>
                <mo>⁡<!-- ⁡ --></mo>
                <mi>n</mi>
                <mo stretchy="false">)</mo>
              </mrow> </math
            >.
          </p>
        </div>
        <div id="FOOT38">
          <p>
            <a class="footnote_backlink" href="#DOCF38"><sup>38</sup></a> Você
            pode se perguntar por que alguém se importaria em elevar números à
            1000ª potência. Veja <a href="#g_t1_002e2_002e6">1.2.6</a>.
          </p>
        </div>
        <div id="FOOT39">
          <p>
            <a class="footnote_backlink" href="#DOCF39"><sup>39</sup></a> Esse
            algoritmo iterativo é antigo. Ele aparece no
            <cite>Chandah-sutra</cite> de Áchárya Pingala, escrito antes de 200
            <abbr>a.C.</abbr> Veja
            <a href="References.html#Knuth-1981">Knuth 1981</a>, seção 4.6.3,
            para uma discussão completa e análise desse e de outros métodos de
            exponenciação.
          </p>
        </div>
        <div id="FOOT40">
          <p>
            <a class="footnote_backlink" href="#DOCF40"><sup>40</sup></a> Esse
            algoritmo, às vezes conhecido como o “método do camponês russo” de
            multiplicação, é antigo. Exemplos de seu uso são encontrados no
            Papiro Rhind, um dos dois documentos matemáticos mais antigos
            existentes, escrito por volta de 1700 <abbr>a.C.</abbr> (e copiado
            de um documento ainda mais antigo) por um escriba egípcio chamado
            A’h-mose.
          </p>
        </div>
        <div id="FOOT41">
          <p>
            <a class="footnote_backlink" href="#DOCF41"><sup>41</sup></a> Esse
            exercício foi sugerido a nós por Joe Stoy, com base em um exemplo em
            <a href="References.html#Kaldewaij-1990">Kaldewaij 1990</a>.
          </p>
        </div>
        <div id="FOOT42">
          <p>
            <a class="footnote_backlink" href="#DOCF42"><sup>42</sup></a> O
            Algoritmo de Euclides é assim chamado porque aparece nos
            <cite>Elementos</cite> de Euclides (Livro 7, ca. 300
            <abbr>a.C.</abbr>). De acordo com
            <a href="References.html#Knuth-_00281973_0029">Knuth (1973)</a>, ele
            pode ser considerado o algoritmo não trivial mais antigo conhecido.
            O método egípcio antigo de multiplicação (<a
              href="#Exercise-1_002e18"
              >Exercício 1.18</a
            >) é certamente mais antigo, mas, como Knuth explica, o algoritmo de
            Euclides é o mais antigo conhecido por ter sido apresentado como um
            algoritmo geral, em vez de um conjunto de exemplos ilustrativos.
          </p>
        </div>
        <div id="FOOT43">
          <p>
            <a class="footnote_backlink" href="#DOCF43"><sup>43</sup></a> Esse
            teorema foi provado em 1845 por Gabriel Lamé, um matemático e
            engenheiro francês conhecido principalmente por suas contribuições à
            física matemática. Para provar o teorema, consideramos pares
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mi>k</mi>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow> </math
            >, onde
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>a</mi>
                  <mi>k</mi>
                </msub>
                <mo>≥<!-- ≥ --></mo>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
              </mrow> </math
            >, para os quais o Algoritmo de Euclides termina em
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>k</mi>
            </math>
            passos. A prova é baseada na afirmação de que, se
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow>
              <mo stretchy="false">→<!-- → --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mi>k</mi>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow>
              <mo stretchy="false">→<!-- → --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow>
            </math>
            são três pares sucessivos no processo de redução, então devemos ter
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <msub>
                <mi>b</mi>
                <mi>k</mi>
              </msub>
              <mo>+</mo>
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub> </math
            >. Para verificar a afirmação, considere que um passo de redução é
            definido pela aplicação da transformação
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>a</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
              </mrow> </math
            >,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>=</mo>
              </mrow>
            </math>
            resto de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mi>k</mi>
              </msub>
            </math>
            dividido por
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mi>k</mi>
              </msub> </math
            >. A segunda equação significa que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mi>k</mi>
              </msub>
              <mo>=</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>q</mi>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
              </mrow>
            </math>
            para algum inteiro positivo
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>q</mi> </math
            >. E como
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>q</mi>
            </math>
            deve ser pelo menos 1, temos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mi>k</mi>
              </msub>
              <mo>=</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>q</mi>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
              </mrow>
              <mo>+</mo>
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <msub>
                <mi>b</mi>
                <mi>k</mi>
              </msub>
              <mo>+</mo>
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub> </math
            >. Mas no passo de redução anterior temos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>=</mo>
              <msub>
                <mi>a</mi>
                <mi>k</mi>
              </msub> </math
            >. Portanto,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>=</mo>
              <msub>
                <mi>a</mi>
                <mi>k</mi>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <msub>
                <mi>b</mi>
                <mi>k</mi>
              </msub>
              <mo>+</mo>
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub> </math
            >. Isso verifica a afirmação. Agora podemos provar o teorema por
            indução em
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>k</mi> </math
            >, o número de passos que o algoritmo requer para terminar. O
            resultado é verdadeiro para
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>k</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow> </math
            >, já que isso apenas requer que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>b</mi>
            </math>
            seja pelo menos tão grande quanto
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>Fib</mtext>
                <mo stretchy="false">(</mo>
                <mn>1</mn>
                <mo stretchy="false">)</mo>
                <mo>=</mo>
                <mn>1</mn>
              </mrow> </math
            >. Agora, assuma que o resultado é verdadeiro para todos os inteiros
            menores ou iguais a
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>k</mi>
            </math>
            e estabeleça o resultado para
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>k</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow> </math
            >. Seja
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow>
              <mo stretchy="false">→<!-- → --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mi>k</mi>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow>
              <mo stretchy="false">→<!-- → --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>a</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>b</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>k</mi>
                    <mo>−<!-- − --></mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow>
            </math>
            pares sucessivos no processo de redução. Por nossas hipóteses de
            indução, temos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>Fib</mtext>
                <mo stretchy="false">(</mo>
                <mi>k</mi>
                <mo>−<!-- − --></mo>
                <mn>1</mn>
                <mo stretchy="false">)</mo>
              </mrow>
            </math>
            e
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mi>k</mi>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>Fib</mtext>
                <mo stretchy="false">(</mo>
                <mi>k</mi>
                <mo stretchy="false">)</mo>
              </mrow> </math
            >. Assim, aplicando a afirmação que acabamos de provar junto com a
            definição dos números de Fibonacci, temos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <msub>
                <mi>b</mi>
                <mi>k</mi>
              </msub>
              <mo>+</mo>
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>k</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≥<!-- ≥ --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>Fib</mtext>
                <mo stretchy="false">(</mo>
                <mi>k</mi>
                <mo stretchy="false">)</mo>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>Fib</mtext>
                <mo stretchy="false">(</mo>
                <mi>k</mi>
                <mo>−<!-- − --></mo>
                <mn>1</mn>
                <mo stretchy="false">)</mo>
              </mrow>
              <mo>=</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>Fib</mtext>
                <mo stretchy="false">(</mo>
                <mi>k</mi>
                <mo>+</mo>
                <mn>1</mn>
                <mo stretchy="false">)</mo>
              </mrow> </math
            >, o que completa a prova do Teorema de Lamé.
          </p>
        </div>
        <div id="FOOT44">
          <p>
            <a class="footnote_backlink" href="#DOCF44"><sup>44</sup></a> Se
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>d</mi>
            </math>
            é um divisor de
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math
            >, então
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mspace width="thinmathspace" />
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mspace width="thinmathspace" />
                <mi>d</mi>
              </mrow>
            </math>
            também é. Mas
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>d</mi>
            </math>
            e
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mspace width="thinmathspace" />
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mspace width="thinmathspace" />
                <mi>d</mi>
              </mrow>
            </math>
            não podem ser ambos maiores que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msqrt>
                <mi>n</mi>
              </msqrt> </math
            >.
          </p>
        </div>
        <div id="FOOT45">
          <p>
            <a class="footnote_backlink" href="#DOCF45"><sup>45</sup></a>
            Pierre de Fermat (1601-1665) é considerado o fundador da teoria dos
            números moderna. Ele obteve muitos resultados importantes na teoria
            dos números, mas geralmente anunciava apenas os resultados, sem
            fornecer suas provas. O Pequeno Teorema de Fermat foi declarado em
            uma carta que ele escreveu em 1640. A primeira prova publicada foi
            dada por Euler em 1736 (e uma prova idêntica foi descoberta nos
            manuscritos não publicados de Leibniz). O mais famoso dos resultados
            de Fermat—conhecido como o Último Teorema de Fermat—foi anotado em
            1637 em sua cópia do livro
            <cite>Aritmética</cite> (do matemático grego do século III Diofanto)
            com a observação “Eu descobri uma prova verdadeiramente maravilhosa,
            mas esta margem é muito pequena para contê-la.” Encontrar uma prova
            do Último Teorema de Fermat tornou-se um dos desafios mais famosos
            da teoria dos números. Uma solução completa foi finalmente dada em
            1995 por Andrew Wiles da Universidade de Princeton.
          </p>
        </div>
        <div id="FOOT46">
          <p>
            <a class="footnote_backlink" href="#DOCF46"><sup>46</sup></a>
            Os passos de redução nos casos em que o expoente
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>e</mi>
            </math>
            é maior que 1 são baseados no fato de que, para quaisquer inteiros
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math
            >,
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>y</mi> </math
            >, e
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>m</mi> </math
            >, podemos encontrar o resto de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>x</mi>
            </math>
            vezes
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>y</mi>
            </math>
            módulo
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>m</mi>
            </math>
            calculando separadamente os restos de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>x</mi>
            </math>
            módulo
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>m</mi>
            </math>
            e
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>y</mi>
            </math>
            módulo
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>m</mi> </math
            >, multiplicando esses valores e, em seguida, tomando o resto do
            resultado módulo
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>m</mi> </math
            >. Por exemplo, no caso em que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>e</mi>
            </math>
            é par, calculamos o resto de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>e</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo>/</mo>
                  </mrow>
                  <mn>2</mn>
                </mrow>
              </msup>
            </math>
            módulo
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>m</mi> </math
            >, elevamos ao quadrado e tomamos o resto módulo
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>m</mi> </math
            >. Essa técnica é útil porque significa que podemos realizar nossos
            cálculos sem precisar lidar com números muito maiores que
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>m</mi> </math
            >. (Compare com <a href="#Exercise-1_002e25">Exercício 1.25</a>.)
          </p>
        </div>
        <div id="FOOT47">
          <p>
            <a class="footnote_backlink" href="#DOCF47"><sup>47</sup></a>
            <a id="Footnote-47"></a>Números que enganam o teste de Fermat são
            chamados <a id="index-Carmichael-numbers"></a>
            <em>números de Carmichael</em>, e pouco se sabe sobre eles, exceto
            que são extremamente raros. Existem 255 números de Carmichael abaixo
            de 100.000.000. Os menores são 561, 1105, 1729, 2465, 2821 e 6601.
            Ao testar a primalidade de números muito grandes escolhidos
            aleatoriamente, a chance de encontrar um valor que engane o teste de
            Fermat é menor que a chance de a radiação cósmica causar um erro no
            computador ao executar um algoritmo "correto". Considerar um
            algoritmo inadequado pelo primeiro motivo, mas não pelo segundo,
            ilustra a diferença entre matemática e engenharia.
          </p>
        </div>
        <div id="FOOT48">
          <p>
            <a class="footnote_backlink" href="#DOCF48"><sup>48</sup></a> Uma
            das aplicações mais impressionantes do teste de primalidade
            probabilístico tem sido no campo da criptografia. Embora seja agora
            computacionalmente inviável fatorar um número arbitrário de 200
            dígitos, a primalidade de tal número pode ser verificada em alguns
            segundos com o teste de Fermat. Esse fato forma a base de uma
            técnica para construir "códigos inquebráveis" sugerida por
            <a href="References.html#Rivest-et-al_002e-_00281977_0029"
              >Rivest et al. (1977)</a
            >. O <a id="index-RSA-algorithm"></a>
            <em>algoritmo RSA</em> resultante tornou-se uma técnica amplamente
            utilizada para aumentar a segurança das comunicações eletrônicas.
            Por causa disso e de desenvolvimentos relacionados, o estudo dos
            números primos, uma vez considerado o epítome de um tópico da
            matemática "pura" a ser estudado apenas por si mesmo, agora se
            revela com importantes aplicações práticas em criptografia,
            transferência eletrônica de fundos e recuperação de informação.
          </p>
        </div>
      </div>
      <nav class="header">
        <p>
          Próximo:
          <a href="1_002e3.html#g_t1_002e3" accesskey="n" rel="next">1.3</a>,
          Anterior:
          <a href="1_002e1.html#g_t1_002e1" accesskey="p" rel="prev">1.1</a>,
          Acima: <a href="#g_t1_002e2" accesskey="u" rel="prev">1.2</a> [<a
            href="index.html#SEC_Contents"
            title="Table of contents"
            accesskey="c"
            rel="contents"
            >Sumário</a
          >]
        </p>
      </nav>
    </section>
    <span class="bottom jump" title="Pular para o final"
      ><a href="#pagebottom" accesskey="b">⇣</a></span
    ><a id="pagebottom"></a>
  </body>
</html>
