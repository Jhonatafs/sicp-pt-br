<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 4.2"
    />
    <meta
      name="keywords"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 4.2"
    />
    <title>
      Estrutura e Interpretação de Programas de Computador, 2ª edição: 4.2
    </title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/highlight.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="js/jquery.min.js"></script>
    <script src="js/footnotes.js"></script>
    <script src="js/browsertest.js"></script>
    <script src="js/light.js"></script>
  </head>
  <body>
    <section>
      <button id="button-light" onclick="lightStatus()">
        <span class="icon_theme"></span>
      </button>
      <a id="pagetop"></a>
      <a id="g_t4_002e2"></a>
      <nav class="header">
        <p>
          Próximo:
          <a href="4_002e3.html#g_t4_002e3" accesskey="n" rel="next">4.3</a>,
          Anterior:
          <a href="4_002e1.html#g_t4_002e1" accesskey="p" rel="prev">4.1</a>,
          Acima:
          <a href="Chapter-4.html#Chapter-4" accesskey="u" rel="prev"
            >Capítulo 4</a
          >
          [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Sumário</a
          >]
        </p>
      </nav>
      <a id="Variations-on-a-Scheme-_002d_002d_002d-Lazy-Evaluation"></a>
      <h3 class="section">
        <span class="secnum">4.2</span
        ><span class="sectitle"
          >Variações em um Esquema — Avaliação Preguiçosa</span
        >
      </h3>

      <p>
        Agora que temos um avaliador expresso como um programa Lisp, podemos
        experimentar com escolhas alternativas no design da linguagem
        simplesmente modificando o avaliador. De fato, novas linguagens são
        frequentemente inventadas primeiro escrevendo um avaliador que incorpora
        a nova linguagem dentro de uma linguagem de alto nível existente. Por
        exemplo, se quisermos discutir algum aspecto de uma modificação proposta
        ao Lisp com outro membro da comunidade Lisp, podemos fornecer um
        avaliador que incorpora a mudança. O destinatário pode então
        experimentar o novo avaliador e enviar comentários como modificações
        adicionais. Não apenas a base de implementação de alto nível facilita o
        teste e a depuração do avaliador; além disso, a incorporação permite que
        o designer aproveite características da linguagem subjacente, assim como
        nosso avaliador Lisp incorporado usa primitivas e estrutura de controle
        da linguagem Lisp subjacente. Somente mais tarde (se for o caso) o
        designer precisará se preocupar em construir uma implementação completa
        em uma linguagem de baixo nível ou em hardware. Nesta seção e na
        próxima, exploraremos algumas variações no Scheme que fornecem poder
        expressivo adicional significativo.
      </p>

      <a id="g_t4_002e2_002e1"></a>
      <a id="Normal-Order-and-Applicative-Order"></a>
      <h4 class="subsection">
        <span class="secnum">4.2.1</span
        ><span class="sectitle">Ordem Normal e Ordem Aplicativa</span>
      </h4>

      <p>
        Em <a href="1_002e1.html#g_t1_002e1">1.1</a>, onde começamos nossa
        discussão sobre modelos de avaliação, nós observamos que o Scheme é uma
        linguagem de <a id="index-applicative_002dorder"></a>
        <em>ordem aplicativa</em>, ou seja, todos os argumentos para
        procedimentos do Scheme são avaliados quando o procedimento é aplicado.
        Em contraste, <a id="index-normal_002dorder"></a>
        <em>linguagens de ordem normal</em> atrasam a avaliação dos argumentos
        do procedimento até que os valores reais dos argumentos sejam
        necessários. Atrasar a avaliação dos argumentos do procedimento até o
        último momento possível (por exemplo, até que sejam exigidos por uma
        operação primitiva) é chamado de <a id="index-lazy-evaluation"></a>
        <em>avaliação preguiçosa</em>.<a
          class="footnote_link"
          id="DOCF236"
          href="#FOOT236"
          ><sup>236</sup></a
        >
        Considere o procedimento
      </p>
      <pre><code class="language-scheme">(define (try a b)
  (if (= a 0) 1 b))</code></pre>

      <p>
        Avaliar <code>(try 0 (/ 1 0))</code> gera um erro no Scheme. Com
        avaliação preguiçosa, não haveria erro. Avaliar a expressão retornaria
        1, porque o argumento <code>(/ 1 0)</code> nunca seria avaliado.
      </p>
      <p>
        Um exemplo que explora a avaliação preguiçosa é a definição de um
        procedimento
        <code>unless</code>
      </p>
      <pre><code class="language-scheme">(define (unless condition 
                usual-value 
                exceptional-value)
  (if condition 
      exceptional-value 
      usual-value))</code></pre>

      <p>que pode ser usado em expressões como</p>
      <pre><code class="language-scheme">(unless (= b 0)
        (/ a b)
        (begin 
          (display "exception: returning 0")
          0))</code></pre>

      <p>
        Isso não funcionará em uma linguagem de ordem aplicativa porque tanto o
        valor usual quanto o valor excepcional serão avaliados antes que
        <code>unless</code> seja chamado (compare
        <a href="1_002e1.html#Exercise-1_002e6">Exercício 1.6</a>). Uma vantagem
        da avaliação preguiçosa é que alguns procedimentos, como
        <code>unless</code>, podem realizar computações úteis mesmo que a
        avaliação de alguns de seus argumentos produza erros ou não termine.
      </p>
      <p>
        Se o corpo de um procedimento é executado antes que um argumento tenha
        sido avaliado, dizemos que o procedimento é
        <a id="index-non_002dstrict"></a> <em>não estrito</em> em relação a esse
        argumento. Se o argumento é avaliado antes que o corpo do procedimento
        seja executado, dizemos que o procedimento é <a id="index-strict"></a>
        <em>estrito</em> em relação a esse argumento.<a
          class="footnote_link"
          id="DOCF237"
          href="#FOOT237"
          ><sup>237</sup></a
        >
        Em uma linguagem puramente de ordem aplicativa, todos os procedimentos
        são estritos em cada argumento. Em uma linguagem puramente de ordem
        normal, todos os procedimentos compostos são não estritos em cada
        argumento, e procedimentos primitivos podem ser estritos ou não
        estritos. Há também linguagens (veja
        <a href="#Exercise-4_002e31">Exercício 4.31</a>) que dão aos
        programadores controle detalhado sobre a estrita dos procedimentos que
        eles definem.
      </p>
      <p>
        Um exemplo marcante de um procedimento que pode ser útilmente tornado
        não estrito é <code>cons</code> (ou, em geral, quase qualquer construtor
        para estruturas de dados). Pode-se realizar computações úteis,
        combinando elementos para formar estruturas de dados e operando nas
        estruturas de dados resultantes, mesmo que os valores dos elementos não
        sejam conhecidos. Faz todo o sentido, por exemplo, calcular o
        comprimento de uma lista sem conhecer os valores dos elementos
        individuais na lista. Nós exploraremos essa ideia em
        <a href="#g_t4_002e2_002e3">4.2.3</a> para implementar os fluxos de
        <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> como listas formadas
        por pares <code>cons</code> não estritos.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e25"></a>Exercício 4.25:</strong> Suponha
          que (no Scheme de ordem aplicativa comum) definimos
          <code>unless</code> como mostrado acima e então definimos
          <code>factorial</code> em termos de <code>unless</code> como
        </p>
        <pre><code class="language-scheme">(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))</code></pre>

        <p>
          O que acontece se tentarmos avaliar <code>(factorial 5)</code>? Nossas
          definições funcionariam em uma linguagem de ordem normal?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e26"></a>Exercício 4.26:</strong> Ben
          Bitdiddle e Alyssa P. Hacker discordam sobre a importância da
          avaliação preguiçosa para implementar coisas como <code>unless</code>.
          Ben aponta que é possível implementar <code>unless</code> em ordem
          aplicativa como uma forma especial. Alyssa contra-argumenta que, se
          alguém fizesse isso, <code>unless</code> seria meramente sintaxe, não
          um procedimento que poderia ser usado em conjunto com procedimentos de
          ordem superior. Preencha os detalhes de ambos os lados do argumento.
          Mostre como implementar <code>unless</code> como uma expressão
          derivada (como <code>cond</code> ou <code>let</code>), e dê um exemplo
          de uma situação onde seria útil ter <code>unless</code> disponível
          como um procedimento, em vez de como uma forma especial.
        </p>
      </blockquote>

      <a id="g_t4_002e2_002e2"></a>
      <a id="An-Interpreter-with-Lazy-Evaluation"></a>
      <h4 class="subsection">
        <span class="secnum">4.2.2</span
        ><span class="sectitle">Um Interpretador com Avaliação Preguiçosa</span>
      </h4>

      <p>
        Nesta seção, implementaremos uma linguagem de ordem normal que é a mesma
        que o Scheme, exceto que os procedimentos compostos são não estritos em
        cada argumento. Procedimentos primitivos ainda serão estritos. Não é
        difícil modificar o avaliador de
        <a href="4_002e1.html#g_t4_002e1_002e1">4.1.1</a> para que a linguagem
        que ele interpreta se comporte dessa maneira. Quase todas as mudanças
        necessárias giram em torno da aplicação de procedimentos.
      </p>
      <p>
        A ideia básica é que, ao aplicar um procedimento, o interpretador deve
        determinar quais argumentos devem ser avaliados e quais devem ser
        atrasados. Os argumentos atrasados não são avaliados; em vez disso, são
        transformados em objetos chamados <a id="index-thunks"></a>
        <em>thunks</em>.<a class="footnote_link" id="DOCF238" href="#FOOT238"
          ><sup>238</sup></a
        >
        O thunk deve conter as informações necessárias para produzir o valor do
        argumento quando ele for necessário, como se tivesse sido avaliado no
        momento da aplicação. Assim, o thunk deve conter a expressão do
        argumento e o ambiente em que a aplicação do procedimento está sendo
        avaliada.
      </p>
      <p>
        O processo de avaliar a expressão em um thunk é chamado de
        <a id="index-forcing"></a>
        <em>forçamento</em>.<a
          class="footnote_link"
          id="DOCF239"
          href="#FOOT239"
          ><sup>239</sup></a
        >
        Em geral, um thunk será forçado apenas quando seu valor for necessário:
        quando ele for passado para um procedimento primitivo que usará o valor
        do thunk; quando ele for o valor de um predicado de uma condicional; e
        quando ele for o valor de um operador que está prestes a ser aplicado
        como um procedimento. Uma escolha de design que temos disponível é se
        devemos ou não <a id="index-memoize"></a> <em>memorizar</em> thunks,
        como fizemos com objetos atrasados em
        <a href="3_002e5.html#g_t3_002e5_002e1">3.5.1</a>. Com memorização, a
        primeira vez que um thunk é forçado, ele armazena o valor que é
        calculado. Forçamentos subsequentes simplesmente retornam o valor
        armazenado sem repetir a computação. Faremos nosso interpretador
        memorizar, porque isso é mais eficiente para muitas aplicações. No
        entanto, há considerações complicadas aqui.<a
          class="footnote_link"
          id="DOCF240"
          href="#FOOT240"
          ><sup>240</sup></a
        >
      </p>
      <a id="Modifying-the-evaluator"></a>
      <h5 class="subsubheading">Modificando o avaliador</h5>

      <p>
        A principal diferença entre o avaliador preguiçoso e o de
        <a href="4_002e1.html#g_t4_002e1">4.1</a> está no tratamento de
        aplicações de procedimentos em <code>eval</code> e <code>apply</code>.
      </p>
      <p>A cláusula <code>application?</code> de <code>eval</code> se torna</p>
      <pre><code class="language-scheme">((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))</code></pre>

      <p>
        Isso é quase o mesmo que a cláusula <code>application?</code> de
        <code>eval</code> em <a href="4_002e1.html#g_t4_002e1_002e1">4.1.1</a>.
        Para avaliação preguiçosa, no entanto, chamamos <code>apply</code> com
        as expressões dos operandos, em vez dos argumentos produzidos por sua
        avaliação. Como precisaremos do ambiente para construir thunks se os
        argumentos forem atrasados, devemos passá-lo também. Ainda avaliamos o
        operador, porque <code>apply</code> precisa do procedimento real a ser
        aplicado para despachar em seu tipo (primitivo versus composto) e
        aplicá-lo.
      </p>
      <p>Sempre que precisamos do valor real de uma expressão, usamos</p>
      <pre><code class="language-scheme">(define (actual-value exp env)
  (force-it (eval exp env)))</code></pre>

      <p>
        em vez de apenas <code>eval</code>, para que, se o valor da expressão
        for um thunk, ele seja forçado.
      </p>
      <p>
        Nossa nova versão de <code>apply</code> também é quase a mesma que a
        versão em <a href="4_002e1.html#g_t4_002e1_002e1">4.1.1</a>. A diferença
        é que <code>eval</code> passou expressões de operandos não avaliadas:
        Para procedimentos primitivos (que são estritos), avaliamos todos os
        argumentos antes de aplicar o primitivo; para procedimentos compostos
        (que são não estritos), atrasamos todos os argumentos antes de aplicar o
        procedimento.
      </p>
      <pre><code class="language-scheme">(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values 
           arguments 
           env)))  ; changed
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args 
            arguments 
            env)   ; changed
           (procedure-environment procedure))))
        (else (error "Unknown procedure 
                      type: APPLY" 
                     procedure))))</code></pre>

      <p>
        Os procedimentos que processam os argumentos são como
        <code>list-of-values</code> de
        <a href="4_002e1.html#g_t4_002e1_002e1">4.1.1</a>, exceto que
        <code>list-of-delayed-args</code> atrasa os argumentos em vez de
        avaliá-los, e <code>list-of-arg-values</code> usa
        <code>actual-value</code> em vez de <code>eval</code>:
      </p>
      <pre><code class="language-scheme">(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value 
             (first-operand exps) 
             env)
            (list-of-arg-values 
             (rest-operands exps)
             env)))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it 
             (first-operand exps) 
             env)
            (list-of-delayed-args 
             (rest-operands exps)
             env))))</code></pre>

      <p>
        O outro lugar onde devemos mudar o avaliador é no tratamento de
        <code>if</code>, onde devemos usar <code>actual-value</code> em vez de
        <code>eval</code> para obter o valor da expressão do predicado antes de
        testar se é verdadeiro ou falso:
      </p>
      <pre><code class="language-scheme">(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) 
                           env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))</code></pre>

      <p>
        Finalmente, devemos mudar o procedimento <code>driver-loop</code> (<a
          href="4_002e1.html#g_t4_002e1_002e4"
          >4.1.4</a
        >) para usar <code>actual-value</code> em vez de <code>eval</code>, para
        que, se um valor atrasado for propagado de volta ao loop de
        leitura-avaliação-impressão, ele será forçado antes de ser impresso.
        Também mudamos os prompts para indicar que este é o avaliador
        preguiçoso:
      </p>
      <pre><code class="language-scheme">(define input-prompt  ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value 
                   input 
                   the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))</code></pre>

      <p>
        Com essas mudanças feitas, podemos iniciar o avaliador e testá-lo. A
        avaliação bem-sucedida da expressão <code>try</code> discutida em
        <a href="#g_t4_002e2_002e1">4.2.1</a> indica que o interpretador está
        realizando avaliação preguiçosa:
      </p>
      <pre><code class="language-scheme">(define the-global-environment 
  (setup-environment))

(driver-loop)

;;; L-Eval input:
(define (try a b) (if (= a 0) 1 b))

;;; L-Eval value:
ok

;;; L-Eval input:
(try 0 (/ 1 0))

;;; L-Eval value:
1</code></pre>

      <a id="Representing-thunks"></a>
      <h5 class="subsubheading">Representando thunks</h5>

      <p>
        Nosso avaliador deve organizar a criação de thunks quando procedimentos
        são aplicados a argumentos e forçar esses thunks posteriormente. Um
        thunk deve empacotar uma expressão junto com o ambiente, para que o
        argumento possa ser produzido mais tarde. Para forçar o thunk,
        simplesmente extraímos a expressão e o ambiente do thunk e avaliamos a
        expressão no ambiente. Usamos <code>actual-value</code> em vez de
        <code>eval</code> para que, caso o valor da expressão seja ele mesmo um
        thunk, nós o forcemos, e assim por diante, até chegarmos a algo que não
        seja um thunk:
      </p>
      <pre><code class="language-scheme">(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) 
                    (thunk-env obj))
      obj))</code></pre>

      <p>
        Uma maneira fácil de empacotar uma expressão com um ambiente é fazer uma
        lista contendo a expressão e o ambiente. Assim, criamos um thunk da
        seguinte forma:
      </p>
      <pre><code class="language-scheme">(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj) (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))</code></pre>

      <p>
        Na verdade, o que queremos para nosso interpretador não é exatamente
        isso, mas sim thunks que foram memorizados. Quando um thunk é forçado,
        nós o transformamos em um thunk avaliado, substituindo a expressão
        armazenada por seu valor e mudando a tag <code>thunk</code> para que ele
        possa ser reconhecido como já avaliado.<a
          class="footnote_link"
          id="DOCF241"
          href="#FOOT241"
          ><sup>241</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) 
  (cadr evaluated-thunk))

(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result
                (actual-value 
                 (thunk-exp obj)
                 (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           ;; replace exp with its value:
           (set-car! (cdr obj) result) 
           ;; forget unneeded env:
           (set-cdr! (cdr obj) '()) 
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))</code></pre>

      <p>
        Observe que o mesmo procedimento <code>delay-it</code> funciona tanto
        com quanto sem memorização.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e27"></a>Exercício 4.27:</strong> Suponha
          que digitamos as seguintes definições no avaliador preguiçoso:
        </p>
        <pre><code class="language-scheme">(define count 0)
(define (id x) (set! count (+ count 1)) x)</code></pre>

        <p>
          Forneça os valores ausentes na seguinte sequência de interações e
          explique suas respostas.<a
            class="footnote_link"
            id="DOCF242"
            href="#FOOT242"
            ><sup>242</sup></a
          >
        </p>
        <pre><code class="language-scheme">(define w (id (id 10)))

;;; L-Eval input:
count

;;; L-Eval value:
⟨response⟩

;;; L-Eval input:
w

;;; L-Eval value:
⟨response⟩

;;; L-Eval input:
count

;;; L-Eval value:
⟨response⟩</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e28"></a>Exercício 4.28:</strong>
          <code>Eval</code> usa <code>actual-value</code> em vez de
          <code>eval</code> para avaliar o operador antes de passá-lo para
          <code>apply</code>, a fim de forçar o valor do operador. Dê um exemplo
          que demonstre a necessidade desse forçamento.
        </p>
        <p>
          <strong><a id="Exercise-4_002e29"></a>Exercício 4.29:</strong> Exiba
          um programa que você esperaria que rodasse muito mais lentamente sem
          memorização do que com memorização. Além disso, considere a seguinte
          interação, onde o procedimento <code>id</code> é definido como em
          <a href="#Exercise-4_002e27">Exercício 4.27</a> e
          <code>count</code> começa em 0:
        </p>
        <pre><code class="language-scheme">(define (square x) (* x x))

;;; L-Eval input:
(square (id 10))

;;; L-Eval value:
⟨response⟩

;;; L-Eval input:
count

;;; L-Eval value:
⟨response⟩</code></pre>

        <p>
          Forneça as respostas tanto quando o avaliador memoriza quanto quando
          não memoriza.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e30"></a>Exercício 4.30:</strong> Cy D.
          Fect, um programador C reformado, está preocupado que alguns efeitos
          colaterais possam nunca ocorrer, porque o avaliador preguiçoso não
          força as expressões em uma sequência. Como o valor de uma expressão em
          uma sequência, exceto a última, não é usado (a expressão está lá
          apenas para seu efeito, como atribuir a uma variável ou imprimir), não
          pode haver uso subsequente desse valor (por exemplo, como argumento
          para um procedimento primitivo) que o forçará. Cy, portanto, pensa
          que, ao avaliar sequências, devemos forçar todas as expressões na
          sequência, exceto a final. Ele propõe modificar
          <code>eval-sequence</code> de
          <a href="4_002e1.html#g_t4_002e1_002e1">4.1.1</a> para usar
          <code>actual-value</code> em vez de <code>eval</code>:
        </p>
        <pre><code class="language-scheme">(define (eval-sequence exps env)
  (cond ((last-exp? exps) 
         (eval (first-exp exps) env))
        (else 
         (actual-value (first-exp exps) 
                       env)
         (eval-sequence (rest-exps exps) 
                        env))))</code></pre>

        <ol>
          <li>
            Ben Bitdiddle acha que Cy está errado. Ele mostra a Cy o
            procedimento <code>for-each</code> descrito em
            <a href="2_002e2.html#Exercise-2_002e23">Exercício 2.23</a>, que dá
            um exemplo importante de uma sequência com efeitos colaterais:

            <pre><code class="language-scheme">(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc 
                       (cdr items)))))</code></pre>

            <p>
              Ele afirma que o avaliador no texto (com o
              <code>eval-sequence</code> original) lida com isso corretamente:
            </p>
            <pre><code class="language-scheme">;;; L-Eval input:
(for-each
 (lambda (x) (newline) (display x))
 (list 57 321 88))
57
321
88

;;; L-Eval value:
done</code></pre>

            <p>
              Explique por que Ben está certo sobre o comportamento de
              <code>for-each</code>.
            </p>
          </li>
          <li>
            Cy concorda que Ben está certo sobre o exemplo
            <code>for-each</code>, mas diz que esse não é o tipo de programa que
            ele estava pensando quando propôs sua mudança para
            <code>eval-sequence</code>. Ele define os seguintes dois
            procedimentos no avaliador preguiçoso:

            <pre><code class="language-scheme">(define (p1 x)
  (set! x (cons x '(2))) x)

(define (p2 x)
  (define (p e) e x)
  (p (set! x (cons x '(2)))))</code></pre>

            <p>
              Quais são os valores de <code>(p1 1)</code> e
              <code>(p2 1)</code> com o <code>eval-sequence</code> original?
              Quais seriam os valores com a mudança proposta por Cy para
              <code>eval-sequence</code>?
            </p>
          </li>
          <li>
            Cy também aponta que mudar <code>eval-sequence</code> como ele
            propõe não afeta o comportamento do exemplo na parte a. Explique por
            que isso é verdade.
          </li>
          <li>
            Como você acha que as sequências devem ser tratadas no avaliador
            preguiçoso? Você gosta da abordagem de Cy, da abordagem no texto ou
            de alguma outra abordagem?
          </li>
        </ol>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e31"></a>Exercício 4.31:</strong> A
          abordagem tomada nesta seção é um tanto desagradável, porque faz uma
          mudança incompatível com o Scheme. Seria mais agradável implementar a
          avaliação preguiçosa como uma
          <a id="index-upward_002dcompatible-extension"></a>
          <em>extensão compatível</em>, ou seja, de modo que programas comuns do
          Scheme funcionem como antes. Podemos fazer isso estendendo a sintaxe
          de declarações de procedimentos para permitir que o usuário controle
          se os argumentos devem ser atrasados. Enquanto estamos nisso, também
          podemos dar ao usuário a escolha entre atrasar com ou sem memorização.
          Por exemplo, a definição
        </p>
        <pre><code class="language-scheme">(define (f a (b lazy) c (d lazy-memo))
  …)</code></pre>

        <p>
          definiria <code>f</code> como um procedimento de quatro argumentos,
          onde o primeiro e o terceiro argumentos são avaliados quando o
          procedimento é chamado, o segundo argumento é atrasado, e o quarto
          argumento é atrasado e memorizado. Assim, definições comuns de
          procedimentos produzirão o mesmo comportamento que o Scheme comum,
          enquanto adicionar a declaração <code>lazy-memo</code> a cada
          parâmetro de cada procedimento composto produzirá o comportamento do
          avaliador preguiçoso definido nesta seção. Projete e implemente as
          mudanças necessárias para produzir tal extensão ao Scheme. Você terá
          que implementar novos procedimentos de sintaxe para lidar com a nova
          sintaxe para <code>define</code>. Você também deve arranjar para que
          <code>eval</code> ou <code>apply</code> determinem quando os
          argumentos devem ser atrasados, e forçar ou atrasar argumentos
          conforme apropriado, e você deve arranjar para que o forçamento
          memorize ou não, conforme apropriado.
        </p>
      </blockquote>

      <a id="g_t4_002e2_002e3"></a>
      <a id="Streams-as-Lazy-Lists"></a>
      <h4 class="subsection">
        <span class="secnum">4.2.3</span
        ><span class="sectitle">Fluxos como Listas Preguiçosas</span>
      </h4>

      <p>
        Em <a href="3_002e5.html#g_t3_002e5_002e1">3.5.1</a>, mostramos como
        implementar fluxos como listas atrasadas. Introduzimos formas especiais
        <code>delay</code> e <code>cons-stream</code>, que permitiram construir
        uma “promessa” para calcular o <code>cdr</code> de um fluxo, sem
        realmente cumprir essa promessa até mais tarde. Poderíamos usar essa
        técnica geral de introduzir formas especiais sempre que precisamos de
        mais controle sobre o processo de avaliação, mas isso é incômodo. Por um
        lado, uma forma especial não é um objeto de primeira classe como um
        procedimento, então não podemos usá-la junto com procedimentos de ordem
        superior.<a class="footnote_link" id="DOCF243" href="#FOOT243"
          ><sup>243</sup></a
        >
        Além disso, fomos forçados a criar fluxos como um novo tipo de objeto de
        dados semelhante, mas não idêntico a listas, e isso nos obrigou a
        reimplementar muitas operações comuns de listas (<code>map</code>,
        <code>append</code>, e assim por diante) para uso com fluxos.
      </p>
      <p>
        Com avaliação preguiçosa, fluxos e listas podem ser idênticos, então não
        há necessidade de formas especiais ou de operações separadas de listas e
        fluxos. Tudo o que precisamos fazer é arranjar as coisas para que
        <code>cons</code> seja não estrito. Uma maneira de conseguir isso é
        estender o avaliador preguiçoso para permitir primitivas não estritas, e
        implementar <code>cons</code> como uma delas. Uma maneira mais fácil é
        lembrar (<a href="2_002e1.html#g_t2_002e1_002e3">2.1.3</a>) que não há
        necessidade fundamental de implementar <code>cons</code> como uma
        primitiva. Em vez disso, podemos representar pares como procedimentos:<a
          class="footnote_link"
          id="DOCF244"
          href="#FOOT244"
          ><sup>244</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (cons x y) (lambda (m) (m x y)))
(define (car z) (z (lambda (p q) p)))
(define (cdr z) (z (lambda (p q) q)))</code></pre>

      <p>
        Em termos dessas operações básicas, as definições padrão das operações
        de listas funcionarão com listas infinitas (fluxos) assim como com
        listas finitas, e as operações de fluxos podem ser implementadas como
        operações de listas. Aqui estão alguns exemplos:
      </p>
      <pre><code class="language-scheme">(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))

(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) 
                       (car list2))
                    (add-lists
                     (cdr list1) 
                     (cdr list2))))))

(define ones (cons 1 ones))

(define integers 
  (cons 1 (add-lists ones integers)))

;;; L-Eval input:
(list-ref integers 17)

;;; L-Eval value:
18</code></pre>

      <p>
        Observe que essas listas preguiçosas são ainda mais preguiçosas que os
        fluxos de <a href="Chapter-3.html#Chapter-3">Capítulo 3</a>: O
        <code>car</code> da lista, assim como o <code>cdr</code>, é atrasado.<a
          class="footnote_link"
          id="DOCF245"
          href="#FOOT245"
          ><sup>245</sup></a
        >
        De fato, até mesmo acessar o <code>car</code> ou <code>cdr</code> de um
        par preguiçoso não precisa forçar o valor de um elemento da lista. O
        valor será forçado apenas quando for realmente necessário—por exemplo,
        para uso como argumento de uma primitiva, ou para ser impresso como uma
        resposta.
      </p>
      <p>
        Pares preguiçosos também ajudam com o problema que surgiu com fluxos em
        <a href="3_002e5.html#g_t3_002e5_002e4">3.5.4</a>, onde descobrimos que
        formular modelos de fluxos de sistemas com loops pode exigir que
        espalhemos nossos programas com operações explícitas de
        <code>delay</code>, além das fornecidas por <code>cons-stream</code>.
        Com avaliação preguiçosa, todos os argumentos para procedimentos são
        atrasados uniformemente. Por exemplo, podemos implementar procedimentos
        para integrar listas e resolver equações diferenciais como originalmente
        pretendíamos em <a href="3_002e5.html#g_t3_002e5_002e4">3.5.4</a>:
      </p>
      <pre><code class="language-scheme">(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt) 
                     int)))
  int)

(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (map f y))
  y)

;;; L-Eval input:
(list-ref (solve (lambda (x) x) 1 0.001) 1000)

;;; L-Eval value:
2.716924</code></pre>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e32"></a>Exercício 4.32:</strong> Dê
          alguns exemplos que ilustram a diferença entre os fluxos de
          <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> e as listas
          preguiçosas “mais preguiçosas” descritas nesta seção. Como você pode
          tirar vantagem dessa preguiça extra?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e33"></a>Exercício 4.33:</strong> Ben
          Bitdiddle testa a implementação de listas preguiçosas dada acima
          avaliando a expressão
        </p>
        <pre><code class="language-scheme">(car '(a b c))</code></pre>

        <p>
          Para sua surpresa, isso produz um erro. Depois de pensar um pouco, ele
          percebe que as “listas” obtidas ao ler expressões entre aspas são
          diferentes das listas manipuladas pelas novas definições de
          <code>cons</code>, <code>car</code>, e <code>cdr</code>. Modifique o
          tratamento de expressões entre aspas pelo avaliador para que listas
          entre aspas digitadas no loop de driver produzam listas preguiçosas
          verdadeiras.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-4_002e34"></a>Exercício 4.34:</strong>
          Modifique o loop de driver para o avaliador para que pares e listas
          preguiçosas sejam impressos de alguma maneira razoável. (O que você
          vai fazer sobre listas infinitas?) Você também pode precisar modificar
          a representação de pares preguiçosos para que o avaliador possa
          identificá-los a fim de imprimi-los.
        </p>
      </blockquote>

      <div class="footnote">
        <h4 class="footnotes-heading">Notas de rodapé</h4>

        <div id="FOOT235">
          <p>
            <a class="footnote_backlink" href="#DOCF235"><sup>235</sup></a>
            Snarf: “Pegar, especialmente um documento ou arquivo grande com o
            propósito de usá-lo com ou sem a permissão do proprietário.” Snarf
            down: “Pegar, às vezes com a conotação de absorver, processar ou
            entender.” (Essas definições foram snarfadas de
            <a href="References.html#Steele-et-al_002e-1983"
              >Steele et al. 1983</a
            >. Veja também
            <a href="References.html#Raymond-1993">Raymond 1993</a>.)
          </p>
        </div>
        <div id="FOOT236">
          <p>
            <a class="footnote_backlink" href="#DOCF236"><sup>236</sup></a> A
            diferença entre a terminologia “preguiçosa” e a terminologia “ordem
            normal” é um tanto vaga. Geralmente, “preguiçosa” refere-se a
            mecanismos de avaliadores específicos, enquanto “ordem normal”
            refere-se à semântica de linguagens, independentemente de qualquer
            estratégia de avaliação específica. Mas isso não é uma distinção
            rígida, e as duas terminologias são frequentemente usadas de forma
            intercambiável.
          </p>
        </div>
        <div id="FOOT237">
          <p>
            <a class="footnote_backlink" href="#DOCF237"><sup>237</sup></a> A
            terminologia “estrita” versus “não estrita” significa essencialmente
            a mesma coisa que “ordem aplicativa” versus “ordem normal”, exceto
            que se refere a procedimentos e argumentos individuais em vez de se
            referir à linguagem como um todo. Em uma conferência sobre
            linguagens de programação, você pode ouvir alguém dizer: “A
            linguagem de ordem normal Hassle tem certas primitivas estritas.
            Outros procedimentos tomam seus argumentos por avaliação
            preguiçosa.”
          </p>
        </div>
        <div id="FOOT238">
          <p>
            <a class="footnote_backlink" href="#DOCF238"><sup>238</sup></a> A
            palavra <a id="index-thunk"></a> <em>thunk</em> foi inventada por um
            grupo de trabalho informal que estava discutindo a implementação de
            chamada por nome em Algol 60. Eles observaram que a maior parte da
            análise de (“pensar sobre”) a expressão poderia ser feita em tempo
            de compilação; assim, em tempo de execução, a expressão já teria
            sido “pensada” (<a href="References.html#Ingerman-et-al_002e-1960"
              >Ingerman et al. 1960</a
            >).
          </p>
        </div>
        <div id="FOOT239">
          <p>
            <a class="footnote_backlink" href="#DOCF239"><sup>239</sup></a> Isso
            é análogo ao uso de <code>force</code> nos objetos atrasados que
            foram introduzidos em
            <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> para representar
            fluxos. A diferença crítica entre o que estamos fazendo aqui e o que
            fizemos em <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> é que
            estamos construindo atraso e forçamento no avaliador, e assim
            tornando isso uniforme e automático em toda a linguagem.
          </p>
        </div>
        <div id="FOOT240">
          <p>
            <a class="footnote_backlink" href="#DOCF240"><sup>240</sup></a>
            Avaliação preguiçosa combinada com memorização é às vezes referida
            como <a id="index-call_002dby_002dneed-1"></a>
            <em>chamada por necessidade</em>, em contraste com
            <a id="index-call_002dby_002dname-1"></a> <em>chamada por nome</em>.
            (Chamada por nome, introduzida em Algol 60, é semelhante à avaliação
            preguiçosa não memorizada.) Como designers de linguagens, podemos
            construir nosso avaliador para memorizar, não memorizar, ou deixar
            isso como uma opção para programadores (<a href="#Exercise-4_002e31"
              >Exercício 4.31</a
            >). Como você pode esperar de
            <a href="Chapter-3.html#Chapter-3">Capítulo 3</a>, essas escolhas
            levantam questões que se tornam tanto sutis quanto confusas na
            presença de atribuições. (Veja
            <a href="#Exercise-4_002e27">Exercício 4.27</a> e
            <a href="#Exercise-4_002e29">Exercício 4.29</a>.) Um excelente
            artigo de
            <a href="References.html#Clinger-_00281982_0029">Clinger (1982)</a>
            tenta esclarecer as múltiplas dimensões de confusão que surgem aqui.
          </p>
        </div>
        <div id="FOOT241">
          <p>
            <a class="footnote_backlink" href="#DOCF241"><sup>241</sup></a>
            Observe que também apagamos o <code>env</code> do thunk uma vez que
            o valor da expressão foi calculado. Isso não faz diferença nos
            valores retornados pelo interpretador. Isso ajuda a economizar
            espaço, no entanto, porque remover a referência do thunk para o
            <code>env</code> uma vez que ele não é mais necessário permite que
            essa estrutura seja <a id="index-garbage_002dcollected"></a>
            <em>coletada como lixo</em> e seu espaço reciclado, como
            discutiremos em <a href="5_002e3.html#g_t5_002e3">5.3</a>.
          </p>
          <p>
            Da mesma forma, poderíamos ter permitido que ambientes
            desnecessários nos objetos atrasados memorizados de
            <a href="3_002e5.html#g_t3_002e5_002e1">3.5.1</a> fossem coletados
            como lixo, fazendo <code>memo-proc</code> fazer algo como
            <code>(set! proc '())</code> para descartar o procedimento
            <code>proc</code> (que inclui o ambiente em que o
            <code>delay</code> foi avaliado) após armazenar seu valor.
          </p>
        </div>
        <div id="FOOT242">
          <p>
            <a class="footnote_backlink" href="#DOCF242"><sup>242</sup></a> Este
            exercício demonstra que a interação entre avaliação preguiçosa e
            efeitos colaterais pode ser muito confusa. Isso é exatamente o que
            você pode esperar da discussão em
            <a href="Chapter-3.html#Chapter-3">Capítulo 3</a>.
          </p>
        </div>
        <div id="FOOT243">
          <p>
            <a class="footnote_backlink" href="#DOCF243"><sup>243</sup></a> Esse
            é exatamente o problema com o procedimento <code>unless</code>, como
            em <a href="#Exercise-4_002e26">Exercício 4.26</a>.
          </p>
        </div>
        <div id="FOOT244">
          <p>
            <a class="footnote_backlink" href="#DOCF244"><sup>244</sup></a>
            Essa é a representação procedural descrita em
            <a href="2_002e1.html#Exercise-2_002e4">Exercício 2.4</a>.
            Essencialmente, qualquer representação procedural (por exemplo, uma
            implementação de passagem de mensagens) funcionaria tão bem. Observe
            que podemos instalar essas definições no avaliador preguiçoso
            simplesmente digitando-as no loop de driver. Se tivéssemos
            originalmente incluído <code>cons</code>, <code>car</code>, e
            <code>cdr</code> como primitivas no ambiente global, elas serão
            redefinidas. (Veja também
            <a href="#Exercise-4_002e33">Exercício 4.33</a> e
            <a href="#Exercise-4_002e34">Exercício 4.34</a>.)
          </p>
        </div>
        <div id="FOOT245">
          <p>
            <a class="footnote_backlink" href="#DOCF245"><sup>245</sup></a> Isso
            nos permite criar versões atrasadas de tipos mais gerais de
            estruturas de listas, não apenas sequências.
            <a href="References.html#Hughes-1990">Hughes 1990</a> discute
            algumas aplicações de “árvores preguiçosas.”
          </p>
        </div>
      </div>
      <nav class="header">
        <p>
          Próximo:
          <a href="4_002e3.html#g_t4_002e3" accesskey="n" rel="next">4.3</a>,
          Anterior:
          <a href="4_002e1.html#g_t4_002e1" accesskey="p" rel="prev">4.1</a>,
          Acima: <a href="#g_t4_002e2" accesskey="u" rel="prev">4.2</a> [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Sumário</a
          >]
        </p>
      </nav>
    </section>
    <span class="bottom jump" title="Jump to bottom"
      ><a href="#pagebottom" accesskey="b">⇣</a></span
    ><a id="pagebottom"></a>
  </body>
</html>
