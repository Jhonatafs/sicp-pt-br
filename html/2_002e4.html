<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.4">
    <meta name="keywords" content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.4">
    <title>Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.4</title>
    <link href="index.xhtml#Top" rel="start" title="Topo">
    <link href="Term-Index.xhtml#Term-Index" rel="index" title="Índice de Termos">
    <link href="index.xhtml#SEC_Contents" rel="contents" title="Sumário">
    <link href="Chapter-2.xhtml#Chapter-2" rel="prev" title="Capítulo 2">
    <link href="2_002e5.xhtml#g_t2_002e5" rel="next" title="2.5">
    <link href="2_002e3.xhtml#g_t2_002e3_002e4" rel="prev" title="2.3.4">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/prettify.css" rel="stylesheet" type="text/css">
    <script src="js/jquery.min.js" type="text/javascript"></script>
    <script src="js/footnotes.js" type="text/javascript"></script>
    <script src="js/browsertest.js" type="text/javascript"></script>
</head>
<body>
    <section>
        <span class="top jump" title="Ir para o topo"><a href="#pagetop" accesskey="t">⇡</a></span>
        <a id="pagetop"></a>
        <a id="g_t2_002e4"></a>
        <nav class="header">
            <p>
                Próximo: <a href="2_002e5.xhtml#g_t2_002e5" accesskey="n" rel="next">2.5</a>, Anterior: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="p" rel="prev">2.3</a>, Acima: <a href="Chapter-2.xhtml#Chapter-2" accesskey="u" rel="prev">Capítulo 2</a>   [<a href="index.xhtml#SEC_Contents" title="Sumário" accesskey="c" rel="contents">Sumário</a>]
            </p>
        </nav>
        <a id="Multiple-Representations-for-Abstract-Data"></a>
        <h3 class="section"><span class="secnum">2.4</span><span class="sectitle">Múltiplas Representações para Dados Abstratos</span></h3>

        <p>
            Introduzimos a abstração de dados, uma metodologia para estruturar sistemas de forma que grande parte de um programa possa ser especificada independentemente das escolhas envolvidas na implementação dos objetos de dados que o programa manipula. Por exemplo, vimos em <a href="2_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a> como separar a tarefa de projetar um programa que usa números racionais da tarefa de implementar números racionais em termos dos mecanismos primitivos da linguagem de computador para construir dados compostos. A ideia principal foi erguer uma barreira de abstração – neste caso, os seletores e construtores para números racionais (<code>make-rat</code>, <code>numer</code>, <code>denom</code>) – que isola a forma como os números racionais são usados de sua representação subjacente em termos de estrutura de lista. Uma barreira de abstração semelhante isola os detalhes dos procedimentos que realizam aritmética racional (<code>add-rat</code>, <code>sub-rat</code>, <code>mul-rat</code> e <code>div-rat</code>) dos procedimentos de "nível superior" que usam números racionais. O programa resultante tem a estrutura mostrada em <a href="2_002e1.xhtml#Figure-2_002e1">Figura 2.1</a>.
        </p>
        <p>
            Essas barreiras de abstração de dados são ferramentas poderosas para controlar a complexidade. Ao isolar as representações subjacentes dos objetos de dados, podemos dividir a tarefa de projetar um grande programa em tarefas menores que podem ser realizadas separadamente. Mas esse tipo de abstração de dados ainda não é poderoso o suficiente, porque nem sempre faz sentido falar de "a representação subjacente" para um objeto de dados.
        </p>
        <p>
            Por um lado, pode haver mais de uma representação útil para um objeto de dados, e podemos querer projetar sistemas que possam lidar com múltiplas representações. Para dar um exemplo simples, números complexos podem ser representados de duas formas quase equivalentes: na forma retangular (partes real e imaginária) e na forma polar (magnitude e ângulo). Às vezes, a forma retangular é mais apropriada e, às vezes, a forma polar é mais apropriada. De fato, é perfeitamente plausível imaginar um sistema em que os números complexos são representados de ambas as formas, e em que os procedimentos para manipular números complexos funcionam com qualquer representação.
        </p>
        <p>
            Mais importante, os sistemas de programação são frequentemente projetados por muitas pessoas trabalhando por longos períodos de tempo, sujeitos a requisitos que mudam com o tempo. Em tal ambiente, simplesmente não é possível que todos concordem antecipadamente sobre as escolhas de representação de dados. Portanto, além das barreiras de abstração de dados que isolam a representação do uso, precisamos de barreiras de abstração que isolem diferentes escolhas de design umas das outras e permitam que diferentes escolhas coexistam em um único programa. Além disso, como grandes programas são frequentemente criados combinando módulos pré-existentes que foram projetados isoladamente, precisamos de convenções que permitam aos programadores incorporar módulos em sistemas maiores <a id="index-additively-1"></a> <em>aditivamente</em>, ou seja, sem precisar redesenhar ou reimplementar esses módulos.
        </p>
        <p>
            Nesta seção, aprenderemos como lidar com dados que podem ser representados de diferentes maneiras por diferentes partes de um programa. Isso requer a construção de <a id="index-generic-procedures-1"></a> <em>procedimentos genéricos</em> – procedimentos que podem operar em dados que podem ser representados de mais de uma maneira. Nossa principal técnica para construir procedimentos genéricos será trabalhar em termos de objetos de dados que possuem <a id="index-type-tags"></a> <em>etiquetas de tipo</em>, ou seja, objetos de dados que incluem informações explícitas sobre como devem ser processados. Também discutiremos <a id="index-data_002ddirected"></a> <em>programação orientada a dados</em>, uma estratégia de implementação poderosa e conveniente para montar sistemas aditivamente com operações genéricas.
        </p>
        <p>
            Começamos com o exemplo simples de números complexos. Veremos como as etiquetas de tipo e o estilo orientado a dados nos permitem projetar representações retangulares e polares separadas para números complexos, mantendo a noção de um objeto de dados abstrato "número complexo". Conseguiremos isso definindo procedimentos aritméticos para números complexos (<code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code> e <code>div-complex</code>) em termos de seletores genéricos que acessam partes de um número complexo independentemente de como o número é representado. O sistema de números complexos resultante, como mostrado em <a href="#Figure-2_002e19">Figura 2.19</a>, contém dois tipos diferentes de barreiras de abstração. As barreiras de abstração "horizontais" desempenham o mesmo papel que as da <a href="2_002e1.xhtml#Figure-2_002e1">Figura 2.1</a>. Elas isolam operações de "nível superior" de representações de "nível inferior". Além disso, há uma barreira "vertical" que nos dá a capacidade de projetar e instalar representações alternativas separadamente.
        </p>
        <figure class="float">
            <a id="Figure-2_002e19"></a>
            <object style="width: 40.41ex; height: 33.41ex;" data="fig/chap2/Fig2.19a.std.svg" type="image/svg+xml">SVG</object>
            <figcaption class="float-caption">
                <p><strong>Figura 2.19:</strong> Barreiras de abstração de dados no sistema de números complexos.</p>
            </figcaption>
        </figure>

        <p>
            Em <a href="2_002e5.xhtml#g_t2_002e5">2.5</a>, mostraremos como usar etiquetas de tipo e o estilo orientado a dados para desenvolver um pacote aritmético genérico. Isso fornece procedimentos (<code>add</code>, <code>mul</code>, e assim por diante) que podem ser usados para manipular todos os tipos de "números" e podem ser facilmente estendidos quando um novo tipo de número é necessário. Em <a href="2_002e5.xhtml#g_t2_002e5_002e3">2.5.3</a>, mostraremos como usar aritmética genérica em um sistema que realiza álgebra simbólica.
        </p>

        <a id="g_t2_002e4_002e1"></a>
        <a id="Representations-for-Complex-Numbers"></a>
        <h4 class="subsection"><span class="secnum">2.4.1</span><span class="sectitle">Representações para Números Complexos</span></h4>

        <p>
            Desenvolveremos um sistema que realiza operações aritméticas em números complexos como um exemplo simples, mas irrealista, de um programa que usa operações genéricas. Começamos discutindo duas representações plausíveis para números complexos como pares ordenados: a forma retangular (parte real e parte imaginária) e a forma polar (magnitude e ângulo).<a class="footnote_link" id="DOCF109" href="#FOOT109"><sup>109</sup></a> A seção <a href="#g_t2_002e4_002e2">2.4.2</a> mostrará como ambas as representações podem coexistir em um único sistema por meio do uso de etiquetas de tipo e operações genéricas.
        </p>
        <p>
            Assim como os números racionais, os números complexos são naturalmente representados como pares ordenados. O conjunto de números complexos pode ser pensado como um espaço bidimensional com dois eixos ortogonais, o eixo "real" e o eixo "imaginário". (Veja <a href="#Figure-2_002e20">Figura 2.20</a>.) Desse ponto de vista, o número complexo <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <mi>z</mi>
                    <mo>=</mo>
                    <mi>x</mi>
                    <mo>+</mo>
                    <mi>i</mi>
                    <mi>y</mi>
                </mrow>
            </math> (onde <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <msup>
                        <mi>i</mi>
                        <mrow class="MJX-TeXAtom-ORD">
                            <mspace width="0.1em"/>
                            <mn>2</mn>
                        </mrow>
                    </msup>
                    <mo>=</mo>
                    <mtext>−1</mtext>
                </mrow>
            </math>) pode ser pensado como o ponto no plano cuja coordenada real é <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>x</mi>
            </math> e cuja coordenada imaginária é <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>y</mi>
            </math>. A adição de números complexos reduz-se, nesta representação, à adição de coordenadas:
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
                    <mtr>
                        <mtd>
                            <mtext>Parte Real</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>+</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Parte Real</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>+</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd/>
                        <mtd/>
                        <mtd>
                            <mtext>Parte Real</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>,</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mtext>Parte Imaginária</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>+</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Parte Imaginária</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>+</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd/>
                        <mtd/>
                        <mtd>
                            <mtext>Parte Imaginária</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>.</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
        <figure class="float">
            <a id="Figure-2_002e20"></a>
            <object style="width: 51.98ex; height: 30.74ex;" data="fig/chap2/Fig2.20.std.svg" type="image/svg+xml">SVG</object>
            <figcaption class="float-caption">
                <p><strong>Figura 2.20:</strong> Números complexos como pontos no plano.</p>
            </figcaption>
        </figure>

        <p>
            Ao multiplicar números complexos, é mais natural pensar em termos de representar um número complexo na forma polar, como uma magnitude e um ângulo (<math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>r</mi>
            </math> e <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>A</mi>
            </math> na <a href="#Figure-2_002e20">Figura 2.20</a>). O produto de dois números complexos é o vetor obtido esticando um número complexo pelo comprimento do outro e depois girando-o pelo ângulo do outro:
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
                    <mtr>
                        <mtd>
                            <mtext>Magnitude</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>⋅<!-- ⋅ --></mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Magnitude</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>⋅<!-- ⋅ --></mo>
                            <mtext>Magnitude</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>,</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mtext>Ângulo</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>⋅<!-- ⋅ --></mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Ângulo</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>+</mo>
                            <mtext>Ângulo</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>.</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
        <p>
            Assim, existem duas representações diferentes para números complexos, que são apropriadas para diferentes operações. No entanto, do ponto de vista de alguém escrevendo um programa que usa números complexos, o princípio da abstração de dados sugere que todas as operações para manipular números complexos devem estar disponíveis, independentemente de qual representação é usada pelo computador. Por exemplo, muitas vezes é útil poder encontrar a magnitude de um número complexo especificado por coordenadas retangulares. Da mesma forma, muitas vezes é útil determinar a parte real de um número complexo especificado por coordenadas polares.
        </p>
        <p>
            Para projetar tal sistema, podemos seguir a mesma estratégia de abstração de dados que seguimos ao projetar o pacote de números racionais em <a href="2_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a>. Suponha que as operações em números complexos sejam implementadas em termos de quatro seletores: <code>real-part</code>, <code>imag-part</code>, <code>magnitude</code> e <code>angle</code>. Também suponha que temos dois procedimentos para construir números complexos: <code>make-from-real-imag</code> retorna um número complexo com partes real e imaginária especificadas, e <code>make-from-mag-ang</code> retorna um número complexo com magnitude e ângulo especificados. Esses procedimentos têm a propriedade de que, para qualquer número complexo <code>z</code>, ambos
        </p>
        <pre><code class="language-scheme">(make-from-real-imag (real-part z) 
                     (imag-part z))</code></pre>

        <p>e</p>
        <pre><code class="language-scheme">(make-from-mag-ang (magnitude z) 
                   (angle z))</code></pre>

        <p>produzem números complexos que são iguais a <code>z</code>.</p>
        <p>
            Usando esses construtores e seletores, podemos implementar aritmética em números complexos usando os "dados abstratos" especificados pelos construtores e seletores, assim como fizemos para números racionais em <a href="2_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a>. Como mostrado nas fórmulas acima, podemos adicionar e subtrair números complexos em termos de partes real e imaginária, enquanto multiplicamos e dividimos números complexos em termos de magnitudes e ângulos:
        </p>
        <pre><code class="language-scheme">(define (add-complex z1 z2)
  (make-from-real-imag 
   (+ (real-part z1) (real-part z2))
   (+ (imag-part z1) (imag-part z2))))

(define (sub-complex z1 z2)
  (make-from-real-imag 
   (- (real-part z1) (real-part z2))
   (- (imag-part z1) (imag-part z2))))

(define (mul-complex z1 z2)
  (make-from-mag-ang 
   (* (magnitude z1) (magnitude z2))
   (+ (angle z1) (angle z2))))

(define (div-complex z1 z2)
  (make-from-mag-ang 
   (/ (magnitude z1) (magnitude z2))
   (- (angle z1) (angle z2))))</code></pre>

        <p>
            Para completar o pacote de números complexos, devemos escolher uma representação e implementar os construtores e seletores em termos de números primitivos e estrutura de lista primitiva. Há duas maneiras óbvias de fazer isso: podemos representar um número complexo na "forma retangular" como um par (parte real, parte imaginária) ou na "forma polar" como um par (magnitude, ângulo). Qual devemos escolher?
        </p>
        <p>
            Para tornar as diferentes escolhas concretas, imagine que há dois programadores, Ben Bitdiddle e Alyssa P. Hacker, que estão projetando independentemente representações para o sistema de números complexos. Ben escolhe representar números complexos na forma retangular. Com essa escolha, selecionar as partes real e imaginária de um número complexo é direto, assim como construir um número complexo com partes real e imaginária dadas. Para encontrar a magnitude e o ângulo, ou para construir um número complexo com uma magnitude e ângulo dados, ele usa as relações trigonométricas
        </p>
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
                <mtr>
                    <mtd>
                        <mi>x</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <mi>r</mi>
                        <mi>cos</mi>
                        <mo>⁡<!-- ⁡ --></mo>
                        <mi>A</mi>
                        <mo>,</mo>
                    </mtd>
                </mtr>
                <mtr>
                    <mtd>
                        <mi>y</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <mi>r</mi>
                        <mi>sin</mi>
                        <mo>⁡<!-- ⁡ --></mo>
                        <mi>A</mi>
                        <mo>,</mo>
                    </mtd>
                </mtr>
                <mtr>
                    <mtd>
                        <mi>r</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <msqrt>
                            <msup>
                                <mi>x</mi>
                                <mn>2</mn>
                            </msup>
                            <mo>+</mo>
                            <msup>
                                <mi>y</mi>
                                <mn>2</mn>
                            </msup>
                            <mo>,</mo>
                        </msqrt>
                    </mtd>
                </mtr>
                <mtr>
                    <mtd>
                        <mi>A</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <mi>arctan</mi>
                        <mo>⁡<!-- ⁡ --></mo>
                        <mo stretchy="false">(</mo>
                        <mi>y</mi>
                        <mo>,</mo>
                        <mi>x</mi>
                        <mo stretchy="false">)</mo>
                        <mo>,</mo>
                    </mtd>
                </mtr>
            </mtable>
        </math>

        <p>
            que relacionam as partes real e imaginária <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">(</mo>
                    <mi>x</mi>
                    <mo>,</mo>
                    <mi>y</mi>
                    <mo stretchy="false">)</mo>
                </mrow>
            </math> à magnitude e ao ângulo <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">(</mo>
                    <mi>r</mi>
                    <mo>,</mo>
                    <mi>A</mi>
                    <mo stretchy="false">)</mo>
                </mrow>
            </math>.<a class="footnote_link" id="DOCF110" href="#FOOT110"><sup>110</sup></a> A representação de Ben é, portanto, dada pelos seguintes seletores e construtores:
        </p>
        <pre><code class="language-scheme">(define (real-part z) (car z))
(define (imag-part z) (cdr z))

(define (magnitude z)
  (sqrt (+ (square (real-part z)) 
           (square (imag-part z)))))

(define (angle z)
  (atan (imag-part z) (real-part z)))

(define (make-from-real-imag x y) 
  (cons x y))

(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))</code></pre>

        <p>
            Alyssa, em contraste, escolhe representar números complexos na forma polar. Para ela, selecionar a magnitude e o ângulo é direto, mas ela precisa usar as relações trigonométricas para obter as partes real e imaginária. A representação de Alyssa é:
        </p>
        <pre><code class="language-scheme">(define (real-part z)
  (* (magnitude z) (cos (angle z))))

(define (imag-part z)
  (* (magnitude z) (sin (angle z))))

(define (magnitude z) (car z))
(define (angle z) (cdr z))

(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))

(define (make-from-mag-ang r a) 
  (cons r a))</code></pre>

        <p>
            A disciplina de abstração de dados garante que a mesma implementação de <code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code> e <code>div-complex</code> funcionará com a representação de Ben ou a de Alyssa.
        </p>
        <a id="g_t2_002e4_002e2"></a>
        <a id="Tagged-data"></a>
        <h4 class="subsection"><span class="secnum">2.4.2</span><span class="sectitle">Dados Etiquetados</span></h4>

        <p>
            Uma maneira de ver a abstração de dados é como uma aplicação do "princípio do menor compromisso". Na implementação do sistema de números complexos em <a href="#g_t2_002e4_002e1">2.4.1</a>, podemos usar a representação retangular de Ben ou a representação polar de Alyssa. A barreira de abstração formada pelos seletores e construtores nos permite adiar até o último momento possível a escolha de uma representação concreta para nossos objetos de dados e, assim, manter a máxima flexibilidade no design do nosso sistema.
        </p>
        <p>
            O princípio do menor compromisso pode ser levado a extremos ainda maiores. Se desejarmos, podemos manter a ambiguidade de representação mesmo <em>depois</em> de termos projetado os seletores e construtores, e optar por usar tanto a representação de Ben <em>quanto</em> a de Alyssa. Se ambas as representações estiverem incluídas em um único sistema, no entanto, precisaremos de alguma maneira de distinguir dados na forma polar de dados na forma retangular. Caso contrário, se nos pedissem, por exemplo, para encontrar a <code>magnitude</code> do par (3, 4), não saberíamos se responder 5 (interpretando o número na forma retangular) ou 3 (interpretando o número na forma polar). Uma maneira direta de realizar essa distinção é incluir uma <a id="index-type-tag"></a> <em>etiqueta de tipo</em> – o símbolo <code>rectangular</code> ou <code>polar</code> – como parte de cada número complexo. Então, quando precisarmos manipular um número complexo, podemos usar a etiqueta para decidir qual seletor aplicar.
        </p>
        <p>
            Para manipular dados etiquetados, assumiremos que temos procedimentos <code>type-tag</code> e <code>contents</code> que extraem de um objeto de dados a etiqueta e o conteúdo real (as coordenadas polares ou retangulares, no caso de um número complexo). Também postularemos um procedimento <code>attach-tag</code> que recebe uma etiqueta e um conteúdo e produz um objeto de dados etiquetado. Uma maneira direta de implementar isso é usar a estrutura de lista comum:
        </p>
        <pre><code class="language-scheme">(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: 
              TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: 
              CONTENTS" datum)))</code></pre>

        <p>
            Usando esses procedimentos, podemos definir predicados <code>rectangular?</code> e <code>polar?</code>, que reconhecem números retangulares e polares, respectivamente:
        </p>
        <pre><code class="language-scheme">(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))

(define (polar? z)
  (eq? (type-tag z) 'polar))</code></pre>

        <p>
            Com as etiquetas de tipo, Ben e Alyssa podem agora modificar seu código para que suas duas representações diferentes possam coexistir no mesmo sistema. Sempre que Ben constrói um número complexo, ele o etiqueta como retangular. Sempre que Alyssa constrói um número complexo, ela o etiqueta como polar. Além disso, Ben e Alyssa devem garantir que os nomes de seus procedimentos não entrem em conflito. Uma maneira de fazer isso é Ben anexar o sufixo <code>rectangular</code> ao nome de cada um de seus procedimentos de representação e Alyssa anexar <code>polar</code> aos nomes dos dela. Aqui está a representação retangular revisada de Ben de <a href="#g_t2_002e4_002e1">2.4.1</a>:
        </p>
        <pre><code class="language-scheme">(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z) (cdr z))

(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))

(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))

(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))

(define (make-from-mag-ang-rectangular r a)
  (attach-tag 
   'rectangular
   (cons (* r (cos a)) (* r (sin a)))))</code></pre>

        <p>e aqui está a representação polar revisada de Alyssa:</p>
        <pre><code class="language-scheme">(define (real-part-polar z)
  (* (magnitude-polar z) 
     (cos (angle-polar z))))

(define (imag-part-polar z)
  (* (magnitude-polar z) 
     (sin (angle-polar z))))

(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))

(define (make-from-real-imag-polar x y)
  (attach-tag 
   'polar
   (cons (sqrt (+ (square x) (square y)))
         (atan y x))))

(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))</code></pre>

        <p>
            Cada seletor genérico é implementado como um procedimento que verifica a etiqueta de seu argumento e chama o procedimento apropriado para lidar com dados desse tipo. Por exemplo, para obter a parte real de um número complexo, <code>real-part</code> examina a etiqueta para determinar se deve usar o <code>real-part-rectangular</code> de Ben ou o <code>real-part-polar</code> de Alyssa. Em ambos os casos, usamos <code>contents</code> para extrair o dado bruto, sem etiqueta, e enviá-lo ao procedimento retangular ou polar conforme necessário:
        </p>
        <pre><code class="language-scheme">(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else
         (error "Unknown type: 
               REAL-PART" z))))

(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else
         (error "Unknown type: 
               IMAG-PART" z))))

(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else
         (error "Unknown type: 
               MAGNITUDE" z))))

(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else
         (error "Unknown type: 
               ANGLE" z))))</code></pre>

        <p>
            Para implementar as operações aritméticas de números complexos, podemos usar os mesmos procedimentos <code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code> e <code>div-complex</code> de <a href="#g_t2_002e4_002e1">2.4.1</a>, porque os seletores que eles chamam são genéricos e, portanto, funcionarão com qualquer representação. Por exemplo, o procedimento <code>add-complex</code> ainda é
        </p>
        <pre><code class="language-scheme">(define (add-complex z1 z2)
  (make-from-real-imag 
   (+ (real-part z1) (real-part z2))
   (+ (imag-part z1) (imag-part z2))))</code></pre>

        <p>
            Finalmente, devemos escolher se construímos números complexos usando a representação de Ben ou a de Alyssa. Uma escolha razoável é construir números retangulares sempre que tivermos partes real e imaginária e construir números polares sempre que tivermos magnitudes e ângulos:
        </p>
        <pre><code class="language-scheme">(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))

(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))</code></pre>

        <p>
            O sistema de números complexos resultante tem a estrutura mostrada na <a href="#Figure-2_002e21">Figura 2.21</a>. O sistema foi decomposto em três partes relativamente independentes: as operações aritméticas de números complexos, a implementação polar de Alyssa e a implementação retangular de Ben. As implementações polar e retangular poderiam ter sido escritas por Ben e Alyssa trabalhando separadamente, e ambas podem ser usadas como representações subjacentes por um terceiro programador implementando os procedimentos aritméticos complexos em termos da interface abstrata de construtores/seletores.
        </p>
        <figure class="float">
            <a id="Figure-2_002e21"></a>
            <object style="width: 65.01ex; height: 33.59ex;" data="fig/chap2/Fig2.21a.std.svg" type="image/svg+xml">SVG</object>
            <figcaption class="float-caption">
                <p><strong>Figura 2.21:</strong> Estrutura do sistema genérico de aritmética complexa.</p>
            </figcaption>
        </figure>

        <p>
            Como cada objeto de dados é etiquetado com seu tipo, os seletores operam nos dados de maneira genérica. Ou seja, cada seletor é definido para ter um comportamento que depende do tipo específico de dados ao qual é aplicado. Observe o mecanismo geral para interfacear as representações separadas: Dentro de uma determinada implementação de representação (digamos, o pacote polar de Alyssa), um número complexo é um par sem tipo (magnitude, ângulo). Quando um seletor genérico opera em um número do tipo <code>polar</code>, ele remove a etiqueta e passa o conteúdo para o código de Alyssa. Por outro lado, quando Alyssa constrói um número para uso geral, ela o etiqueta com um tipo para que ele possa ser reconhecido apropriadamente pelos procedimentos de nível superior. Essa disciplina de remover e anexar etiquetas à medida que os objetos de dados são passados de nível para nível pode ser uma estratégia organizacional importante, como veremos em <a href="2_002e5.xhtml#g_t2_002e5">2.5</a>.
        </p>
        <a id="g_t2_002e4_002e3"></a>
        <a id="Data_002dDirected-Programming-and-Additivity"></a>
        <h4 class="subsection"><span class="secnum">2.4.3</span><span class="sectitle">Programação Orientada a Dados e Aditividade</span></h4>

        <p>
            A estratégia geral de verificar o tipo de um dado e chamar um procedimento apropriado é chamada de <a id="index-dispatching-on-type"></a> <em>despacho por tipo</em>. Essa é uma estratégia poderosa para obter modularidade no design de sistemas. Por outro lado, implementar o despacho como em <a href="#g_t2_002e4_002e2">2.4.2</a> tem duas fraquezas significativas. Uma fraqueza é que os procedimentos de interface genérica (<code>real-part</code>, <code>imag-part</code>, <code>magnitude</code> e <code>angle</code>) devem conhecer todas as diferentes representações. Por exemplo, suponha que quiséssemos incorporar uma nova representação para números complexos em nosso sistema de números complexos. Precisaríamos identificar essa nova representação com um tipo e, em seguida, adicionar uma cláusula a cada um dos procedimentos de interface genérica para verificar o novo tipo e aplicar o seletor apropriado para essa representação.
        </p>
        <p>
            Outra fraqueza da técnica é que, embora as representações individuais possam ser projetadas separadamente, devemos garantir que nenhum dois procedimentos em todo o sistema tenham o mesmo nome. É por isso que Ben e Alyssa tiveram que mudar os nomes de seus procedimentos originais de <a href="#g_t2_002e4_002e1">2.4.1</a>.
        </p>
        <p>
            A questão subjacente a ambas essas fraquezas é que a técnica para implementar interfaces genéricas não é <a id="index-additive"></a> <em>aditiva</em>. A pessoa que implementa os procedimentos de seletores genéricos deve modificar esses procedimentos cada vez que uma nova representação é instalada, e as pessoas que interfaceiam as representações individuais devem modificar seu código para evitar conflitos de nomes. Em cada um desses casos, as mudanças que devem ser feitas no código são diretas, mas devem ser feitas mesmo assim, e isso é uma fonte de inconveniência e erro. Isso não é um grande problema para o sistema de números complexos como ele está, mas suponha que houvesse não duas, mas centenas de diferentes representações para números complexos. E suponha que houvesse muitos seletores genéricos para serem mantidos na interface de dados abstratos. Suponha, de fato, que nenhum programador conhecesse todos os procedimentos de interface ou todas as representações. O problema é real e deve ser abordado em programas como sistemas de gerenciamento de banco de dados em grande escala.
        </p>
        <p>
            O que precisamos é de um meio para modularizar ainda mais o design do sistema. Isso é fornecido pela técnica de programação conhecida como <a id="index-data_002ddirected-programming-1"></a> <em>programação orientada a dados</em>. Para entender como a programação orientada a dados funciona, comece com a observação de que sempre que lidamos com um conjunto de operações genéricas que são comuns a um conjunto de diferentes tipos, estamos, de fato, lidando com uma tabela bidimensional que contém as operações possíveis em um eixo e os tipos possíveis no outro eixo. As entradas na tabela são os procedimentos que implementam cada operação para cada tipo de argumento apresentado. No sistema de números complexos desenvolvido na seção anterior, a correspondência entre o nome da operação, o tipo de dados e o procedimento real foi espalhada entre as várias cláusulas condicionais nos procedimentos de interface genérica. Mas a mesma informação poderia ter sido organizada em uma tabela, como mostrado na <a href="#Figure-2_002e22">Figura 2.22</a>.
        </p>
        <figure class="float">
            <a id="Figure-2_002e22"></a>
            <object style="width: 63.29ex; height: 20.98ex;" data="fig/chap2/Fig2.22.std.svg" type="image/svg+xml">SVG</object>
            <figcaption class="float-caption">
                <p><strong>Figura 2.22:</strong> Tabela de operações para o sistema de números complexos.</p>
            </figcaption>
        </figure>

        <p>
            A programação orientada a dados é a técnica de projetar programas para trabalhar diretamente com essa tabela. Anteriormente, implementamos o mecanismo que interfaceia o código de aritmética complexa com os dois pacotes de representação como um conjunto de procedimentos que cada um realiza um despacho explícito por tipo. Aqui, implementaremos a interface como um único procedimento que procura a combinação do nome da operação e do tipo do argumento na tabela para encontrar o procedimento correto a ser aplicado e, em seguida, aplica-o ao conteúdo do argumento. Se fizermos isso, então, para adicionar um novo pacote de representação ao sistema, não precisamos mudar nenhum procedimento existente; precisamos apenas adicionar novas entradas à tabela.
        </p>
        <p>
            Para implementar esse plano, assuma que temos dois procedimentos, <code>put</code> e <code>get</code>, para manipular a tabela de operações e tipos:
        </p>
        <ul>
            <li> <code>(put ⟨<var>op</var>⟩ ⟨<var>type</var>⟩ ⟨<var>item</var>⟩)</code> instala o <code>⟨</code><var>item</var><code>⟩</code> na tabela, indexado pelo <code>⟨</code><var>op</var><code>⟩</code> e o <code>⟨</code><var>type</var><code>⟩</code>.</li>
            <li> <code>(get ⟨<var>op</var>⟩ ⟨<var>type</var>⟩)</code> procura a entrada <code>⟨</code><var>op</var><code>⟩</code>, <code>⟨</code><var>type</var><code>⟩</code> na tabela e retorna o item encontrado lá. Se nenhum item for encontrado, <code>get</code> retorna falso.</li>
        </ul>

        <p>
            Por enquanto, podemos assumir que <code>put</code> e <code>get</code> estão incluídos em nossa linguagem. Em <a href="Chapter-3.xhtml#Chapter-3">Capítulo 3</a> (<a href="3_002e3.xhtml#g_t3_002e3_002e3">3.3.3</a>), veremos como implementar essas e outras operações para manipular tabelas.
        </p>
        <p>
            Aqui está como a programação orientada a dados pode ser usada no sistema de números complexos. Ben, que desenvolveu a representação retangular, implementa seu código exatamente como fez originalmente. Ele define uma coleção de procedimentos, ou um <a id="index-package"></a> <em>pacote</em>, e interfaceia esses procedimentos com o resto do sistema adicionando entradas à tabela que dizem ao sistema como operar em números retangulares. Isso é realizado chamando o seguinte procedimento:
        </p>
        <pre><code class="language-scheme">(define (install-rectangular-package)
  ;; procedimentos internos
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) 
    (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface com o resto do sistema
  (define (tag x) 
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) 
         (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) 
         (tag (make-from-mag-ang r a))))
  'done)</code></pre>

        <p>
            Observe que os procedimentos internos aqui são os mesmos procedimentos de <a href="#g_t2_002e4_002e1">2.4.1</a> que Ben escreveu quando estava trabalhando isoladamente. Nenhuma mudança é necessária para interfaceá-los com o resto do sistema. Além disso, como essas definições de procedimentos são internas ao procedimento de instalação, Ben não precisa se preocupar com conflitos de nomes com outros procedimentos fora do pacote retangular. Para interfacear esses procedimentos com o resto do sistema, Ben instala seu procedimento <code>real-part</code> sob o nome de operação <code>real-part</code> e o tipo <code>(rectangular)</code>, e da mesma forma para os outros seletores.<a class="footnote_link" id="DOCF111" href="#FOOT111"><sup>111</sup></a> A interface também define os construtores a serem usados pelo sistema externo.<a class="footnote_link" id="DOCF112" href="#FOOT112"><sup>112</sup></a> Esses são idênticos aos construtores definidos internamente por Ben, exceto que eles anexam a etiqueta.
        </p>
        <p>
            O pacote polar de Alyssa é análogo:
        </p>
        <pre><code class="language-scheme">(define (install-polar-package)
  ;; procedimentos internos
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface com o resto do sistema
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) 
         (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) 
         (tag (make-from-mag-ang r a))))
  'done)</code></pre>

        <p>
            Mesmo que Ben e Alyssa ainda usem seus procedimentos originais definidos com os mesmos nomes que os do outro (por exemplo, <code>real-part</code>), essas definições agora são internas a diferentes procedimentos (veja <a href="1_002e1.xhtml#g_t1_002e1_002e8">1.