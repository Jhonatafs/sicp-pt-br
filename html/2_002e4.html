<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.4">
    <meta name="keywords" content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.4">
    <title>Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.4</title>
    <link href="index.xhtml#Top" rel="start" title="Topo">
    <link href="Term-Index.xhtml#Term-Index" rel="index" title="Índice de Termos">
    <link href="index.xhtml#SEC_Contents" rel="contents" title="Sumário">
    <link href="Chapter-2.xhtml#Chapter-2" rel="prev" title="Capítulo 2">
    <link href="2_002e5.xhtml#g_t2_002e5" rel="next" title="2.5">
    <link href="2_002e3.xhtml#g_t2_002e3_002e4" rel="prev" title="2.3.4">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/prettify.css" rel="stylesheet" type="text/css">
    <script src="js/jquery.min.js" type="text/javascript"></script>
    <script src="js/footnotes.js" type="text/javascript"></script>
    <script src="js/browsertest.js" type="text/javascript"></script>
</head>
<body>
    <section>
        <span class="top jump" title="Ir para o topo"><a href="#pagetop" accesskey="t">⇡</a></span>
        <a id="pagetop"></a>
        <a id="g_t2_002e4"></a>
        <nav class="header">
            <p>
                Próximo: <a href="2_002e5.xhtml#g_t2_002e5" accesskey="n" rel="next">2.5</a>, Anterior: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="p" rel="prev">2.3</a>, Acima: <a href="Chapter-2.xhtml#Chapter-2" accesskey="u" rel="prev">Capítulo 2</a>   [<a href="index.xhtml#SEC_Contents" title="Sumário" accesskey="c" rel="contents">Sumário</a>]
            </p>
        </nav>
        <a id="Multiple-Representations-for-Abstract-Data"></a>
        <h3 class="section"><span class="secnum">2.4</span><span class="sectitle">Múltiplas Representações para Dados Abstratos</span></h3>

        <p>
            Introduzimos a abstração de dados, uma metodologia para estruturar sistemas de forma que grande parte de um programa possa ser especificada independentemente das escolhas envolvidas na implementação dos objetos de dados que o programa manipula. Por exemplo, vimos em <a href="2_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a> como separar a tarefa de projetar um programa que usa números racionais da tarefa de implementar números racionais em termos dos mecanismos primitivos da linguagem de computador para construir dados compostos. A ideia principal foi erguer uma barreira de abstração – neste caso, os seletores e construtores para números racionais (<code>make-rat</code>, <code>numer</code>, <code>denom</code>) – que isola a forma como os números racionais são usados de sua representação subjacente em termos de estrutura de lista. Uma barreira de abstração semelhante isola os detalhes dos procedimentos que realizam aritmética racional (<code>add-rat</code>, <code>sub-rat</code>, <code>mul-rat</code> e <code>div-rat</code>) dos procedimentos de "nível superior" que usam números racionais. O programa resultante tem a estrutura mostrada em <a href="2_002e1.xhtml#Figure-2_002e1">Figura 2.1</a>.
        </p>
        <p>
            Essas barreiras de abstração de dados são ferramentas poderosas para controlar a complexidade. Ao isolar as representações subjacentes dos objetos de dados, podemos dividir a tarefa de projetar um grande programa em tarefas menores que podem ser realizadas separadamente. Mas esse tipo de abstração de dados ainda não é poderoso o suficiente, porque nem sempre faz sentido falar de "a representação subjacente" para um objeto de dados.
        </p>
        <p>
            Por um lado, pode haver mais de uma representação útil para um objeto de dados, e podemos querer projetar sistemas que possam lidar com múltiplas representações. Para dar um exemplo simples, números complexos podem ser representados de duas formas quase equivalentes: na forma retangular (partes real e imaginária) e na forma polar (magnitude e ângulo). Às vezes, a forma retangular é mais apropriada e, às vezes, a forma polar é mais apropriada. De fato, é perfeitamente plausível imaginar um sistema em que os números complexos são representados de ambas as formas, e em que os procedimentos para manipular números complexos funcionam com qualquer representação.
        </p>
        <p>
            Mais importante, os sistemas de programação são frequentemente projetados por muitas pessoas trabalhando por longos períodos de tempo, sujeitos a requisitos que mudam com o tempo. Em tal ambiente, simplesmente não é possível que todos concordem antecipadamente sobre as escolhas de representação de dados. Portanto, além das barreiras de abstração de dados que isolam a representação do uso, precisamos de barreiras de abstração que isolem diferentes escolhas de design umas das outras e permitam que diferentes escolhas coexistam em um único programa. Além disso, como grandes programas são frequentemente criados combinando módulos pré-existentes que foram projetados isoladamente, precisamos de convenções que permitam aos programadores incorporar módulos em sistemas maiores <a id="index-additively-1"></a> <em>aditivamente</em>, ou seja, sem precisar redesenhar ou reimplementar esses módulos.
        </p>
        <p>
            Nesta seção, aprenderemos como lidar com dados que podem ser representados de diferentes maneiras por diferentes partes de um programa. Isso requer a construção de <a id="index-generic-procedures-1"></a> <em>procedimentos genéricos</em> – procedimentos que podem operar em dados que podem ser representados de mais de uma maneira. Nossa principal técnica para construir procedimentos genéricos será trabalhar em termos de objetos de dados que possuem <a id="index-type-tags"></a> <em>etiquetas de tipo</em>, ou seja, objetos de dados que incluem informações explícitas sobre como devem ser processados. Também discutiremos <a id="index-data_002ddirected"></a> <em>programação orientada a dados</em>, uma estratégia de implementação poderosa e conveniente para montar sistemas aditivamente com operações genéricas.
        </p>
        <p>
            Começamos com o exemplo simples de números complexos. Veremos como as etiquetas de tipo e o estilo orientado a dados nos permitem projetar representações retangulares e polares separadas para números complexos, mantendo a noção de um objeto de dados abstrato "número complexo". Conseguiremos isso definindo procedimentos aritméticos para números complexos (<code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code> e <code>div-complex</code>) em termos de seletores genéricos que acessam partes de um número complexo independentemente de como o número é representado. O sistema de números complexos resultante, como mostrado em <a href="#Figure-2_002e19">Figura 2.19</a>, contém dois tipos diferentes de barreiras de abstração. As barreiras de abstração "horizontais" desempenham o mesmo papel que as da <a href="2_002e1.xhtml#Figure-2_002e1">Figura 2.1</a>. Elas isolam operações de "nível superior" de representações de "nível inferior". Além disso, há uma barreira "vertical" que nos dá a capacidade de projetar e instalar representações alternativas separadamente.
        </p>
        <figure class="float">
            <a id="Figure-2_002e19"></a>
            <object style="width: 40.41ex; height: 33.41ex;" data="fig/chap2/Fig2.19a.std.svg" type="image/svg+xml">SVG</object>
            <figcaption class="float-caption">
                <p><strong>Figura 2.19:</strong> Barreiras de abstração de dados no sistema de números complexos.</p>
            </figcaption>
        </figure>

        <p>
            Em <a href="2_002e5.xhtml#g_t2_002e5">2.5</a>, mostraremos como usar etiquetas de tipo e o estilo orientado a dados para desenvolver um pacote aritmético genérico. Isso fornece procedimentos (<code>add</code>, <code>mul</code>, e assim por diante) que podem ser usados para manipular todos os tipos de "números" e podem ser facilmente estendidos quando um novo tipo de número é necessário. Em <a href="2_002e5.xhtml#g_t2_002e5_002e3">2.5.3</a>, mostraremos como usar aritmética genérica em um sistema que realiza álgebra simbólica.
        </p>

        <a id="g_t2_002e4_002e1"></a>
        <a id="Representations-for-Complex-Numbers"></a>
        <h4 class="subsection"><span class="secnum">2.4.1</span><span class="sectitle">Representações para Números Complexos</span></h4>

        <p>
            Desenvolveremos um sistema que realiza operações aritméticas em números complexos como um exemplo simples, mas irrealista, de um programa que usa operações genéricas. Começamos discutindo duas representações plausíveis para números complexos como pares ordenados: a forma retangular (parte real e parte imaginária) e a forma polar (magnitude e ângulo).<a class="footnote_link" id="DOCF109" href="#FOOT109"><sup>109</sup></a> A seção <a href="#g_t2_002e4_002e2">2.4.2</a> mostrará como ambas as representações podem coexistir em um único sistema por meio do uso de etiquetas de tipo e operações genéricas.
        </p>
        <p>
            Assim como os números racionais, os números complexos são naturalmente representados como pares ordenados. O conjunto de números complexos pode ser pensado como um espaço bidimensional com dois eixos ortogonais, o eixo "real" e o eixo "imaginário". (Veja <a href="#Figure-2_002e20">Figura 2.20</a>.) Desse ponto de vista, o número complexo <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <mi>z</mi>
                    <mo>=</mo>
                    <mi>x</mi>
                    <mo>+</mo>
                    <mi>i</mi>
                    <mi>y</mi>
                </mrow>
            </math> (onde <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <msup>
                        <mi>i</mi>
                        <mrow class="MJX-TeXAtom-ORD">
                            <mspace width="0.1em"/>
                            <mn>2</mn>
                        </mrow>
                    </msup>
                    <mo>=</mo>
                    <mtext>−1</mtext>
                </mrow>
            </math>) pode ser pensado como o ponto no plano cuja coordenada real é <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>x</mi>
            </math> e cuja coordenada imaginária é <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>y</mi>
            </math>. A adição de números complexos reduz-se, nesta representação, à adição de coordenadas:
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
                    <mtr>
                        <mtd>
                            <mtext>Parte Real</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>+</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Parte Real</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>+</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd/>
                        <mtd/>
                        <mtd>
                            <mtext>Parte Real</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>,</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mtext>Parte Imaginária</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>+</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Parte Imaginária</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>+</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd/>
                        <mtd/>
                        <mtd>
                            <mtext>Parte Imaginária</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>.</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
        <figure class="float">
            <a id="Figure-2_002e20"></a>
            <object style="width: 51.98ex; height: 30.74ex;" data="fig/chap2/Fig2.20.std.svg" type="image/svg+xml">SVG</object>
            <figcaption class="float-caption">
                <p><strong>Figura 2.20:</strong> Números complexos como pontos no plano.</p>
            </figcaption>
        </figure>

        <p>
            Ao multiplicar números complexos, é mais natural pensar em termos de representar um número complexo na forma polar, como uma magnitude e um ângulo (<math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>r</mi>
            </math> e <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>A</mi>
            </math> na <a href="#Figure-2_002e20">Figura 2.20</a>). O produto de dois números complexos é o vetor obtido esticando um número complexo pelo comprimento do outro e depois girando-o pelo ângulo do outro:
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
                    <mtr>
                        <mtd>
                            <mtext>Magnitude</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>⋅<!-- ⋅ --></mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Magnitude</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>⋅<!-- ⋅ --></mo>
                            <mtext>Magnitude</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>,</mo>
                        </mtd>
                    </mtr>
                    <mtr>
                        <mtd>
                            <mtext>Ângulo</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo>⋅<!-- ⋅ --></mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                            <mo>=</mo>
                        </mtd>
                        <mtd>
                            <mtext>Ângulo</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>1</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>+</mo>
                            <mtext>Ângulo</mtext>
                            <mo stretchy="false">(</mo>
                            <msub>
                                <mi>z</mi>
                                <mn>2</mn>
                            </msub>
                            <mo stretchy="false">)</mo>
                            <mo>.</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </p>
        <p>
            Assim, existem duas representações diferentes para números complexos, que são apropriadas para diferentes operações. No entanto, do ponto de vista de alguém escrevendo um programa que usa números complexos, o princípio da abstração de dados sugere que todas as operações para manipular números complexos devem estar disponíveis, independentemente de qual representação é usada pelo computador. Por exemplo, muitas vezes é útil poder encontrar a magnitude de um número complexo especificado por coordenadas retangulares. Da mesma forma, muitas vezes é útil determinar a parte real de um número complexo especificado por coordenadas polares.
        </p>
        <p>
            Para projetar tal sistema, podemos seguir a mesma estratégia de abstração de dados que seguimos ao projetar o pacote de números racionais em <a href="2_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a>. Suponha que as operações em números complexos sejam implementadas em termos de quatro seletores: <code>real-part</code>, <code>imag-part</code>, <code>magnitude</code> e <code>angle</code>. Também suponha que temos dois procedimentos para construir números complexos: <code>make-from-real-imag</code> retorna um número complexo com partes real e imaginária especificadas, e <code>make-from-mag-ang</code> retorna um número complexo com magnitude e ângulo especificados. Esses procedimentos têm a propriedade de que, para qualquer número complexo <code>z</code>, ambos
        </p>
        <pre><code class="language-scheme">(make-from-real-imag (real-part z) 
                     (imag-part z))</code></pre>

        <p>e</p>
        <pre><code class="language-scheme">(make-from-mag-ang (magnitude z) 
                   (angle z))</code></pre>

        <p>produzem números complexos que são iguais a <code>z</code>.</p>
        <p>
            Usando esses construtores e seletores, podemos implementar aritmética em números complexos usando os "dados abstratos" especificados pelos construtores e seletores, assim como fizemos para números racionais em <a href="2_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a>. Como mostrado nas fórmulas acima, podemos adicionar e subtrair números complexos em termos de partes real e imaginária, enquanto multiplicamos e dividimos números complexos em termos de magnitudes e ângulos:
        </p>
        <pre><code class="language-scheme">(define (add-complex z1 z2)
  (make-from-real-imag 
   (+ (real-part z1) (real-part z2))
   (+ (imag-part z1) (imag-part z2))))

(define (sub-complex z1 z2)
  (make-from-real-imag 
   (- (real-part z1) (real-part z2))
   (- (imag-part z1) (imag-part z2))))

(define (mul-complex z1 z2)
  (make-from-mag-ang 
   (* (magnitude z1) (magnitude z2))
   (+ (angle z1) (angle z2))))

(define (div-complex z1 z2)
  (make-from-mag-ang 
   (/ (magnitude z1) (magnitude z2))
   (- (angle z1) (angle z2))))</code></pre>

        <p>
            Para completar o pacote de números complexos, devemos escolher uma representação e implementar os construtores e seletores em termos de números primitivos e estrutura de lista primitiva. Há duas maneiras óbvias de fazer isso: podemos representar um número complexo na "forma retangular" como um par (parte real, parte imaginária) ou na "forma polar" como um par (magnitude, ângulo). Qual devemos escolher?
        </p>
        <p>
            Para tornar as diferentes escolhas concretas, imagine que há dois programadores, Ben Bitdiddle e Alyssa P. Hacker, que estão projetando independentemente representações para o sistema de números complexos. Ben escolhe representar números complexos na forma retangular. Com essa escolha, selecionar as partes real e imaginária de um número complexo é direto, assim como construir um número complexo com partes real e imaginária dadas. Para encontrar a magnitude e o ângulo, ou para construir um número complexo com uma magnitude e ângulo dados, ele usa as relações trigonométricas
        </p>
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
                <mtr>
                    <mtd>
                        <mi>x</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <mi>r</mi>
                        <mi>cos</mi>
                        <mo>⁡<!-- ⁡ --></mo>
                        <mi>A</mi>
                        <mo>,</mo>
                    </mtd>
                </mtr>
                <mtr>
                    <mtd>
                        <mi>y</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <mi>r</mi>
                        <mi>sin</mi>
                        <mo>⁡<!-- ⁡ --></mo>
                        <mi>A</mi>
                        <mo>,</mo>
                    </mtd>
                </mtr>
                <mtr>
                    <mtd>
                        <mi>r</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <msqrt>
                            <msup>
                                <mi>x</mi>
                                <mn>2</mn>
                            </msup>
                            <mo>+</mo>
                            <msup>
                                <mi>y</mi>
                                <mn>2</mn>
                            </msup>
                            <mo>,</mo>
                        </msqrt>
                    </mtd>
                </mtr>
                <mtr>
                    <mtd>
                        <mi>A</mi>
                    </mtd>
                    <mtd>
                        <mo>=</mo>
                    </mtd>
                    <mtd>
                        <mi>arctan</mi>
                        <mo>⁡<!-- ⁡ --></mo>
                        <mo stretchy="false">(</mo>
                        <mi>y</mi>
                        <mo>,</mo>
                        <mi>x</mi>
                        <mo stretchy="false">)</mo>
                        <mo>,</mo>
                    </mtd>
                </mtr>
            </mtable>
        </math>

        <p>
            que relacionam as partes real e imaginária <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">(</mo>
                    <mi>x</mi>
                    <mo>,</mo>
                    <mi>y</mi>
                    <mo stretchy="false">)</mo>
                </mrow>
            </math> à magnitude e ao ângulo <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">(</mo>
                    <mi>r</mi>
                    <mo>,</mo>
                    <mi>A</mi>
                    <mo stretchy="false">)</mo>
                </mrow>
            </math>.<a class="footnote_link" id="DOCF110" href="#FOOT110"><sup>110</sup></a> A representação de Ben é, portanto, dada pelos seguintes seletores e construtores:
        </p>
        <pre><code class="language-scheme">(define (real-part z) (car z))
(define (imag-part z) (cdr z))

(define (magnitude z)
  (sqrt (+ (square (real-part z)) 
           (square (imag-part z)))))

(define (angle z)
  (atan (imag-part z) (real-part z)))

(define (make-from-real-imag x y) 
  (cons x y))

(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))</code></pre>

        <p>
            Alyssa, em contraste, escolhe representar números complexos na forma polar. Para ela, selecionar a magnitude e o ângulo é direto, mas ela precisa usar as relações trigonométricas para obter as partes real e imaginária. A representação de Alyssa é:
        </p>
        <pre><code class="language-scheme">(define (real-part z)
  (* (magnitude z) (cos (angle z))))

(define (imag-part z)
  (* (magnitude z) (sin (angle z))))

(define (magnitude z) (car z))
(define (angle z) (cdr z))

(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))

(define (make-from-mag-ang r a) 
  (cons r a))</code></pre>

        <p>
            A disciplina de abstração de dados garante que a mesma implementação de <code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code> e <code>div-complex</code> funcionará com a representação de Ben ou a de Alyssa.
        </p>
        <a id="g_t2_002e4_002e2"></a>
        <a id="Tagged-data"></a>
        <h4 class="subsection"><span class="secnum">2.4.2</span><span class="sectitle">Dados Etiquetados</span></h4>

        <p>
            Uma maneira de ver a abstração de dados é como uma aplicação do "princípio do menor compromisso". Na implementação do sistema de números complexos em <a href="#g_t2_002e4_002e1">2.4.1</a>, podemos usar a representação retangular de Ben ou a representação polar de Alyssa. A barreira de abstração formada pelos seletores e construtores nos permite adiar até o último momento possível a escolha de uma representação concreta para nossos objetos de dados e, assim, manter a máxima flexibilidade no design do nosso sistema.
        </p>
        <p>
            O princípio do menor compromisso pode ser levado a extremos ainda maiores. Se desejarmos, podemos manter a ambiguidade de representação mesmo <em>depois</em> de termos projetado os seletores e construtores, e optar por usar tanto a representação de Ben <em>quanto</em> a de Alyssa. Se ambas as representações estiverem incluídas em um único sistema, no entanto, precisaremos de alguma maneira de distinguir dados na forma polar de dados na forma retangular. Caso contrário, se nos pedissem, por exemplo, para encontrar a <code>magnitude</code> do par (3, 4), não saberíamos se responder 5 (interpretando o número na forma retangular) ou 3 (interpretando o número na forma polar). Uma maneira direta de realizar essa distinção é incluir uma <a id="index-type-tag"></a> <em>etiqueta de tipo</em> – o símbolo <code>rectangular</code> ou <code>polar</code> – como parte de cada número complexo. Então, quando precisarmos manipular um número complexo, podemos usar a etiqueta para decidir qual seletor aplicar.
        </p>
        <p>
            Para manipular dados etiquetados, assumiremos que temos procedimentos <code>type-tag</code> e <code>contents</code> que extraem de um objeto de dados a etiqueta e o conteúdo real (as coordenadas polares ou retangulares, no caso de um número complexo). Também postularemos um procedimento <code>attach-tag</code> que recebe uma etiqueta e um conteúdo e produz um objeto de dados etiquetado. Uma maneira direta de implementar isso é usar a estrutura de lista comum:
        </p>
        <pre><code class="language-scheme">(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: 
              TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: 
              CONTENTS" datum)))</code></pre>

        <p>
            Usando esses procedimentos, podemos definir predicados <code>rectangular?</code> e <code>polar?</code>, que reconhecem números retangulares e polares, respectivamente:
        </p>
        <pre><code class="language-scheme">(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))

(define (polar? z)
  (eq? (type-tag z) 'polar))</code></pre>

        <p>
            Com as etiquetas de tipo, Ben e Alyssa podem agora modificar seu código para que suas duas representações diferentes possam coexistir no mesmo sistema. Sempre que Ben constrói um número complexo, ele o etiqueta como retangular. Sempre que Alyssa constrói um número complexo, ela o etiqueta como polar. Além disso, Ben e Alyssa devem garantir que os nomes de seus procedimentos não entrem em conflito. Uma maneira de fazer isso é Ben anexar o sufixo <code>rectangular</code> ao nome de cada um de seus procedimentos de representação e Alyssa anexar <code>polar</code> aos nomes dos dela. Aqui está a representação retangular revisada de Ben de <a href="#g_t2_002e4_002e1">2.4.1</a>:
        </p>
        <pre><code class="language-scheme">(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z) (cdr z))

(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))

(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))

(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))

(define (make-from-mag-ang-rectangular r a)
  (attach-tag 
   'rectangular
   (cons (* r (cos a)) (* r (sin a)))))</code></pre>

        <p>e aqui está a representação polar revisada de Alyssa:</p>
        <pre><code class="language-scheme">(define (real-part-polar z)
  (* (magnitude-polar z) 
     (cos (angle-polar z))))

(define (imag-part-polar z)
  (* (magnitude-polar z) 
     (sin (angle-polar z))))

(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))

(define (make-from-real-imag-polar x y)
  (attach-tag 
   'polar
   (cons (sqrt (+ (square x) (square y)))
         (atan y x))))

(define (make-from-m