<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.1"
    />
    <meta
      name="keywords"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.1"
    />
    <title>
      Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.1
    </title>
    <link rel="stylesheet" href="css/style.css" />
    <!--<link rel="stylesheet" href="css/prettify.css" />-->
    <link rel="stylesheet" href="css/highlight.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="js/jquery.min.js"></script>
    <script src="js/footnotes.js"></script>
    <script src="js/browsertest.js"></script>
  </head>
  <body>
    <section>
      <span class="top jump"><a href="#pagetop" accesskey="t">⇡</a></span>
      <a id="pagetop"></a>
      <nav class="header">
        <p>
          Próximo:
          <a href="1_002e2.html#g_t1_002e2" accesskey="n" rel="next">1.2</a>,
          Anterior:
          <a href="Chapter-1.html#Chapter-1" accesskey="p" rel="prev"
            >Capítulo 1</a
          >, Acima:
          <a href="Chapter-1.html#Chapter-1" accesskey="u" rel="prev"
            >Capítulo 1</a
          >
          [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Conteúdo</a
          >]
        </p>
      </nav>
      <a id="g_t1_002e1"></a>
      <h3 class="section">
        <span class="secnum">1.1</span
        ><span class="sectitle">Os Elementos da Programação</span>
      </h3>

      <p>
        Uma linguagem de programação poderosa é mais do que apenas um meio para
        instruir um computador a realizar tarefas. A linguagem também serve como
        uma estrutura dentro da qual organizamos nossas ideias sobre processos.
        Assim, ao descrever uma linguagem, devemos prestar atenção especial aos
        meios que a linguagem fornece para combinar ideias simples e formar
        ideias mais complexas. Toda linguagem poderosa possui três mecanismos
        para realizar isso:
      </p>
      <ul>
        <li>
          <strong>expressões primitivas</strong>, que representam as entidades
          mais simples com as quais a linguagem se preocupa,
        </li>
        <li>
          <strong>meios de combinação</strong>, pelos quais elementos compostos
          são construídos a partir de elementos mais simples, e
        </li>
        <li>
          <strong>meios de abstração</strong>, pelos quais elementos compostos
          podem ser nomeados e manipulados como unidades.
        </li>
      </ul>

      <p>
        Na programação, lidamos com dois tipos de elementos: procedimentos e
        dados. (Mais tarde, descobriremos que eles não são tão distintos.)
        Informalmente, dados são "coisas" que queremos manipular, e
        procedimentos são descrições das regras para manipular os dados. Assim,
        qualquer linguagem de programação poderosa deve ser capaz de descrever
        dados primitivos e procedimentos primitivos e deve ter métodos para
        combinar e abstrair procedimentos e dados.
      </p>
      <p>
        Neste capítulo, lidaremos apenas com dados numéricos simples para que
        possamos nos concentrar nas regras para construir procedimentos.<a
          class="footnote_link"
          id="DOCF4"
          href="#FOOT4"
          ><sup>4</sup></a
        >
        Nos capítulos posteriores, veremos que essas mesmas regras nos permitem
        construir procedimentos para manipular dados compostos também.
      </p>

      <a id="g_t1_002e1_002e1"></a>
      <a id="Expressions"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.1</span
        ><span class="sectitle">Expressões</span>
      </h4>

      <p>
        Uma maneira fácil de começar a programar é examinar algumas interações
        típicas com um interpretador para o dialeto Scheme de Lisp. Imagine que
        você está sentado em um terminal de computador. Você digita uma
        <a id="index-expression"></a><em>expressão</em>, e o interpretador
        responde exibindo o resultado da <a id="index-evaluating"></a
        ><em>avaliação</em> dessa expressão.
      </p>
      <p>
        Um tipo de expressão primitiva que você pode digitar é um número. (Mais
        precisamente, a expressão que você digita consiste nos numerais que
        representam o número na base 10.) Se você apresentar ao Lisp um número:
      </p>
      <pre><code class="language-scheme">
486
      </code></pre>

      <p>
        o interpretador responderá imprimindo:<a
          class="footnote_link"
          id="DOCF5"
          href="#FOOT5"
          ><sup>5</sup></a
        >
      </p>
      <pre><code class="language-scheme">
486
      </code></pre>

      <p>
        Expressões que representam números podem ser combinadas com uma
        expressão que representa um procedimento primitivo (como
        <code>+</code> ou <code>*</code>) para formar uma expressão composta que
        representa a aplicação do procedimento a esses números. Por exemplo:
      </p>
      <pre><code class="language-scheme">
(+ 137 349)
486

(- 1000 334)
666

(* 5 99)
495

(/ 10 5)
2

(+ 2.7 10)
12.7        
      </code></pre>

      <p>
        Expressões como essas, formadas delimitando uma lista de expressões
        entre parênteses para denotar a aplicação de um procedimento, são
        chamadas de <a id="index-combinations"></a><em>combinações</em>. O
        elemento mais à esquerda na lista é chamado de
        <a id="index-operator"></a><em>operador</em>, e os outros elementos são
        chamados de <a id="index-operands"></a><em>operandos</em>. O valor de
        uma combinação é obtido aplicando o procedimento especificado pelo
        operador aos <a id="index-arguments"></a><em>argumentos</em> que são os
        valores dos operandos.
      </p>
      <p>
        A convenção de colocar o operador à esquerda dos operandos é conhecida
        como <a id="index-prefix-notation"></a><em>notação prefixa</em>, e pode
        ser um pouco confusa no início porque difere significativamente da
        convenção matemática usual. No entanto, a notação prefixa tem várias
        vantagens. Uma delas é que pode acomodar procedimentos que podem receber
        um número arbitrário de argumentos, como nos exemplos a seguir:
      </p>
      <pre><code class="language-scheme">
(+ 21 35 12 7)
75

(* 25 4 12)
1200
      </code></pre>

      <p>
        Não pode haver ambiguidade, porque o operador é sempre o elemento mais à
        esquerda e toda a combinação é delimitada pelos parênteses.
      </p>
      <p>
        Uma segunda vantagem da notação prefixa é que ela se estende de maneira
        direta para permitir que combinações sejam <i>aninhadas</i>, ou seja,
        que tenham combinações cujos elementos são eles próprios combinações:
      </p>
      <pre><code class="language">
(+ (* 3 5) (- 10 6))
19        
      </code></pre>

      <p>
        Não há limite (em princípio) para a profundidade desse aninhamento e
        para a complexidade geral das expressões que o interpretador Lisp pode
        avaliar. Somos nós, humanos, que nos confundimos com expressões ainda
        relativamente simples, como:
      </p>
      <pre><code class="language-scheme">
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
      </code></pre>

      <p>
        que o interpretador avaliaria prontamente como 57. Podemos nos ajudar
        escrevendo essa expressão na forma:
      </p>
      <pre><code class="language-scheme">
(+ (* 3
(+ (* 2 4)
   (+ 3 5)))
(+ (- 10 7)
6))
      </code></pre>

      <p>
        seguindo uma convenção de formatação conhecida como
        <a id="index-pretty_002dprinting"></a><em>pretty-printing</em>, na qual
        cada combinação longa é escrita de forma que os operandos sejam
        alinhados verticalmente. Os recuos resultantes mostram claramente a
        estrutura da expressão.<a class="footnote_link" id="DOCF6" href="#FOOT6"
          ><sup>6</sup></a
        >
      </p>
      <p>
        Mesmo com expressões complexas, o interpretador sempre opera no mesmo
        ciclo básico: ele lê uma expressão do terminal, avalia a expressão e
        imprime o resultado. Esse modo de operação é frequentemente expresso
        dizendo que o interpretador funciona em um
        <a id="index-read_002deval_002dprint-loop"></a
        ><em>loop de leitura-avaliação-impressão</em>. Observe, em particular,
        que não é necessário instruir explicitamente o interpretador a imprimir
        o valor da expressão.<a class="footnote_link" id="DOCF7" href="#FOOT7"
          ><sup>7</sup></a
        >
      </p>

      <a id="g_t1_002e1_002e2"></a>
      <a id="Naming-and-the-Environment"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.2</span
        ><span class="sectitle">Nomes e o Ambiente</span>
      </h4>

      <p>
        Um aspecto crítico de uma linguagem de programação é o meio que ela
        fornece para usar nomes para se referir a objetos computacionais.
        Dizemos que o nome identifica uma <a id="index-variable"></a
        ><em>variável</em> cujo <a id="index-value"></a><em>valor</em> é o
        objeto.
      </p>
      <p>
        No dialeto Scheme de Lisp, nomeamos coisas com <code>define</code>.
        Digitando:
      </p>
      <pre><code class="language-scheme">
(define size 2)
      </code></pre>

      <p>
        o interpretador associa o valor 2 ao nome <code>size</code>.<a
          class="footnote_link"
          id="DOCF8"
          href="#FOOT8"
          ><sup>8</sup></a
        >
        Uma vez que o nome <code>size</code> foi associado ao número 2, podemos
        nos referir ao valor 2 pelo nome:
      </p>
      <pre><code class="language-scheme">
size
2

(* 5 size)
10
      </code></pre>

      <p>Aqui estão mais exemplos do uso de <code>define</code>:</p>
      <pre><code class="language-scheme">
(define pi 3.14159)
(define radius 10)

(* pi (* radius radius))
314.159

(define circumference (* 2 pi radius))

circumference
62.8318
      </code></pre>

      <p>
        <code>Define</code> é o meio mais simples de abstração em nossa
        linguagem, pois nos permite usar nomes simples para nos referir aos
        resultados de operações compostas, como a
        <code>circumference</code> calculada acima. Em geral, objetos
        computacionais podem ter estruturas muito complexas, e seria
        extremamente inconveniente ter que lembrar e repetir seus detalhes cada
        vez que quisermos usá-los. De fato, programas complexos são construídos
        passo a passo, criando objetos computacionais de complexidade crescente.
        O interpretador torna essa construção passo a passo particularmente
        conveniente, pois as associações nome-objeto podem ser criadas
        incrementalmente em interações sucessivas. Esse recurso incentiva o
        desenvolvimento e teste incremental de programas e é em grande parte
        responsável pelo fato de que um programa Lisp geralmente consiste em um
        grande número de procedimentos relativamente simples.
      </p>
      <p>
        Deve ficar claro que a possibilidade de associar valores a símbolos e
        recuperá-los posteriormente significa que o interpretador deve manter
        algum tipo de memória que acompanhe os pares nome-objeto. Essa memória é
        chamada de <a id="index-environment"></a><em>ambiente</em> (mais
        precisamente, o <a id="index-global-environment"></a
        ><em>ambiente global</em>, pois veremos mais tarde que uma computação
        pode envolver vários ambientes diferentes).<a
          class="footnote_link"
          id="DOCF9"
          href="#FOOT9"
          ><sup>9</sup></a
        >
      </p>

      <a id="g_t1_002e1_002e3"></a>
      <a id="Evaluating-Combinations"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.3</span
        ><span class="sectitle">Avaliando Combinações</span>
      </h4>

      <p>
        Um de nossos objetivos neste capítulo é isolar questões sobre o
        pensamento procedural. Como um exemplo, vamos considerar que, ao avaliar
        combinações, o interpretador está seguindo um procedimento.
      </p>
      <blockquote>
        <p>Para avaliar uma combinação, faça o seguinte:</p>
        <ol>
          <li>Avalie as subexpressões da combinação.</li>
          <li>
            Aplique o procedimento que é o valor da subexpressão mais à esquerda
            (o operador) aos argumentos que são os valores das outras
            subexpressões (os operandos).
          </li>
        </ol>
      </blockquote>

      <p>
        Mesmo essa regra simples ilustra alguns pontos importantes sobre
        processos em geral. Primeiro, observe que o primeiro passo determina
        que, para realizar o processo de avaliação para uma combinação, devemos
        primeiro realizar o processo de avaliação em cada elemento da
        combinação. Assim, a regra de avaliação é <a id="index-recursive"></a
        ><em>recursiva</em> por natureza; ou seja, ela inclui, como um de seus
        passos, a necessidade de invocar a própria regra.<a
          class="footnote_link"
          id="DOCF10"
          href="#FOOT10"
          ><sup>10</sup></a
        >
      </p>
      <p>
        Observe como a ideia de recursão pode ser usada de forma sucinta para
        expressar o que, no caso de uma combinação profundamente aninhada, seria
        visto como um processo bastante complicado. Por exemplo, avaliar:
      </p>
      <pre><code class="language-scheme">
(* (+ 2 (* 4 6)) (+ 3 5 7))
      </code></pre>

      <p>
        exige que a regra de avaliação seja aplicada a quatro combinações
        diferentes. Podemos obter uma imagem desse processo representando a
        combinação na forma de uma árvore, como mostrado na
        <a href="#Figure-1_002e1">Figura 1.1</a>. Cada combinação é representada
        por um nó com ramos correspondentes ao operador e aos operandos da
        combinação saindo dele. Os nós terminais (ou seja, nós sem ramos saindo
        deles) representam operadores ou números. Visualizando a avaliação em
        termos da árvore, podemos imaginar que os valores dos operandos percolam
        para cima, começando nos nós terminais e depois se combinando em níveis
        cada vez mais altos. Em geral, veremos que a recursão é uma técnica
        muito poderosa para lidar com objetos hierárquicos, semelhantes a
        árvores. De fato, a forma "percolar valores para cima" da regra de
        avaliação é um exemplo de um tipo geral de processo conhecido como
        <a id="index-tree-accumulation"></a><em>acumulação em árvore</em>.
      </p>
      <figure class="float">
        <a id="Figure-1_002e1"></a>
        <object
          style="width: 20.38ex; height: 20.46ex"
          data="fig/chap1/Fig1.1g.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 1.1:</strong> Representação em árvore, mostrando o
            valor de cada subcombinação.
          </p>
        </figcaption>
      </figure>

      <p>
        Em seguida, observe que a aplicação repetida do primeiro passo nos leva
        ao ponto onde precisamos avaliar, não combinações, mas expressões
        primitivas, como numerais, operadores embutidos ou outros nomes.
        Cuidamos dos casos primitivos estipulando que:
      </p>
      <ul>
        <li>os valores dos numerais são os números que eles nomeiam,</li>
        <li>
          os valores dos operadores embutidos são as sequências de instruções da
          máquina que realizam as operações correspondentes, e
        </li>
        <li>
          os valores de outros nomes são os objetos associados a esses nomes no
          ambiente.
        </li>
      </ul>

      <p>
        Podemos considerar a segunda regra como um caso especial da terceira,
        estipulando que símbolos como <code>+</code> e <code>*</code> também
        estão incluídos no ambiente global e são associados às sequências de
        instruções da máquina que são seus "valores". O ponto chave a ser
        observado é o papel do ambiente na determinação do significado dos
        símbolos nas expressões. Em uma linguagem interativa como Lisp, não faz
        sentido falar do valor de uma expressão como <code>(+ x 1)</code> sem
        especificar qualquer informação sobre o ambiente que forneceria um
        significado para o símbolo <code>x</code> (ou mesmo para o símbolo
        <code>+</code>). Como veremos no
        <a href="Chapter-3.html#Chapter-3">Capítulo 3</a>, a noção geral do
        ambiente como fornecedor de um contexto no qual a avaliação ocorre
        desempenhará um papel importante em nossa compreensão da execução de
        programas.
      </p>
      <p>
        Observe que a regra de avaliação dada acima não lida com definições. Por
        exemplo, avaliar <code>(define x 3)</code> não aplica
        <code>define</code> a dois argumentos, um dos quais é o valor do símbolo
        <code>x</code> e o outro é 3, pois o propósito do <code>define</code> é
        precisamente associar <code>x</code> a um valor. (Ou seja,
        <code>(define x 3)</code> não é uma combinação.)
      </p>
      <p>
        Tais exceções à regra geral de avaliação são chamadas de
        <a id="index-special-forms"></a><em>formas especiais</em>.
        <code>Define</code> é o único exemplo de forma especial que vimos até
        agora, mas encontraremos outras em breve. Cada forma especial tem sua
        própria regra de avaliação. Os vários tipos de expressões (cada um com
        sua regra de avaliação associada) constituem a sintaxe da linguagem de
        programação. Em comparação com a maioria das outras linguagens de
        programação, Lisp tem uma sintaxe muito simples; ou seja, a regra de
        avaliação para expressões pode ser descrita por uma regra geral simples,
        juntamente com regras especializadas para um pequeno número de formas
        especiais.<a class="footnote_link" id="DOCF11" href="#FOOT11"
          ><sup>11</sup></a
        >
      </p>

      <a id="g_t1_002e1_002e4"></a>
      <a id="Compound-Procedures"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.4</span
        ><span class="sectitle">Procedimentos Compostos</span>
      </h4>

      <p>
        Identificamos em Lisp alguns dos elementos que devem aparecer em
        qualquer linguagem de programação poderosa:
      </p>
      <ul>
        <li>
          Números e operações aritméticas são dados e procedimentos primitivos.
        </li>
        <li>
          O aninhamento de combinações fornece um meio de combinar operações.
        </li>
        <li>
          Definições que associam nomes a valores fornecem um meio limitado de
          abstração.
        </li>
      </ul>

      <p>
        Agora aprenderemos sobre <a id="index-procedure-definitions"></a
        ><em>definições de procedimentos</em>, uma técnica de abstração muito
        mais poderosa pela qual uma operação composta pode receber um nome e ser
        referida como uma unidade.
      </p>
      <p>
        Começamos examinando como expressar a ideia de "quadrado". Poderíamos
        dizer: "Para elevar algo ao quadrado, multiplique-o por si mesmo." Isso
        é expresso em nossa linguagem como:
      </p>
      <pre><code class="language-scheme">
(define (square x) (* x x))
      </code></pre>
      <p>Podemos entender isso da seguinte maneira:</p>
      <pre><code class="language-scheme">
(define  (square          x)    (*         x      x))
  |        |              |      |         |      |
 Para ao quadrado elevar algo, multiplique-o por si mesmo.
      </code></pre>

      <p>
        Temos aqui um <a id="index-compound-procedure"></a
        ><em>procedimento composto</em>, que recebeu o nome <code>square</code>.
        O procedimento representa a operação de multiplicar algo por si mesmo. A
        coisa a ser multiplicada recebe um nome local, <code>x</code>, que
        desempenha o mesmo papel que um pronome desempenha na linguagem natural.
        Avaliar a definição cria esse procedimento composto e o associa ao nome
        <code>square</code>.<a class="footnote_link" id="DOCF12" href="#FOOT12"
          ><sup>12</sup></a
        >
      </p>
      <p>A forma geral de uma definição de procedimento é:</p>
      <pre><code class="lenguage-scheme">
(define (⟨name⟩ ⟨formal parameters⟩) ⟨body⟩)
      </code></pre>

      <p>
        O <code>⟨</code><var>name</var><code>⟩</code> é um símbolo a ser
        associado à definição do procedimento no ambiente.<a
          class="footnote_link"
          id="DOCF13"
          href="#FOOT13"
          ><sup>13</sup></a
        >
        Os <code>⟨</code><var>formal parameters</var><code>⟩</code> são os nomes
        usados dentro do corpo do procedimento para se referir aos argumentos
        correspondentes do procedimento. O <code>⟨</code><var>body</var
        ><code>⟩</code> é uma expressão que produzirá o valor da aplicação do
        procedimento quando os parâmetros formais forem substituídos pelos
        argumentos reais aos quais o procedimento é aplicado.<a
          class="footnote_link"
          id="DOCF14"
          href="#FOOT14"
          ><sup>14</sup></a
        >
        O <code>⟨</code><var>name</var><code>⟩</code> e os <code>⟨</code
        ><var>formal parameters</var><code>⟩</code> são agrupados entre
        parênteses, assim como seriam em uma chamada real ao procedimento que
        está sendo definido.
      </p>
      <p>Após definir <code>square</code>, podemos agora usá-lo:</p>
      <pre><code class="language-scheme">
(square 21)
441

(square (+ 2 5))
49

(square (square 3))
81
      </code></pre>

      <p>
        Também podemos usar <code>square</code> como um bloco de construção na
        definição de outros procedimentos. Por exemplo,
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>x</mi>
            <mn>2</mn>
          </msup>
          <mo>+</mo>
          <msup>
            <mi>y</mi>
            <mn>2</mn>
          </msup>
        </math>
        pode ser expresso como:
      </p>
      <pre><code class="language-scheme">
(+ (square x) (square y))
      </code></pre>

      <p>
        Podemos facilmente definir um procedimento
        <code>sum-of-squares</code> que, dados quaisquer dois números como
        argumentos, produz a soma de seus quadrados:
      </p>
      <pre><code class="language-scheme">
(define (sum-of-squares x y)
(+ (square x) (square y)))

(sum-of-squares 3 4)
25
      </code></pre>

      <p>
        Agora podemos usar <code>sum-of-squares</code> como um bloco de
        construção na construção de outros procedimentos:
      </p>
      <pre><code class="language-scheme">
(define (f a)
(sum-of-squares (+ a 1) (* a 2)))

(f 5)
136
      </code></pre>

      <p>
        Procedimentos compostos são usados exatamente da mesma maneira que
        procedimentos primitivos. De fato, não se pode dizer, olhando para a
        definição de <code>sum-of-squares</code> dada acima, se
        <code>square</code> foi embutido no interpretador, como <code>+</code> e
        <code>*</code>, ou definido como um procedimento composto.
      </p>

      <a id="g_t1_002e1_002e5"></a>
      <a id="The-Substitution-Model-for-Procedure-Application"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.5</span
        ><span class="sectitle"
          >O Modelo de Substituição para Aplicação de Procedimentos</span
        >
      </h4>

      <p>
        Para avaliar uma combinação cujo operador nomeia um procedimento
        composto, o interpretador segue um processo muito semelhante ao das
        combinações cujos operadores nomeiam procedimentos primitivos, que
        descrevemos em <a href="#g_t1_002e1_002e3">1.1.3</a>. Ou seja, o
        interpretador avalia os elementos da combinação e aplica o procedimento
        (que é o valor do operador da combinação) aos argumentos (que são os
        valores dos operandos da combinação).
      </p>
      <p>
        Podemos assumir que o mecanismo para aplicar procedimentos primitivos a
        argumentos é embutido no interpretador. Para procedimentos compostos, o
        processo de aplicação é o seguinte:
      </p>
      <blockquote>
        <p>
          Para aplicar um procedimento composto a argumentos, avalie o corpo do
          procedimento com cada parâmetro formal substituído pelo argumento
          correspondente.
        </p>
      </blockquote>

      <p>Para ilustrar esse processo, vamos avaliar a combinação:</p>
      <pre><code class="language-scheme">
(f 5)
      </code></pre>

      <p>
        onde <code>f</code> é o procedimento definido em
        <a href="#g_t1_002e1_002e4">1.1.4</a>. Começamos recuperando o corpo de
        <code>f</code>:
      </p>
      <pre><code class="language-scheme">
(sum-of-squares (+ a 1) (* a 2))
      </code></pre>

      <p>
        Então substituímos o parâmetro formal <code>a</code> pelo argumento 5:
      </p>
      <pre><code class="language-scheme">
(sum-of-squares (+ 5 1) (* 5 2))
      </code></pre>

      <p>
        Assim, o problema se reduz à avaliação de uma combinação com dois
        operandos e um operador <code>sum-of-squares</code>. Avaliar essa
        combinação envolve três subproblemas. Devemos avaliar o operador para
        obter o procedimento a ser aplicado e avaliar os operandos para obter os
        argumentos. Agora <code>(+ 5 1)</code> produz 6 e
        <code>(* 5 2)</code> produz 10, então devemos aplicar o procedimento
        <code>sum-of-squares</code> a 6 e 10. Esses valores são substituídos
        pelos parâmetros formais <code>x</code> e <code>y</code> no corpo de
        <code>sum-of-squares</code>, reduzindo a expressão a:
      </p>
      <pre><code class="language-scheme">
(+ (square 6) (square 10))
      </code></pre>

      <p>Se usarmos a definição de <code>square</code>, isso se reduz a:</p>
      <pre><code class="language-scheme">
(+ (* 6 6) (* 10 10))
      </code></pre>

      <p>que se reduz por multiplicação a:</p>
      <pre><code class="language-scheme">
(+ 36 100)
      </code></pre>

      <p>e finalmente a:</p>
      <pre><code class="language-scheme">
136
      </code></pre>

      <p>
        O processo que acabamos de descrever é chamado de
        <a id="index-substitution-model"></a
        ><em>modelo de substituição</em> para aplicação de procedimentos. Ele
        pode ser tomado como um modelo que determina o "significado" da
        aplicação de procedimentos, na medida em que os procedimentos neste
        capítulo estão em questão. No entanto, há dois pontos que devem ser
        enfatizados:
      </p>
      <ul>
        <li>
          O propósito da substituição é nos ajudar a pensar sobre a aplicação de
          procedimentos, não para fornecer uma descrição de como o interpretador
          realmente funciona. Interpretadores típicos não avaliam aplicações de
          procedimentos manipulando o texto de um procedimento para substituir
          valores pelos parâmetros formais. Na prática, a "substituição" é
          realizada usando um ambiente local para os parâmetros formais.
          Discutiremos isso mais detalhadamente no
          <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> e
          <a href="Chapter-4.html#Chapter-4">Capítulo 4</a> quando examinarmos a
          implementação de um interpretador em detalhes.
        </li>
        <li>
          Ao longo deste livro, apresentaremos uma sequência de modelos cada vez
          mais elaborados de como os interpretadores funcionam, culminando com
          uma implementação completa de um interpretador e compilador no
          <a href="Chapter-5.html#Chapter-5">Capítulo 5</a>. O modelo de
          substituição é apenas o primeiro desses modelos—uma maneira de começar
          a pensar formalmente sobre o processo de avaliação. Em geral, ao
          modelar fenômenos em ciência e engenharia, começamos com modelos
          simplificados e incompletos. À medida que examinamos as coisas em
          maior detalhe, esses modelos simples se tornam inadequados e devem ser
          substituídos por modelos mais refinados. O modelo de substituição não
          é exceção. Em particular, quando abordarmos no
          <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> o uso de
          procedimentos com "dados mutáveis", veremos que o modelo de
          substituição se quebra e deve ser substituído por um modelo mais
          complicado de aplicação de procedimentos.<a
            class="footnote_link"
            id="DOCF15"
            href="#FOOT15"
            ><sup>15</sup></a
          >
        </li>
      </ul>

      <a id="Applicative-order-versus-normal-order"></a>
      <h5 class="subsubheading">Ordem aplicativa versus ordem normal</h5>

      <p>
        De acordo com a descrição da avaliação dada em
        <a href="#g_t1_002e1_002e3">1.1.3</a>, o interpretador primeiro avalia o
        operador e os operandos e então aplica o procedimento resultante aos
        argumentos resultantes. Essa não é a única maneira de realizar a
        avaliação. Um modelo alternativo de avaliação não avaliaria os operandos
        até que seus valores fossem necessários. Em vez disso, ele primeiro
        substituiria as expressões dos operandos pelos parâmetros até obter uma
        expressão envolvendo apenas operadores primitivos e então realizaria a
        avaliação. Se usássemos esse método, a avaliação de
        <code>(f 5)</code> procederia de acordo com a sequência de expansões:
      </p>
      <pre><code class="language-scheme">
(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) 
   (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) 
   (* (* 5 2) (* 5 2)))
      </code></pre>

      <p>seguido pelas reduções:</p>
      <pre><code class="language-scheme">
(+ (* 6 6) 
(* 10 10))

(+ 36 100)

136
      </code></pre>

      <p>
        Isso dá a mesma resposta que nosso modelo anterior de avaliação, mas o
        processo é diferente. Em particular, as avaliações de
        <code>(+ 5 1)</code> e <code>(* 5 2)</code> são realizadas duas vezes
        aqui, correspondendo à redução da expressão <code>(* x x)</code> com
        <code>x</code> substituído respectivamente por <code>(+ 5 1)</code> e
        <code>(* 5 2)</code>.
      </p>
      <p>
        Esse método alternativo de avaliação "expandir completamente e depois
        reduzir" é conhecido como <a id="index-normal_002dorder-evaluation"></a
        ><em>avaliação em ordem normal</em>, em contraste com o método "avaliar
        os argumentos e depois aplicar" que o interpretador realmente usa, que é
        chamado de <a id="index-applicative_002dorder-evaluation"></a
        ><em>avaliação em ordem aplicativa</em>. Pode-se mostrar que, para
        aplicações de procedimentos que podem ser modeladas usando substituição
        (incluindo todos os procedimentos nos dois primeiros capítulos deste
        livro) e que produzem valores legítimos, a avaliação em ordem normal e
        em ordem aplicativa produzem o mesmo valor. (Veja
        <a href="#Exercise-1_002e5">Exercício 1.5</a> para um exemplo de um
        valor "ilegítimo" onde a avaliação em ordem normal e em ordem aplicativa
        não dão o mesmo resultado.)
      </p>
      <p>
        Lisp usa avaliação em ordem aplicativa, em parte devido à eficiência
        adicional obtida ao evitar múltiplas avaliações de expressões como as
        ilustradas com <code>(+ 5 1)</code> e <code>(* 5 2)</code> acima e, mais
        significativamente, porque a avaliação em ordem normal se torna muito
        mais complicada de lidar quando saímos do domínio dos procedimentos que
        podem ser modelados por substituição. Por outro lado, a avaliação em
        ordem normal pode ser uma ferramenta extremamente valiosa, e
        investigaremos algumas de suas implicações no
        <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> e
        <a href="Chapter-4.html#Chapter-4">Capítulo 4</a>.<a
          class="footnote_link"
          id="DOCF16"
          href="#FOOT16"
          ><sup>16</sup></a
        >
      </p>

      <a id="g_t1_002e1_002e6"></a>
      <a id="Conditional-Expressions-and-Predicates"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.6</span
        ><span class="sectitle">Expressões Condicionais e Predicados</span>
      </h4>

      <p>
        O poder expressivo da classe de procedimentos que podemos definir neste
        ponto é muito limitado, porque não temos como fazer testes e realizar
        operações diferentes dependendo do resultado de um teste. Por exemplo,
        não podemos definir um procedimento que calcule o valor absoluto de um
        número testando se o número é positivo, negativo ou zero e tomando ações
        diferentes nos diferentes casos de acordo com a regra:
      </p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mrow>
          <mo>|</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
          </mrow>
          <mo>|</mo>
        </mrow>
        <mspace width="thickmathspace" />
        <mo>=</mo>
        <mspace width="thickmathspace" />
        <mrow>
          <mo>{</mo>
          <mtable
            columnalign="right left left"
            rowspacing="4pt"
            columnspacing="1em"
          >
            <mtr>
              <mtd>
                <mi>x</mi>
              </mtd>
              <mtd>
                <mspace width="thickmathspace" />
                <mtext>se</mtext>
              </mtd>
              <mtd>
                <mi>x</mi>
                <mo>&gt;</mo>
                <mn>0</mn>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mspace width="thickmathspace" />
                <mtext>se</mtext>
              </mtd>
              <mtd>
                <mi>x</mi>
                <mo>=</mo>
                <mn>0</mn>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mo>−</mo>
                <mi>x</mi>
              </mtd>
              <mtd>
                <mspace width="thickmathspace" />
                <mtext>se</mtext>
              </mtd>
              <mtd>
                <mi>x</mi>
                <mo>&lt;</mo>
                <mn>0.</mn>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
      </math>

      <p>
        Esse constructo é chamado de <a id="index-case-analysis"></a
        ><em>análise de casos</em>, e há uma forma especial em Lisp para notar
        tal análise de casos. Ela é chamada de <code>cond</code> (que significa
        "condicional") e é usada da seguinte forma:
      </p>
      <pre><code class="language-scheme">
(define (abs x)
(cond ((> x 0) x)
      ((= x 0) 0)
      ((< x 0) (- x))))
      </code></pre>

      <p>A forma geral de uma expressão condicional é:</p>
      <pre><code class="language-scheme">
(cond (⟨p₁⟩ ⟨e₁⟩)
      (⟨p₂⟩ ⟨e₂⟩)
      …
      (⟨pₙ⟩ ⟨eₙ⟩))  
      </code></pre>

      <p>
        consistindo do símbolo <code>cond</code> seguido por pares de expressões
        entre parênteses:
      </p>
      <pre><code class="language-scheme">
(⟨p⟩ ⟨e⟩)
      </code></pre>

      <p>
        chamados de <a id="index-clauses"></a><em>cláusulas</em>. A primeira
        expressão em cada par é um <a id="index-predicate"></a
        ><em>predicado</em>—ou seja, uma expressão cujo valor é interpretado
        como verdadeiro ou falso.<a
          class="footnote_link"
          id="DOCF17"
          href="#FOOT17"
          ><sup>17</sup></a
        >
      </p>
      <p>
        Expressões condicionais são avaliadas da seguinte forma. O predicado
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <msub>
              <mi>p</mi>
              <mn>1</mn>
            </msub>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        é avaliado primeiro. Se seu valor for falso, então
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <msub>
              <mi>p</mi>
              <mn>2</mn>
            </msub>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        é avaliado. Se o valor de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <msub>
              <mi>p</mi>
              <mn>2</mn>
            </msub>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        também for falso, então
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <msub>
              <mi>p</mi>
              <mn>3</mn>
            </msub>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        é avaliado. Esse processo continua até que um predicado seja encontrado
        cujo valor seja verdadeiro, caso em que o interpretador retorna o valor
        da expressão <a id="index-consequent-expression"></a
        ><em>consequente</em> correspondente
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <mi>e</mi>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        da cláusula como o valor da expressão condicional. Se nenhum dos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <mi>p</mi>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        for encontrado como verdadeiro, o valor do <code>cond</code> é
        indefinido.
      </p>
      <p>
        A palavra <a id="index-predicate-1"></a><em>predicado</em> é usada para
        procedimentos que retornam verdadeiro ou falso, bem como para expressões
        que avaliam para verdadeiro ou falso. O procedimento de valor absoluto
        <code>abs</code> faz uso dos predicados primitivos <code>&gt;</code>,
        <code>&lt;</code> e <code>=</code>.<a
          class="footnote_link"
          id="DOCF18"
          href="#FOOT18"
          ><sup>18</sup></a
        >
        Eles recebem dois números como argumentos e testam se o primeiro número
        é, respectivamente, maior que, menor que ou igual ao segundo número,
        retornando verdadeiro ou falso de acordo.
      </p>
      <p>Outra maneira de escrever o procedimento de valor absoluto é:</p>
      <pre><code class="language-scheme">
(define (abs x)
(cond ((&lt; x 0) (- x))
      (else x)))
      </code></pre>

      <p>
        que poderia ser expresso em português como "Se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        for menor que zero, retorne
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo>−</mo>
            <mi>x</mi>
          </mrow> </math
        >; caso contrário, retorne
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>."
        <code>Else</code> é um símbolo especial que pode ser usado no lugar do
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <mi>p</mi>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        na cláusula final de um <code>cond</code>. Isso faz com que o
        <code>cond</code> retorne como seu valor o valor da expressão
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <mi>e</mi>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        correspondente sempre que todas as cláusulas anteriores tiverem sido
        ignoradas. Na verdade, qualquer expressão que sempre avalie para um
        valor verdadeiro poderia ser usada como o
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">⟨</mo>
            <mi>p</mi>
            <mo stretchy="false">⟩</mo>
          </mrow>
        </math>
        aqui.
      </p>
      <p>
        Aqui está mais uma maneira de escrever o procedimento de valor absoluto:
      </p>
      <pre><code class="language-scheme">
(define (abs x)
(if (&lt; x 0)
    (- x)
    x))
      </code></pre>

      <p>
        Isso usa a forma especial <code>if</code>, um tipo restrito de
        condicional que pode ser usado quando há exatamente dois casos na
        análise de casos. A forma geral de uma expressão <code>if</code> é:
      </p>
      <pre><code class="language-scheme">
(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩) 
      </code></pre>

      <p>
        Para avaliar uma expressão <code>if</code>, o interpretador começa
        avaliando a parte <code>⟨</code><var>predicate</var><code>⟩</code> da
        expressão. Se o <code>⟨</code><var>predicate</var><code>⟩</code> avaliar
        para um valor verdadeiro, o interpretador então avalia o <code>⟨</code
        ><var>consequent</var><code>⟩</code> e retorna seu valor. Caso
        contrário, ele avalia o <code>⟨</code><var>alternative</var
        ><code>⟩</code> e retorna seu valor.<a
          class="footnote_link"
          id="DOCF19"
          href="#FOOT19"
          ><sup>19</sup></a
        >
      </p>
      <p>
        Além dos predicados primitivos como <code>&lt;</code>, <code>=</code> e
        <code>&gt;</code>, existem operações de composição lógica, que nos
        permitem construir predicados compostos. As três mais frequentemente
        usadas são:
      </p>
      <ul>
        <li>
          <code
            >(and ⟨<var>e₁</var>⟩
            <span class="roman">…</span> ⟨<var>eₙ</var>⟩)</code
          >
          <p>
            O interpretador avalia as expressões <code>⟨</code><var>e</var
            ><code>⟩</code> uma a uma, em ordem da esquerda para a direita. Se
            qualquer <code>⟨</code><var>e</var><code>⟩</code> avaliar para
            falso, o valor da expressão <code>and</code> é falso, e o restante
            das <code>⟨</code><var>e</var><code>⟩</code> não é avaliado. Se
            todas as <code>⟨</code><var>e</var><code>⟩</code> avaliarem para
            valores verdadeiros, o valor da expressão <code>and</code> é o valor
            da última.
          </p>
        </li>
        <li>
          <code
            >(or ⟨<var>e₁</var>⟩
            <span class="roman">…</span> ⟨<var>eₙ</var>⟩)</code
          >
          <p>
            O interpretador avalia as expressões <code>⟨</code><var>e</var
            ><code>⟩</code> uma a uma, em ordem da esquerda para a direita. Se
            qualquer <code>⟨</code><var>e</var><code>⟩</code> avaliar para um
            valor verdadeiro, esse valor é retornado como o valor da expressão
            <code>or</code>, e o restante das <code>⟨</code><var>e</var
            ><code>⟩</code> não é avaliado. Se todas as <code>⟨</code
            ><var>e</var><code>⟩</code> avaliarem para falso, o valor da
            expressão <code>or</code> é falso.
          </p>
        </li>
        <li>
          <code>(not ⟨<var>e</var>⟩)</code>
          <p>
            O valor de uma expressão <code>not</code> é verdadeiro quando a
            expressão <code>⟨</code><var>e</var><code>⟩</code> avalia para
            falso, e falso caso contrário.
          </p>
        </li>
      </ul>

      <p>
        Observe que <code>and</code> e <code>or</code> são formas especiais, não
        procedimentos, porque as subexpressões não são necessariamente todas
        avaliadas. <code>Not</code> é um procedimento ordinário.
      </p>
      <p>
        Como exemplo de como esses são usados, a condição de que um número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        esteja no intervalo
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mn>5</mn>
          <mo>&lt;</mo>
          <mi>x</mi>
          <mo>&lt;</mo>
          <mn>10</mn>
        </math>
        pode ser expressa como:
      </p>
      <pre><code class="language-scheme">
(and (> x 5) (< x 10))
      </code></pre>

      <p>
        Como outro exemplo, podemos definir um predicado para testar se um
        número é maior ou igual a outro como:
      </p>
      <pre><code class="language-scheme">
(define (>= x y) 
(or (> x y) (= x y)))
      </code></pre>

      <p>ou alternativamente como:</p>
      <pre><code class="language-scheme">
(define (>= x y) 
(not (< x y)))
      </code></pre>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e1"></a>Exercício 1.1:</strong> Abaixo
          está uma sequência de expressões. Qual é o resultado impresso pelo
          interpretador em resposta a cada expressão? Suponha que a sequência
          seja avaliada na ordem em que é apresentada.
        </p>
        <pre><code class="language-scheme">
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (> b a) b a))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
        </code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e2"></a>Exercício 1.2:</strong> Traduza a
          seguinte expressão para a forma prefixa:
        </p>
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mrow>
                <mn>5</mn>
                <mo>+</mo>
                <mn>4</mn>
                <mo>+</mo>
                <mo stretchy="false">(</mo>
                <mn>2</mn>
                <mo>−</mo>
                <mo stretchy="false">(</mo>
                <mn>3</mn>
                <mo>−</mo>
                <mo stretchy="false">(</mo>
                <mn>6</mn>
                <mo>+</mo>
                <mfrac>
                  <mn>4</mn>
                  <mn>5</mn>
                </mfrac>
                <mo stretchy="false">)</mo>
                <mo stretchy="false">)</mo>
                <mo stretchy="false">)</mo>
              </mrow>
              <mrow>
                <mn>3</mn>
                <mo stretchy="false">(</mo>
                <mn>6</mn>
                <mo>−</mo>
                <mn>2</mn>
                <mo stretchy="false">)</mo>
                <mo stretchy="false">(</mo>
                <mn>2</mn>
                <mo>−</mo>
                <mn>7</mn>
                <mo stretchy="false">)</mo>
              </mrow>
            </mfrac>
            <mo>.</mo>
          </mrow>
        </math>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e3"></a>Exercício 1.3:</strong> Defina um
          procedimento que receba três números como argumentos e retorne a soma
          dos quadrados dos dois maiores números.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e4"></a>Exercício 1.4:</strong> Observe
          que nosso modelo de avaliação permite combinações cujos operadores são
          expressões compostas. Use essa observação para descrever o
          comportamento do seguinte procedimento:
        </p>
        <pre><code class="language-scheme">
(define (a-plus-abs-b a b)
((if (> b 0) + -) a b))
        </code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e5"></a>Exercício 1.5:</strong> Ben
          Bitdiddle inventou um teste para determinar se o interpretador que ele
          enfrenta está usando avaliação em ordem aplicativa ou em ordem normal.
          Ele define os seguintes dois procedimentos:
        </p>
        <pre><code class="language-scheme">
(define (p) (p))

(define (test x y) 
  (if (= x 0) 
      0 
      y))
        </code></pre>

        <p>Então ele avalia a expressão:</p>
        <pre><code class="language-scheme">
(test 0 (p))
        </code></pre>

        <p>
          Que comportamento Ben observará com um interpretador que usa avaliação
          em ordem aplicativa? Que comportamento ele observará com um
          interpretador que usa avaliação em ordem normal? Explique sua
          resposta. (Suponha que a regra de avaliação para a forma especial
          <code>if</code> seja a mesma, independentemente de o interpretador
          estar usando ordem normal ou aplicativa: A expressão predicada é
          avaliada primeiro, e o resultado determina se a expressão consequente
          ou alternativa será avaliada.)
        </p>
      </blockquote>

      <a id="Sec_002e1_002e1_002e7"></a><a id="g_t1_002e1_002e7"></a>
      <a id="Example_003a-Square-Roots-by-Newton_0027s-Method"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.7</span
        ><span class="sectitle"
          >Exemplo: Raízes Quadradas pelo Método de Newton</span
        >
      </h4>

      <p>
        Procedimentos, como introduzidos acima, são muito semelhantes a funções
        matemáticas comuns. Eles especificam um valor que é determinado por um
        ou mais parâmetros. Mas há uma diferença importante entre funções
        matemáticas e procedimentos de computador. Procedimentos devem ser
        eficazes.
      </p>
      <p>
        Como um exemplo, considere o problema de calcular raízes quadradas.
        Podemos definir a função raiz quadrada como:
      </p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <msqrt>
          <mi>x</mi>
        </msqrt>
        <mspace width="thickmathspace" />
        <mspace width="thickmathspace" />
        <mo>=</mo>
        <mspace width="thickmathspace" />
        <mspace width="thickmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mtext>o</mtext>
          <mspace width="thickmathspace" />
          <mspace width="thickmathspace" />
          <mi>y</mi>
        </mrow>
        <mspace width="thickmathspace" />
        <mspace width="thickmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mtext>tal que</mtext>
        </mrow>
        <mspace width="thickmathspace" />
        <mspace width="thickmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mi>y</mi>
          <mo>≥</mo>
          <mn>0</mn>
        </mrow>
        <mspace width="thickmathspace" />
        <mspace width="thickmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mtext>e</mtext>
          <mspace width="thickmathspace" />
          <mspace width="thickmathspace" />
          <msup>
            <mi>y</mi>
            <mn>2</mn>
          </msup>
          <mo>=</mo>
          <mi>x</mi>
          <mo>.</mo>
        </mrow>
      </math>

      <p>
        Isso descreve uma função matemática perfeitamente legítima. Poderíamos
        usá-la para reconhecer se um número é a raiz quadrada de outro ou para
        derivar fatos sobre raízes quadradas em geral. Por outro lado, a
        definição não descreve um procedimento. De fato, ela quase não nos diz
        nada sobre como realmente encontrar a raiz quadrada de um número dado.
        Não ajudará reformular essa definição em pseudo-Lisp:
      </p>
      <pre><code class="language-scheme">
(define (sqrt x)
(the y (and (>= y 0) 
            (= (square y) x))))
      </code></pre>

      <p>Isso apenas levanta a questão.</p>
      <p>
        O contraste entre função e procedimento é um reflexo da distinção geral
        entre descrever propriedades das coisas e descrever como fazer coisas,
        ou, como às vezes é referido, a distinção entre conhecimento declarativo
        e conhecimento imperativo. Em matemática, geralmente estamos preocupados
        com descrições declarativas (o que é), enquanto em ciência da computação
        geralmente estamos preocupados com descrições imperativas (como
        fazer).<a class="footnote_link" id="DOCF20" href="#FOOT20"
          ><sup>20</sup></a
        >
      </p>
      <p>
        Como se calcula raízes quadradas? A maneira mais comum é usar o método
        de Newton de aproximações sucessivas, que diz que sempre que temos um
        palpite
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        para o valor da raiz quadrada de um número
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>,
        podemos realizar uma manipulação simples para obter um palpite melhor
        (mais próximo da raiz quadrada real) calculando a média de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        com
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >.<a class="footnote_link" id="DOCF21" href="#FOOT21"><sup>21</sup></a>
        Por exemplo, podemos calcular a raiz quadrada de 2 da seguinte forma.
        Suponha que nosso palpite inicial seja 1:
      </p>
      <div class="example">
        <pre class="example">
Palpite     Quociente      Média

1         (2/1)  = 2    ((2 + 1)/2)  = 1.5

1.5       (2/1.5)       ((1.3333 + 1.5)/2)
            = 1.3333      = 1.4167

1.4167    (2/1.4167)    ((1.4167 + 1.4118)/2) 
            = 1.4118      = 1.4142  

1.4142    ...           ...
</pre
        >
      </div>

      <p>
        Continuando esse processo, obtemos aproximações cada vez melhores para a
        raiz quadrada.
      </p>
      <p>
        Agora vamos formalizar o processo em termos de procedimentos. Começamos
        com um valor para o radicando (o número cuja raiz quadrada estamos
        tentando calcular) e um valor para o palpite. Se o palpite for bom o
        suficiente para nossos propósitos, terminamos; caso contrário, devemos
        repetir o processo com um palpite melhorado. Escrevemos essa estratégia
        básica como um procedimento:
      </p>
      <pre><code class="language-scheme">
(define (sqrt-iter guess x)
(if (good-enough? guess x)
    guess
    (sqrt-iter (improve guess x) x)))
      </code></pre>

      <p>
        Um palpite é melhorado calculando a média dele com o quociente do
        radicando e o palpite antigo:
      </p>
      <pre><code class="language-scheme">
(define (improve guess x)
  (average guess (/ x guess)))
      </code></pre>

      <p>onde:</p>
      <pre><code class="language-scheme">
(define (average x y) 
(/ (+ x y) 2))
      </code></pre>

      <p>
        Também temos que dizer o que queremos dizer com "bom o suficiente". O
        seguinte servirá para ilustração, mas não é realmente um teste muito
        bom. (Veja <a href="#Exercise-1_002e7">Exercício 1.7</a>.) A ideia é
        melhorar a resposta até que ela esteja próxima o suficiente para que seu
        quadrado difira do radicando por menos de uma tolerância predeterminada
        (aqui 0.001):<a class="footnote_link" id="DOCF22" href="#FOOT22"
          ><sup>22</sup></a
        >
      </p>
      <pre><code class="language-scheme">
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
      </code></pre>

      <p>
        Finalmente, precisamos de uma maneira de começar. Por exemplo, podemos
        sempre adivinhar que a raiz quadrada de qualquer número é 1:<a
          class="footnote_link"
          id="DOCF23"
          href="#FOOT23"
          ><sup>23</sup></a
        >
      </p>
      <pre><code class="language-scheme">
(define (sqrt x)
  (sqrt-iter 1.0 x))
      </code></pre>

      <p>
        Se digitarmos essas definições para o interpretador, podemos usar
        <code>sqrt</code> como qualquer outro procedimento:
      </p>
      <pre><code class="language-scheme">
(sqrt 9)
3.00009155413138

(sqrt (+ 100 37))
        11.704699917758145

(sqrt (+ (sqrt 2) (sqrt 3)))
1.7739279023207892

(square (sqrt 1000))
1000.000369924366
      </code></pre>

      <p>
        O programa <code>sqrt</code> também ilustra que a linguagem procedural
        simples que introduzimos até agora é suficiente para escrever qualquer
        programa puramente numérico que se poderia escrever em, por exemplo, C
        ou Pascal. Isso pode parecer surpreendente, já que não incluímos em
        nossa linguagem nenhum constructo iterativo (de loop) que direcione o
        computador a fazer algo repetidamente. <code>Sqrt-iter</code>, por outro
        lado, demonstra como a iteração pode ser realizada sem nenhum constructo
        especial, além da capacidade comum de chamar um procedimento.<a
          class="footnote_link"
          id="DOCF24"
          href="#FOOT24"
          ><sup>24</sup></a
        >
      </p>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e6"></a>Exercício 1.6:</strong> Alyssa P.
          Hacker não entende por que <code>if</code> precisa ser fornecido como
          uma forma especial. “Por que não posso simplesmente defini-lo como um
          procedimento ordinário em termos de <code>cond</code>?”, ela pergunta.
          A amiga de Alyssa, Eva Lu Ator, afirma que isso pode ser feito, e ela
          define uma nova versão de <code>if</code>:
        </p>
        <pre><code class="language-scheme">
        

(define (new-if predicate 
          then-clause 
          else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
        </code></pre>

        <p>Eva demonstra o programa para Alyssa:</p>
        <pre><code class="language-scheme">
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
        </code></pre>

        <p>
          Encantada, Alyssa usa <code>new-if</code> para reescrever o programa
          de raiz quadrada:
        </p>
        <pre><code class="language-scheme">
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
        </code></pre>

        <p>
          O que acontece quando Alyssa tenta usar isso para calcular raízes
          quadradas? Explique.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e7"></a>Exercício 1.7:</strong> O teste
          <code>good-enough?</code> usado no cálculo de raízes quadradas não
          será muito eficaz para encontrar as raízes quadradas de números muito
          pequenos. Além disso, em computadores reais, as operações aritméticas
          são quase sempre realizadas com precisão limitada. Isso torna nosso
          teste inadequado para números muito grandes. Explique essas
          afirmações, com exemplos mostrando como o teste falha para números
          pequenos e grandes. Uma estratégia alternativa para implementar
          <code>good-enough?</code> é observar como <code>guess</code> muda de
          uma iteração para a próxima e parar quando a mudança é uma fração
          muito pequena do palpite. Projete um procedimento de raiz quadrada que
          use esse tipo de teste final. Isso funciona melhor para números
          pequenos e grandes?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e8"></a>Exercício 1.8:</strong> O método
          de Newton para raízes cúbicas é baseado no fato de que, se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>y</mi>
          </math>
          é uma aproximação da raiz cúbica de
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>,
          então uma aproximação melhor é dada pelo valor

          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mrow>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>x</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mo>/</mo>
                    </mrow>
                    <msup>
                      <mi>y</mi>
                      <mn>2</mn>
                    </msup>
                  </mrow>
                  <mo>+</mo>
                  <mn>2</mn>
                  <mi>y</mi>
                </mrow>
                <mn>3</mn>
              </mfrac>
              <mo>.</mo>
            </mrow>
          </math>

          Use essa fórmula para implementar um procedimento de raiz cúbica
          análogo ao procedimento de raiz quadrada. (Em
          <a href="1_002e3.html#g_t1_002e3_002e4">1.3.4</a> veremos como
          implementar o método de Newton em geral como uma abstração desses
          procedimentos de raiz quadrada e raiz cúbica.)
        </p>
      </blockquote>

      <a id="g_t1_002e1_002e8"></a>
      <a id="Procedures-as-Black_002dBox-Abstractions"></a>
      <h4 class="subsection">
        <span class="secnum">1.1.8</span
        ><span class="sectitle"
          >Procedimentos como Abstrações de Caixa Preta</span
        >
      </h4>

      <p>
        <code>Sqrt</code> é nosso primeiro exemplo de um processo definido por
        um conjunto de procedimentos mutuamente definidos. Observe que a
        definição de <code>sqrt-iter</code> é <a id="index-recursive-1"></a
        ><em>recursiva</em>; isto é, o procedimento é definido em termos de si
        mesmo. A ideia de poder definir um procedimento em termos de si mesmo
        pode ser perturbadora; pode parecer pouco claro como tal definição
        “circular” poderia fazer sentido, muito menos especificar um processo
        bem definido a ser executado por um computador. Isso será abordado com
        mais cuidado em <a href="1_002e2.html#g_t1_002e2">1.2</a>. Mas primeiro,
        vamos considerar alguns outros pontos importantes ilustrados pelo
        exemplo <code>sqrt</code>.
      </p>

      <p>
        Observe que o problema de calcular raízes quadradas se divide
        naturalmente em vários subproblemas: como dizer se um palpite é bom o
        suficiente, como melhorar um palpite, e assim por diante. Cada uma
        dessas tarefas é realizada por um procedimento separado. O programa
        <code>sqrt</code> inteiro pode ser visto como um conjunto de
        procedimentos (mostrado em <a href="#Figure-1_002e2">Figura 1.2</a>) que
        espelha a decomposição do problema em subproblemas.
      </p>

      <figure class="float">
        <a id="Figure-1_002e2"></a>
        <object
          style="width: 34.97ex; height: 15.63ex"
          data="fig/chap1/Fig1.2.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 1.2:</strong> Decomposição procedural do programa
            <code>sqrt</code>.
          </p>
        </figcaption>
      </figure>

      <p>
        A importância dessa estratégia de decomposição não é simplesmente que se
        está dividindo o programa em partes. Afinal, poderíamos pegar qualquer
        programa grande e dividi-lo em partes—as primeiras dez linhas, as
        próximas dez linhas, as próximas dez linhas, e assim por diante. Em vez
        disso, é crucial que cada procedimento realize uma tarefa identificável
        que possa ser usada como um módulo na definição de outros procedimentos.
        Por exemplo, quando definimos o procedimento
        <code>good-enough?</code> em termos de <code>square</code>, somos
        capazes de considerar o procedimento <code>square</code> como uma “caixa
        preta”. Não estamos, nesse momento, preocupados com <em>como</em> o
        procedimento calcula seu resultado, apenas com o fato de que ele calcula
        o quadrado. Os detalhes de como o quadrado é calculado podem ser
        suprimidos, para serem considerados posteriormente. De fato, no que diz
        respeito ao procedimento <code>good-enough?</code>,
        <code>square</code> não é exatamente um procedimento, mas uma abstração
        de um procedimento, uma chamada <a id="index-procedural-abstraction"></a
        ><em>abstração procedural</em>. Nesse nível de abstração, qualquer
        procedimento que calcule o quadrado é igualmente bom.
      </p>

      <p>
        Assim, considerando apenas os valores que retornam, os dois
        procedimentos a seguir para elevar um número ao quadrado devem ser
        indistinguíveis. Cada um recebe um argumento numérico e produz o
        quadrado desse número como valor.<a
          class="footnote_link"
          id="DOCF25"
          href="#FOOT25"
          ><sup>25</sup></a
        >
      </p>
      <pre><code class="language-scheme">
(define (square x) (* x x))

(define (square x) 
  (exp (double (log x))))

(define (double x) (+ x x))
      </code></pre>

      <p>
        Portanto, uma definição de procedimento deve ser capaz de suprimir
        detalhes. Os usuários do procedimento podem não ter escrito o
        procedimento eles mesmos, mas podem tê-lo obtido de outro programador
        como uma caixa preta. Um usuário não precisa saber como o procedimento é
        implementado para usá-lo.
      </p>

      <a id="Local-names"></a>
      <h5 class="subsubheading">Nomes locais</h5>

      <p>
        Um detalhe da implementação de um procedimento que não deve importar
        para o usuário do procedimento é a escolha de nomes para os parâmetros
        formais do procedimento. Assim, os seguintes procedimentos não devem ser
        distinguíveis:
      </p>
      <pre><code class="language-scheme">
(define (square x) (* x x))

(define (square y) (* y y))
      </code></pre>

      <p>
        Este princípio—que o significado de um procedimento deve ser
        independente dos nomes dos parâmetros usados por seu autor—parece
        superficialmente evidente, mas suas consequências são profundas. A
        consequência mais simples é que os nomes dos parâmetros de um
        procedimento devem ser locais ao corpo do procedimento. Por exemplo,
        usamos <code>square</code> na definição de <code>good-enough?</code> em
        nosso procedimento de raiz quadrada:
      </p>
      <pre><code class="language-scheme">
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
      </code></pre>

      <p>
        A intenção do autor de <code>good-enough?</code> é determinar se o
        quadrado do primeiro argumento está dentro de uma tolerância dada do
        segundo argumento. Vemos que o autor de <code>good-enough?</code> usou o
        nome <code>guess</code> para se referir ao primeiro argumento e
        <code>x</code> para se referir ao segundo argumento. O argumento de
        <code>square</code> é <code>guess</code>. Se o autor de
        <code>square</code> usou <code>x</code> (como acima) para se referir a
        esse argumento, vemos que o <code>x</code> em
        <code>good-enough?</code> deve ser um <code>x</code> diferente daquele
        em <code>square</code>. A execução do procedimento
        <code>square</code> não deve afetar o valor de <code>x</code> que é
        usado por <code>good-enough?</code>, porque esse valor de
        <code>x</code> pode ser necessário por <code>good-enough?</code> após
        <code>square</code> terminar de calcular.
      </p>

      <p>
        Se os parâmetros não fossem locais aos corpos de seus respectivos
        procedimentos, então o parâmetro <code>x</code> em
        <code>square</code> poderia ser confundido com o parâmetro
        <code>x</code> em <code>good-enough?</code>, e o comportamento de
        <code>good-enough?</code> dependeria de qual versão de
        <code>square</code> usássemos. Assim, <code>square</code> não seria a
        caixa preta que desejamos.
      </p>

      <p>
        Um parâmetro formal de um procedimento tem um papel muito especial na
        definição do procedimento, pois não importa qual nome o parâmetro formal
        tenha. Tal nome é chamado de <a id="index-bound-variable"></a
        ><em>variável ligada</em>, e dizemos que a definição do procedimento
        <a id="index-binds"></a><em>liga</em> seus parâmetros formais. O
        significado de uma definição de procedimento é inalterado se uma
        variável ligada for consistentemente renomeada em toda a definição.<a
          class="footnote_link"
          id="DOCF26"
          href="#FOOT26"
          ><sup>26</sup></a
        >
        Se uma variável não for ligada, dizemos que ela é <a id="index-free"></a
        ><em>livre</em>. O conjunto de expressões para as quais uma ligação
        define um nome é chamado de <a id="index-scope"></a
        ><em>escopo</em> desse nome. Em uma definição de procedimento, as
        variáveis ligadas declaradas como parâmetros formais do procedimento têm
        o corpo do procedimento como seu escopo.
      </p>

      <p>
        Na definição de <code>good-enough?</code> acima, <code>guess</code> e
        <code>x</code> são variáveis ligadas, mas <code>&lt;</code>,
        <code>-</code>, <code>abs</code> e <code>square</code> são livres. O
        significado de <code>good-enough?</code> deve ser independente dos nomes
        que escolhemos para <code>guess</code> e <code>x</code>, desde que sejam
        distintos e diferentes de <code>&lt;</code>, <code>-</code>,
        <code>abs</code> e <code>square</code>. (Se renomeássemos
        <code>guess</code> para <code>abs</code>, teríamos introduzido um bug ao
        <a id="index-capturing"></a><em>capturar</em> a variável
        <code>abs</code>. Ela teria mudado de livre para ligada.) O significado
        de <code>good-enough?</code> não é independente dos nomes de suas
        variáveis livres, no entanto. Certamente depende do fato (externo a essa
        definição) de que o símbolo <code>abs</code> nomeia um procedimento para
        calcular o valor absoluto de um número.
        <code>Good-enough?</code> calculará uma função diferente se
        substituirmos <code>cos</code> por <code>abs</code> em sua definição.
      </p>

      <a id="Internal-definitions-and-block-structure"></a>
      <h5 class="subsubheading">Definições internas e estrutura de bloco</h5>

      <p>
        Temos um tipo de isolamento de nomes disponível até agora: Os parâmetros
        formais de um procedimento são locais ao corpo do procedimento. O
        programa de raiz quadrada ilustra outra maneira pela qual gostaríamos de
        controlar o uso de nomes. O programa existente consiste em procedimentos
        separados:
      </p>
      <pre><code class="language-scheme">
(define (sqrt x) 
  (sqrt-iter 1.0 x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))
      </code></pre>

      <p>
        O problema com esse programa é que o único procedimento importante para
        os usuários de <code>sqrt</code> é <code>sqrt</code>. Os outros
        procedimentos (<code>sqrt-iter</code>, <code>good-enough?</code> e
        <code>improve</code>) apenas atrapalham suas mentes. Eles podem não
        definir nenhum outro procedimento chamado <code>good-enough?</code> como
        parte de outro programa para trabalhar junto com o programa de raiz
        quadrada, porque <code>sqrt</code> precisa dele. O problema é
        especialmente grave na construção de grandes sistemas por muitos
        programadores separados. Por exemplo, na construção de uma grande
        biblioteca de procedimentos numéricos, muitas funções numéricas são
        calculadas como aproximações sucessivas e, portanto, podem ter
        procedimentos chamados <code>good-enough?</code> e
        <code>improve</code> como procedimentos auxiliares. Gostaríamos de
        localizar os subprocedimentos, escondendo-os dentro de
        <code>sqrt</code> para que <code>sqrt</code> pudesse coexistir com
        outras aproximações sucessivas, cada uma tendo seu próprio procedimento
        privado <code>good-enough?</code>. Para tornar isso possível, permitimos
        que um procedimento tenha definições internas que são locais a esse
        procedimento. Por exemplo, no problema da raiz quadrada, podemos
        escrever:
      </p>
      <pre><code class="language-scheme">
(define (sqrt x)
  (define (good-enough? guess x)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
      </code></pre>

      <p>
        Esse aninhamento de definições, chamado
        <a id="index-block-structure"></a><em>estrutura de bloco</em>, é
        basicamente a solução correta para o problema mais simples de
        empacotamento de nomes. Mas há uma ideia melhor aqui. Além de
        internalizar as definições dos procedimentos auxiliares, podemos
        simplificá-las. Como <code>x</code> é ligado na definição de
        <code>sqrt</code>, os procedimentos <code>good-enough?</code>,
        <code>improve</code> e <code>sqrt-iter</code>, que são definidos
        internamente em <code>sqrt</code>, estão no escopo de <code>x</code>.
        Assim, não é necessário passar <code>x</code> explicitamente para cada
        um desses procedimentos. Em vez disso, permitimos que
        <code>x</code> seja uma variável livre nas definições internas, como
        mostrado abaixo. Então <code>x</code> obtém seu valor do argumento com o
        qual o procedimento envolvente <code>sqrt</code> é chamado. Essa
        disciplina é chamada <a id="index-lexical-scoping"></a
        ><em>escopo léxico</em>.<a
          class="footnote_link"
          id="DOCF27"
          href="#FOOT27"
          ><sup>27</sup></a
        >
      </p>
      <pre><code class="language-scheme">
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
      </code></pre>

      <p>
        Usaremos a estrutura de bloco extensivamente para nos ajudar a dividir
        programas grandes em partes gerenciáveis.<a
          class="footnote_link"
          id="DOCF28"
          href="#FOOT28"
          ><sup>28</sup></a
        >
        A ideia da estrutura de bloco originou-se com a linguagem de programação
        Algol 60. Ela aparece na maioria das linguagens de programação avançadas
        e é uma ferramenta importante para ajudar a organizar a construção de
        programas grandes.
      </p>

      <div class="footnote">
        <h4 class="footnotes-heading">Notas de rodapé</h4>

        <div id="FOOT4">
          <p>
            <a class="footnote_backlink" href="#DOCF4"><sup>4</sup></a> A
            caracterização de números como “dados simples” é uma mentira
            descarada. Na verdade, o tratamento de números é um dos aspectos
            mais complicados e confusos de qualquer linguagem de programação.
            Algumas questões típicas envolvidas são estas: Alguns sistemas de
            computador distinguem <a id="index-integers"></a><em>inteiros</em>,
            como 2, de <a id="index-real-numbers"></a><em>números reais</em>,
            como 2.71. O número real 2.00 é diferente do inteiro 2? As operações
            aritméticas usadas para inteiros são as mesmas que as operações
            usadas para números reais? 6 dividido por 2 produz 3 ou 3.0? Quão
            grande um número podemos representar? Quantas casas decimais de
            precisão podemos representar? O intervalo de inteiros é o mesmo que
            o intervalo de números reais? Além dessas questões, é claro, há uma
            coleção de questões relacionadas a erros de arredondamento e
            truncamento—toda a ciência da análise numérica. Como nosso foco
            neste livro é no design de programas em grande escala, em vez de
            técnicas numéricas, vamos ignorar esses problemas. Os exemplos
            numéricos neste capítulo exibirão o comportamento usual de
            arredondamento que se observa ao usar operações aritméticas que
            preservam um número limitado de casas decimais de precisão em
            operações não inteiras.
          </p>
        </div>
        <div id="FOOT5">
          <p>
            <a class="footnote_backlink" href="#DOCF5"><sup>5</sup></a> Ao longo
            deste livro, quando quisermos enfatizar a distinção entre a entrada
            digitada pelo usuário e a resposta impressa pelo interpretador,
            mostraremos a última em caracteres inclinados.
          </p>
        </div>
        <div id="FOOT6">
          <p>
            <a class="footnote_backlink" href="#DOCF6"><sup>6</sup></a> Sistemas
            Lisp normalmente fornecem recursos para ajudar o usuário a formatar
            expressões. Dois recursos especialmente úteis são um que recua
            automaticamente para a posição correta de pretty-print sempre que
            uma nova linha é iniciada e outro que destaca o parêntese esquerdo
            correspondente sempre que um parêntese direito é digitado.
          </p>
        </div>
        <div id="FOOT7">
          <p>
            <a class="footnote_backlink" href="#DOCF7"><sup>7</sup></a> Lisp
            obedece à convenção de que toda expressão tem um valor. Essa
            convenção, junto com a antiga reputação de Lisp como uma linguagem
            ineficiente, é a fonte da piada de Alan Perlis (parafraseando Oscar
            Wilde) de que “Programadores Lisp sabem o valor de tudo, mas o custo
            de nada.”
          </p>
        </div>
        <div id="FOOT8">
          <p>
            <a class="footnote_backlink" href="#DOCF8"><sup>8</sup></a> Neste
            livro, não mostramos a resposta do interpretador à avaliação de
            definições, pois isso é altamente dependente da implementação.
          </p>
        </div>
        <div id="FOOT9">
          <p>
            <a class="footnote_backlink" href="#DOCF9"><sup>9</sup></a>
            <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> mostrará que essa
            noção de ambiente é crucial, tanto para entender como o
            interpretador funciona quanto para implementar interpretadores.
          </p>
        </div>
        <div id="FOOT10">
          <p>
            <a class="footnote_backlink" href="#DOCF10"><sup>10</sup></a> Pode
            parecer estranho que a regra de avaliação diga, como parte do
            primeiro passo, que devemos avaliar o elemento mais à esquerda de
            uma combinação, já que, nesse ponto, isso só pode ser um operador
            como <code>+</code> ou <code>*</code> representando um procedimento
            primitivo embutido, como adição ou multiplicação. Veremos mais tarde
            que é útil poder trabalhar com combinações cujos operadores são eles
            mesmos expressões compostas.
          </p>
        </div>
        <div id="FOOT11">
          <p>
            <a class="footnote_backlink" href="#DOCF11"><sup>11</sup></a> Formas
            sintáticas especiais que são simplesmente estruturas superficiais
            convenientes para coisas que podem ser escritas de maneiras mais
            uniformes são às vezes chamadas de <a id="index-syntactic-sugar"></a
            ><em>açúcar sintático</em>, para usar uma frase cunhada por Peter
            Landin. Em comparação com usuários de outras linguagens,
            programadores Lisp, como regra, estão menos preocupados com questões
            de sintaxe. (Por outro lado, examine qualquer manual de Pascal e
            observe quanto dele é dedicado a descrições de sintaxe.) Esse desdém
            pela sintaxe deve-se em parte à flexibilidade de Lisp, que facilita
            a mudança da sintaxe superficial, e em parte à observação de que
            muitos constructos sintáticos “convenientes”, que tornam a linguagem
            menos uniforme, acabam causando mais problemas do que valem quando
            os programas se tornam grandes e complexos. Nas palavras de Alan
            Perlis, “Açúcar sintático causa câncer de ponto e vírgula.”
          </p>
        </div>
        <div id="FOOT12">
          <p>
            <a class="footnote_backlink" href="#DOCF12"><sup>12</sup></a>
            Observe que há duas operações diferentes sendo combinadas aqui:
            estamos criando o procedimento e estamos dando a ele o nome
            <code>square</code>. É possível, e de fato importante, ser capaz de
            separar essas duas noções—criar procedimentos sem nomeá-los e dar
            nomes a procedimentos que já foram criados. Veremos como fazer isso
            em <a href="1_002e3.html#g_t1_002e3_002e2">1.3.2</a>.
          </p>
        </div>
        <div id="FOOT13">
          <p>
            <a class="footnote_backlink" href="#DOCF13"><sup>13</sup></a> Ao
            longo deste livro, descreveremos a sintaxe geral de expressões
            usando símbolos em itálico delimitados por colchetes angulares—por
            exemplo, <code>⟨</code><var>name</var><code>⟩</code>—para denotar os
            “espaços” na expressão a serem preenchidos quando tal expressão é
            realmente usada.
          </p>
        </div>
        <div id="FOOT14">
          <p>
            <a class="footnote_backlink" href="#DOCF14"><sup>14</sup></a> Mais
            geralmente, o corpo do procedimento pode ser uma sequência de
            expressões. Nesse caso, o interpretador avalia cada expressão na
            sequência por vez e retorna o valor da expressão final como o valor
            da aplicação do procedimento.
          </p>
        </div>
        <div id="FOOT15">
          <p>
            <a class="footnote_backlink" href="#DOCF15"><sup>15</sup></a> Apesar
            da simplicidade da ideia de substituição, é surpreendentemente
            complicado dar uma definição matemática rigorosa do processo de
            substituição. O problema surge da possibilidade de confusão entre os
            nomes usados para os parâmetros formais de um procedimento e os
            (possivelmente idênticos) nomes usados nas expressões às quais o
            procedimento pode ser aplicado. De fato, há uma longa história de
            definições errôneas de <a id="index-substitution"></a
            ><em>substituição</em> na literatura de lógica e semântica de
            programação. Veja
            <a href="References.html#Stoy-1977">Stoy 1977</a> para uma discussão
            cuidadosa da substituição.
          </p>
        </div>
        <div id="FOOT16">
          <p>
            <a class="footnote_backlink" href="#DOCF16"><sup>16</sup></a> Em
            <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> introduziremos
            <a id="index-stream-processing"></a><em>processamento de fluxo</em>,
            que é uma maneira de lidar com estruturas de dados aparentemente
            “infinitas” incorporando uma forma limitada de avaliação de ordem
            normal. Em <a href="4_002e2.html#g_t4_002e2">4.2</a> modificaremos o
            interpretador Scheme para produzir uma variante de Scheme de ordem
            normal.
          </p>
        </div>
        <div id="FOOT17">
          <p>
            <a class="footnote_backlink" href="#DOCF17"><sup>17</sup></a>
            “Interpretado como verdadeiro ou falso” significa o seguinte: Em
            Scheme, há dois valores distinguidos que são denotados pelas
            constantes <code>#t</code> e <code>#f</code>. Quando o interpretador
            verifica o valor de um predicado, ele interpreta
            <code>#f</code> como falso. Qualquer outro valor é tratado como
            verdadeiro. (Assim, fornecer <code>#t</code> é logicamente
            desnecessário, mas é conveniente.) Neste livro, usaremos os nomes
            <code>true</code> e <code>false</code>, que estão associados aos
            valores <code>#t</code> e <code>#f</code>, respectivamente.
          </p>
        </div>
        <div id="FOOT18">
          <p>
            <a class="footnote_backlink" href="#DOCF18"><sup>18</sup></a>
            <code>Abs</code> também usa o operador “menos” <code>-</code>, que,
            quando usado com um único operando, como em <code>(- x)</code>,
            indica negação.
          </p>
        </div>
        <div id="FOOT19">
          <p>
            <a class="footnote_backlink" href="#DOCF19"><sup>19</sup></a> Uma
            pequena diferença entre <code>if</code> e <code>cond</code> é que a
            parte <code>⟨</code><var>e</var><code>⟩</code> de cada cláusula
            <code>cond</code> pode ser uma sequência de expressões. Se o
            <code>⟨</code><var>p</var><code>⟩</code> correspondente for
            considerado verdadeiro, as expressões <code>⟨</code><var>e</var
            ><code>⟩</code> são avaliadas em sequência e o valor da expressão
            final na sequência é retornado como o valor do <code>cond</code>. Em
            uma expressão <code>if</code>, no entanto, o <code>⟨</code
            ><var>consequent</var><code>⟩</code> e o <code>⟨</code
            ><var>alternative</var><code>⟩</code> devem ser expressões únicas.
          </p>
        </div>
        <div id="FOOT20">
          <p>
            <a class="footnote_backlink" href="#DOCF20"><sup>20</sup></a>
            Descrições declarativas e imperativas estão intimamente
            relacionadas, assim como matemática e ciência da computação. Por
            exemplo, dizer que a resposta produzida por um programa é “correta”
            é fazer uma afirmação declarativa sobre o programa. Há uma grande
            quantidade de pesquisa voltada para estabelecer técnicas para provar
            que programas são corretos, e muito da dificuldade técnica desse
            assunto tem a ver com negociar a transição entre afirmações
            imperativas (a partir das quais os programas são construídos) e
            afirmações declarativas (que podem ser usadas para deduzir coisas).
            Em uma linha relacionada, uma área importante no design de
            linguagens de programação é a exploração de linguagens de muito alto
            nível, nas quais se programa em termos de afirmações declarativas. A
            ideia é tornar os interpretadores sofisticados o suficiente para
            que, dado o conhecimento “o que é” especificado pelo programador,
            eles possam gerar o conhecimento “como fazer” automaticamente. Isso
            não pode ser feito em geral, mas há áreas importantes onde progresso
            foi feito. Revisitaremos essa ideia em
            <a href="Chapter-4.html#Chapter-4">Capítulo 4</a>.
          </p>
        </div>
        <div id="FOOT21">
          <p>
            <a class="footnote_backlink" href="#DOCF21"><sup>21</sup></a> Esse
            algoritmo de raiz quadrada é na verdade um caso especial do método
            de Newton, que é uma técnica geral para encontrar raízes de
            equações. O algoritmo de raiz quadrada em si foi desenvolvido por
            Heron de Alexandria no primeiro século <abbr>A.D.</abbr> Veremos
            como expressar o método geral de Newton como um procedimento Lisp em
            <a href="1_002e3.html#g_t1_002e3_002e4">1.3.4</a>.
          </p>
        </div>
        <div id="FOOT22">
          <p>
            <a class="footnote_backlink" href="#DOCF22"><sup>22</sup></a>
            Geralmente daremos nomes a predicados terminando com pontos de
            interrogação, para nos ajudar a lembrar que são predicados. Isso é
            apenas uma convenção estilística. No que diz respeito ao
            interpretador, o ponto de interrogação é apenas um caractere comum.
          </p>
        </div>
        <div id="FOOT23">
          <p>
            <a class="footnote_backlink" href="#DOCF23"><sup>23</sup></a>
            Observe que expressamos nosso palpite inicial como 1.0 em vez de 1.
            Isso não faria diferença em muitas implementações de Lisp. No
            entanto, o <abbr>MIT</abbr> Scheme distingue entre inteiros exatos e
            valores decimais, e dividir dois inteiros produz um número racional
            em vez de um decimal. Por exemplo, dividir 10 por 6 produz 5/3,
            enquanto dividir 10.0 por 6.0 produz 1.6666666666666667.
            (Aprenderemos como implementar aritmética em números racionais em
            <a href="2_002e1.html#g_t2_002e1_002e1">2.1.1</a>.) Se começarmos
            com um palpite inicial de 1 em nosso programa de raiz quadrada, e
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>x</mi>
            </math>
            é um inteiro exato, todos os valores subsequentes produzidos no
            cálculo da raiz quadrada serão números racionais em vez de decimais.
            Operações mistas em números racionais e decimais sempre produzem
            decimais, então começar com um palpite inicial de 1.0 força todos os
            valores subsequentes a serem decimais.
          </p>
        </div>
        <div id="FOOT24">
          <p>
            <a class="footnote_backlink" href="#DOCF24"><sup>24</sup></a>
            Leitores preocupados com questões de eficiência envolvidas no uso de
            chamadas de procedimento para implementar iteração devem notar as
            observações sobre “recursão em cauda” em
            <a href="1_002e2.html#g_t1_002e2_002e1">1.2.1</a>.
          </p>
        </div>
        <div id="FOOT25">
          <p>
            <a class="footnote_backlink" href="#DOCF25"><sup>25</sup></a> Não é
            nem mesmo claro qual desses procedimentos é uma implementação mais
            eficiente. Isso depende do hardware disponível. Há máquinas para as
            quais a implementação “óbvia” é a menos eficiente. Considere uma
            máquina que tem tabelas extensas de logaritmos e antilogaritmos
            armazenadas de maneira muito eficiente.
          </p>
        </div>
        <div id="FOOT26">
          <p>
            <a class="footnote_backlink" href="#DOCF26"><sup>26</sup></a> O
            conceito de renomeação consistente é na verdade sutil e difícil de
            definir formalmente. Lógicos famosos cometeram erros embaraçosos
            aqui.
          </p>
        </div>
        <div id="FOOT27">
          <p>
            <a class="footnote_backlink" href="#DOCF27"><sup>27</sup></a> O
            escopo léxico dita que variáveis livres em um procedimento são
            tomadas para se referir a ligações feitas por definições de
            procedimentos envolventes; isto é, elas são procuradas no ambiente
            em que o procedimento foi definido. Veremos como isso funciona em
            detalhes no capítulo 3, quando estudarmos ambientes e o
            comportamento detalhado do interpretador.<a id="Footnote-28"></a>
          </p>
        </div>
        <div id="FOOT28">
          <p>
            <a class="footnote_backlink" href="#DOCF28"><sup>28</sup></a>
            Definições embutidas devem vir primeiro no corpo de um procedimento.
            A administração não é responsável pelas consequências da execução de
            programas que entrelaçam definição e uso.
          </p>
        </div>
      </div>

      <nav class="header">
        <p>
          Próximo:
          <a href="1_002e2.html#g_t1_002e2" accesskey="n" rel="next">1.2</a>,
          Anterior:
          <a href="Chapter-1.html#Chapter-1" accesskey="p" rel="prev"
            >Capítulo 1</a
          >, Acima: <a href="#g_t1_002e1" accesskey="u" rel="prev">1.1</a> [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Conteúdo</a
          >]
        </p>
      </nav>
    </section>
    <span class="bottom jump" title="Jump to bottom"
      ><a href="#pagebottom" accesskey="b">⇣</a></span
    ><a id="pagebottom"></a>
  </body>
</html>
