<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 3.5"
    />
    <meta
      name="keywords"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 3.5"
    />
    <title>
      Estrutura e Interpretação de Programas de Computador, 2ª edição: 3.5
    </title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/prettify.css" />
    <script src="js/jquery.min.js"></script>
    <script src="js/footnotes.js"></script>
    <script src="js/browsertest.js"></script>
  </head>
  <body>
    <section>
      <a id="pagetop"></a>
      <a id="g_t3_002e5"></a>
      <nav class="header">
        <p>
          Próximo:
          <a href="Chapter-4.html#Chapter-4" accesskey="n" rel="next"
            >Capítulo 4</a
          >, Anterior:
          <a href="3_002e4.html#g_t3_002e4" accesskey="p" rel="prev">3.4</a>,
          Acima:
          <a href="Chapter-3.html#Chapter-3" accesskey="u" rel="prev"
            >Capítulo 3</a
          >
          [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Conteúdo</a
          >]
        </p>
      </nav>
      <a id="Streams"></a>
      <h3 class="section">
        <span class="secnum">3.5</span><span class="sectitle">Fluxos</span>
      </h3>

      <p>
        Nós ganhamos uma boa compreensão da atribuição como uma ferramenta na
        modelagem, assim como uma apreciação dos problemas complexos que a
        atribuição levanta. É hora de perguntar se poderíamos ter feito as
        coisas de uma maneira diferente, para evitar alguns desses problemas.
        Nesta seção, exploramos uma abordagem alternativa para modelar estado,
        baseada em estruturas de dados chamadas <a id="index-streams-1"></a>
        <em>fluxos</em>. Como veremos, os fluxos podem mitigar parte da
        complexidade de modelar estados.
      </p>

      <p>
        Vamos recuar e revisar de onde essa complexidade vem. Na tentativa de
        modelar fenômenos do mundo real, tomamos algumas decisões aparentemente
        razoáveis: modelamos objetos do mundo real com estado local por objetos
        computacionais com variáveis locais. Identificamos a variação temporal
        no mundo real com a variação temporal no computador. Implementamos a
        variação temporal dos estados dos objetos do modelo no computador com
        atribuições às variáveis locais dos objetos do modelo.
      </p>

      <p>
        Existe outra abordagem? Podemos evitar identificar o tempo no computador
        com o tempo no mundo modelado? Devemos fazer o modelo mudar com o tempo
        para modelar fenômenos em um mundo em mudança? Pense sobre o problema em
        termos de funções matemáticas. Podemos descrever o comportamento
        variante no tempo de uma quantidade
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> como
        uma função do tempo
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><mrow class="MJX-TeXAtom-ORD"
            ><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi
            ><mo stretchy="false">)</mo></mrow
          ></math
        >. Se nos concentrarmos em
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math>
        instante a instante, pensamos nela como uma quantidade em mudança. No
        entanto, se nos concentrarmos em toda a história temporal de valores,
        não enfatizamos a mudança — a função em si não muda.<a
          class="footnote_link"
          id="DOCF180"
          href="#FOOT180"
          ><sup>180</sup></a
        >
      </p>

      <p>
        Se o tempo for medido em passos discretos, então podemos modelar uma
        função temporal como uma sequência (possivelmente infinita). Nesta
        seção, veremos como modelar mudanças em termos de sequências que
        representam as histórias temporais dos sistemas sendo modelados. Para
        isso, introduzimos novas estruturas de dados chamadas
        <a id="index-streams-2"></a> <em>fluxos</em>. De um ponto de vista
        abstrato, um fluxo é simplesmente uma sequência. No entanto,
        descobriremos que a implementação direta de fluxos como listas (como em
        <a href="2_002e2.html#g_t2_002e2_002e1">2.2.1</a>) não revela
        totalmente o poder do processamento de fluxos. Como alternativa,
        introduzimos a técnica de <a id="index-delayed-evaluation-1"></a>
        <em>avaliação atrasada</em>, que nos permite representar sequências
        muito grandes (mesmo infinitas) como fluxos.
      </p>

      <p>
        O processamento de fluxos nos permite modelar sistemas que têm estado
        sem nunca usar atribuição ou dados mutáveis. Isso tem implicações
        importantes, tanto teóricas quanto práticas, porque podemos construir
        modelos que evitam as desvantagens inerentes à introdução de atribuição.
        Por outro lado, o framework de fluxos levanta dificuldades próprias, e a
        questão de qual técnica de modelagem leva a sistemas mais modulares e
        mais facilmente mantidos permanece em aberto.
      </p>

      <a id="g_t3_002e5_002e1"></a>
      <a id="Streams-Are-Delayed-Lists"></a>
      <h4 class="subsection">
        <span class="secnum">3.5.1</span
        ><span class="sectitle">Fluxos São Listas Atrasadas</span>
      </h4>

      <p>
        Como vimos em <a href="2_002e2.html#g_t2_002e2_002e3">2.2.3</a>,
        sequências podem servir como interfaces padrão para combinar módulos de
        programas. Formulamos abstrações poderosas para manipular sequências,
        como <code>map</code>, <code>filter</code> e <code>accumulate</code>,
        que capturam uma variedade de operações de uma maneira que é tanto
        sucinta quanto elegante.
      </p>

      <p>
        Infelizmente, se representarmos sequências como listas, essa elegância é
        obtida ao preço de uma severa ineficiência em relação ao tempo e espaço
        necessários para nossas computações. Quando representamos manipulações
        em sequências como transformações de listas, nossos programas devem
        construir e copiar estruturas de dados (que podem ser enormes) a cada
        passo de um processo.
      </p>

      <p>
        Para ver por que isso é verdade, vamos comparar dois programas para
        calcular a soma de todos os números primos em um intervalo. O primeiro
        programa é escrito em estilo iterativo padrão:<a
          class="footnote_link"
          id="DOCF181"
          href="#FOOT181"
          ><sup>181</sup></a
        >
      </p>

      <pre><code class="language-scheme">(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count)
           (iter (+ count 1)
                 (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))</code></pre>

      <p>
        O segundo programa realiza a mesma computação usando as operações de
        sequência de <a href="2_002e2.html#g_t2_002e2_002e3">2.2.3</a>:
      </p>

      <pre><code class="language-scheme">(define (sum-primes a b)
  (accumulate 
   +
   0
   (filter prime? (enumerate-interval a b))))</code></pre>

      <p>
        Na execução da computação, o primeiro programa precisa armazenar apenas
        a soma sendo acumulada. Em contraste, o filtro no segundo programa não
        pode fazer nenhum teste até que <code>enumerate-interval</code> tenha
        construído uma lista completa dos números no intervalo. O filtro gera
        outra lista, que por sua vez é passada para
        <code>accumulate</code> antes de ser colapsada para formar uma soma.
        Esse armazenamento intermediário grande não é necessário pelo primeiro
        programa, que podemos pensar como enumerando o intervalo
        incrementalmente, adicionando cada primo à soma à medida que é gerado.
      </p>

      <p>
        A ineficiência no uso de listas torna-se dolorosamente aparente se
        usarmos o paradigma de sequência para calcular o segundo primo no
        intervalo de 10.000 a 1.000.000 avaliando a expressão:
      </p>

      <pre><code class="language-scheme">(car (cdr 
      (filter 
       prime?
       (enumerate-interval 10000 1000000))))</code></pre>

      <p>
        Esta expressão encontra o segundo primo, mas a sobrecarga computacional
        é absurda. Construímos uma lista de quase um milhão de inteiros,
        filtramos essa lista testando cada elemento para primalidade e então
        ignoramos quase todo o resultado. Em um estilo de programação mais
        tradicional, intercalaríamos a enumeração e a filtragem, e pararíamos
        quando atingíssemos o segundo primo.
      </p>

      <p>
        Fluxos são uma ideia inteligente que permite usar manipulações de
        sequência sem incorrer nos custos de manipular sequências como listas.
        Com fluxos, podemos alcançar o melhor dos dois mundos: podemos formular
        programas elegantemente como manipulações de sequência, enquanto
        atingimos a eficiência da computação incremental. A ideia básica é
        organizar a construção de um fluxo apenas parcialmente e passar a
        construção parcial para o programa que consome o fluxo. Se o consumidor
        tentar acessar uma parte do fluxo que ainda não foi construída, o fluxo
        automaticamente construirá apenas o suficiente para produzir a parte
        necessária, preservando assim a ilusão de que o fluxo inteiro existe. Em
        outras palavras, embora escrevamos programas como se estivéssemos
        processando sequências completas, projetamos nossa implementação de
        fluxo para intercalar automaticamente e transparentemente a construção
        do fluxo com seu uso.
      </p>

      <p>
        Na superfície, fluxos são apenas listas com nomes diferentes para os
        procedimentos que as manipulam. Há um construtor,
        <code>cons-stream</code>, e dois seletores, <code>stream-car</code> e
        <code>stream-cdr</code>, que satisfazem as restrições:
      </p>

      <div class="example">
        <pre class="example">
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y</pre
        >
      </div>

      <p>
        Há um objeto distinguível, <code>the-empty-stream</code>, que não pode
        ser o resultado de nenhuma operação <code>cons-stream</code>, e que pode
        ser identificado com o predicado <code>stream-null?</code>.<a
          class="footnote_link"
          id="DOCF182"
          href="#FOOT182"
          ><sup>182</sup></a
        >
        Assim, podemos criar e usar fluxos, da mesma forma que podemos criar e
        usar listas, para representar dados agregados dispostos em uma
        sequência. Em particular, podemos construir análogos de fluxo das
        operações de lista do
        <a href="Chapter-2.html#Chapter-2">Capítulo 2</a>, como
        <code>list-ref</code>, <code>map</code> e <code>for-each</code>:<a
          class="footnote_link"
          id="DOCF183"
          href="#FOOT183"
          ><sup>183</sup></a
        >
      </p>

      <pre><code class="language-scheme">(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream 
       (proc (stream-car s))
       (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin 
        (proc (stream-car s))
        (stream-for-each proc 
                         (stream-cdr s)))))</code></pre>

      <p><code>Stream-for-each</code> é útil para visualizar fluxos:</p>

      <pre><code class="language-scheme">(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))</code></pre>

      <p>
        Para fazer a implementação do fluxo intercalar automaticamente e
        transparentemente a construção de um fluxo com seu uso, organizaremos
        para que o <code>cdr</code> de um fluxo seja avaliado quando for
        acessado pelo procedimento <code>stream-cdr</code> em vez de quando o
        fluxo for construído por <code>cons-stream</code>. Essa escolha de
        implementação é reminiscente de nossa discussão sobre números racionais
        em <a href="2_002e1.html#g_t2_002e1_002e2">2.1.2</a>, onde vimos que
        podemos escolher implementar números racionais de modo que a redução do
        numerador e denominador para termos mais baixos seja realizada no
        momento da construção ou no momento da seleção. As duas implementações
        de números racionais produzem a mesma abstração de dados, mas a escolha
        tem um efeito na eficiência. Há uma relação semelhante entre fluxos e
        listas ordinárias. Como uma abstração de dados, fluxos são iguais a
        listas. A diferença é o momento em que os elementos são avaliados. Com
        listas ordinárias, tanto o <code>car</code> quanto o
        <code>cdr</code> são avaliados no momento da construção. Com fluxos, o
        <code>cdr</code> é avaliado no momento da seleção.
      </p>

      <p>
        Nossa implementação de fluxos será baseada em uma forma especial chamada
        <code>delay</code>. Avaliar <code>(delay ⟨exp⟩)</code> não avalia a
        expressão <code>⟨exp⟩</code>, mas retorna um objeto chamado
        <a id="index-delayed-object"></a> <em>objeto atrasado</em>, que podemos
        pensar como uma “promessa” de avaliar <code>⟨exp⟩</code> em algum
        momento futuro. Como companheiro de <code>delay</code>, há um
        procedimento chamado <code>force</code> que toma um objeto atrasado como
        argumento e realiza a avaliação — efetivamente forçando o
        <code>delay</code> a cumprir sua promessa. Veremos abaixo como
        <code>delay</code> e <code>force</code> podem ser implementados, mas
        primeiro vamos usá-los para construir fluxos.
      </p>

      <p><code>Cons-stream</code> é uma forma especial definida de modo que:</p>

      <pre><code class="language-scheme">(cons-stream ⟨a⟩ ⟨b⟩)</code></pre>

      <p>é equivalente a:</p>

      <pre><code class="language-scheme">(cons ⟨a⟩ (delay ⟨b⟩))</code></pre>

      <p>
        O que isso significa é que construiremos fluxos usando pares. No
        entanto, em vez de colocar o valor do resto do fluxo no
        <code>cdr</code> do par, colocaremos lá uma promessa de calcular o resto
        se ele for solicitado. <code>Stream-car</code> e
        <code>stream-cdr</code> podem agora ser definidos como procedimentos:
      </p>

      <pre><code class="language-scheme">(define (stream-car stream) 
  (car stream))

(define (stream-cdr stream) 
  (force (cdr stream)))</code></pre>

      <p>
        <code>Stream-car</code> seleciona o <code>car</code> do par;
        <code>stream-cdr</code> seleciona o <code>cdr</code> do par e avalia a
        expressão atrasada encontrada lá para obter o resto do fluxo.<a
          class="footnote_link"
          id="DOCF184"
          href="#FOOT184"
          ><sup>184</sup></a
        >
      </p>

      <a id="The-stream-implementation-in-action"></a>
      <h5 class="subsubheading">A implementação do fluxo em ação</h5>

      <p>
        Para ver como essa implementação se comporta, vamos analisar a
        computação “extravagante” de primos que vimos acima, reformulada em
        termos de fluxos:
      </p>

      <pre><code class="language-scheme">(stream-car 
 (stream-cdr
  (stream-filter 
   prime? (stream-enumerate-interval 
           10000 1000000))))</code></pre>

      <p>Veremos que isso realmente funciona de forma eficiente.</p>

      <p>
        Começamos chamando <code>stream-enumerate-interval</code> com os
        argumentos 10.000 e 1.000.000. <code>Stream-enumerate-interval</code> é
        o análogo de fluxo de <code>enumerate-interval</code> (<a
          href="2_002e2.html#g_t2_002e2_002e3"
          >2.2.3</a
        >):
      </p>

      <pre><code class="language-scheme">(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1)
                                  high))))</code></pre>

      <p>
        e, portanto, o resultado retornado por
        <code>stream-enumerate-interval</code>, formado pelo
        <code>cons-stream</code>, é<a
          class="footnote_link"
          id="DOCF185"
          href="#FOOT185"
          ><sup>185</sup></a
        >
      </p>

      <pre><code class="language-scheme">(cons 10000
      (delay 
        (stream-enumerate-interval 
         10001 
         1000000)))</code></pre>

      <p>
        Ou seja, <code>stream-enumerate-interval</code> retorna um fluxo
        representado como um par cujo <code>car</code> é 10.000 e cujo
        <code>cdr</code> é uma promessa de enumerar mais do intervalo se
        solicitado. Este fluxo é agora filtrado para primos, usando o análogo de
        fluxo do procedimento <code>filter</code> (<a
          href="2_002e2.html#g_t2_002e2_002e3"
          >2.2.3</a
        >):
      </p>

      <pre><code class="language-scheme">(define (stream-filter pred stream)
  (cond ((stream-null? stream) 
         the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream 
          (stream-car stream)
          (stream-filter 
           pred
           (stream-cdr stream))))
        (else (stream-filter 
               pred 
               (stream-cdr stream)))))</code></pre>

      <p>
        <code>Stream-filter</code> testa o <code>stream-car</code> do fluxo (o
        <code>car</code> do par, que é 10.000). Como isso não é primo,
        <code>stream-filter</code> examina o <code>stream-cdr</code> de seu
        fluxo de entrada. A chamada para <code>stream-cdr</code> força a
        avaliação do <code>stream-enumerate-interval</code> atrasado, que agora
        retorna:
      </p>

      <pre><code class="language-scheme">(cons 10001
      (delay 
        (stream-enumerate-interval 
         10002 
         1000000)))</code></pre>

      <p>
        <code>Stream-filter</code> agora olha para o
        <code>stream-car</code> deste fluxo, 10.001, vê que isso também não é
        primo, força outro <code>stream-cdr</code>, e assim por diante, até que
        <code>stream-enumerate-interval</code> produza o primo 10.007, onde
        <code>stream-filter</code>, de acordo com sua definição, retorna:
      </p>

      <pre><code class="language-scheme">(cons-stream 
 (stream-car stream)
 (stream-filter pred (stream-cdr stream)))</code></pre>

      <p>que neste caso é:</p>

      <pre><code class="language-scheme">(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 
                  10009 1000000))))))</code></pre>

      <p>
        Este resultado é agora passado para <code>stream-cdr</code> em nossa
        expressão original. Isso força o <code>stream-filter</code> atrasado,
        que por sua vez continua forçando o
        <code>stream-enumerate-interval</code> atrasado até encontrar o próximo
        primo, que é 10.009. Finalmente, o resultado passado para
        <code>stream-car</code> em nossa expressão original é:
      </p>

      <pre><code class="language-scheme">(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 
                  10011 1000000))))))</code></pre>

      <p>
        <code>Stream-car</code> retorna 10.009, e a computação está completa.
        Apenas tantos inteiros foram testados para primalidade quanto foram
        necessários para encontrar o segundo primo, e o intervalo foi enumerado
        apenas o suficiente para alimentar o filtro de primos.
      </p>

      <p>
        Em geral, podemos pensar na avaliação atrasada como programação
        “orientada por demanda”, onde cada estágio no processo de fluxo é
        ativado apenas o suficiente para satisfazer o próximo estágio. O que
        fizemos foi desacoplar a ordem real dos eventos na computação da
        estrutura aparente de nossos procedimentos. Escrevemos procedimentos
        como se os fluxos existissem “todos de uma vez” quando, na realidade, a
        computação é realizada incrementalmente, como em estilos de programação
        tradicionais.
      </p>

      <a id="Implementing-delay-and-force"></a>
      <h5 class="subsubheading">
        Implementando <code>delay</code> e <code>force</code>
      </h5>

      <p>
        Embora <code>delay</code> e <code>force</code> possam parecer operações
        misteriosas, sua implementação é realmente bastante direta.
        <code>Delay</code> deve empacotar uma expressão para que ela possa ser
        avaliada posteriormente sob demanda, e podemos realizar isso
        simplesmente tratando a expressão como o corpo de um procedimento.
        <code>Delay</code> pode ser uma forma especial tal que:
      </p>

      <pre><code class="language-scheme">(delay ⟨exp⟩)</code></pre>

      <p>é açúcar sintático para:</p>

      <pre><code class="language-scheme">(lambda () ⟨exp⟩)</code></pre>

      <p>
        <code>Force</code> simplesmente chama o procedimento (sem argumentos)
        produzido por <code>delay</code>, então podemos implementar
        <code>force</code> como um procedimento:
      </p>

      <pre><code class="language-scheme">(define (force delayed-object)
  (delayed-object))</code></pre>

      <p>
        Esta implementação é suficiente para <code>delay</code> e
        <code>force</code> funcionarem como anunciado, mas há uma otimização
        importante que podemos incluir. Em muitas aplicações, acabamos forçando
        o mesmo objeto atrasado muitas vezes. Isso pode levar a uma ineficiência
        séria em programas recursivos envolvendo fluxos. (Veja
        <a href="#Exercise-3_002e57">Exercício 3.57</a>.) A solução é construir
        objetos atrasados de modo que, na primeira vez que forem forçados,
        armazenem o valor que foi calculado. Forçamentos subsequentes
        simplesmente retornarão o valor armazenado sem repetir a computação. Em
        outras palavras, implementamos <code>delay</code> como um procedimento
        memoizado especializado, semelhante ao descrito em
        <a href="3_002e3.html#Exercise-3_002e27">Exercício 3.27</a>. Uma
        maneira de realizar isso é usar o seguinte procedimento, que toma como
        argumento um procedimento (sem argumentos) e retorna uma versão
        memoizada do procedimento. A primeira vez que o procedimento memoizado é
        executado, ele salva o resultado calculado. Em avaliações subsequentes,
        ele simplesmente retorna o resultado.
      </p>

      <pre><code class="language-scheme">(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))</code></pre>

      <p>
        <code>Delay</code> é então definido de modo que
        <code>(delay ⟨exp⟩)</code> seja equivalente a:
      </p>

      <pre><code class="language-scheme">(memo-proc (lambda () ⟨exp⟩))</code></pre>

      <p>
        e <code>force</code> é como definido anteriormente.<a
          class="footnote_link"
          id="DOCF186"
          href="#FOOT186"
          ><sup>186</sup></a
        >
      </p>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e50"></a>Exercício 3.50:</strong>
          Complete a seguinte definição, que generaliza
          <code>stream-map</code> para permitir procedimentos que tomam
          múltiplos argumentos, análogo a <code>map</code> em
          <a href="2_002e2.html#g_t2_002e2_002e1">2.2.1</a>,
          <a href="2_002e2.html#Footnote-78">Nota de rodapé 78</a>.
        </p>
        <pre><code class="language-scheme">(define (stream-map proc . argstreams)
  (if (⟨??⟩ (car argstreams))
      the-empty-stream
      (⟨??⟩
       (apply proc (map ⟨??⟩ argstreams))
       (apply stream-map
              (cons proc 
                    (map ⟨??⟩ 
                         argstreams)))))</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e51"></a>Exercício 3.51:</strong> Para
          dar uma olhada mais de perto na avaliação atrasada, usaremos o
          seguinte procedimento, que simplesmente retorna seu argumento após
          imprimi-lo:
        </p>
        <pre><code class="language-scheme">(define (show x)
  (display-line x)
  x)</code></pre>

        <p>
          O que o interpretador imprime em resposta à avaliação de cada
          expressão na seguinte sequência?<a
            class="footnote_link"
            id="DOCF187"
            href="#FOOT187"
            ><sup>187</sup></a
          >
        </p>
        <pre><code class="language-scheme">(define x 
  (stream-map 
   show 
   (stream-enumerate-interval 0 10)))

(stream-ref x 5)
(stream-ref x 7)</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e52"></a>Exercício 3.52:</strong>
          Considere a sequência de expressões:
        </p>
        <pre><code class="language-scheme">(define sum 0)

(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq 
  (stream-map 
   accum 
   (stream-enumerate-interval 1 20)))

(define y (stream-filter even? seq))

(define z 
  (stream-filter 
   (lambda (x) 
     (= (remainder x 5) 0)) seq))

(stream-ref y 7)
(display-stream z)</code></pre>

        <p>
          Qual é o valor de <code>sum</code> após cada uma das expressões acima
          ser avaliada? Qual é a resposta impressa à avaliação das expressões
          <code>stream-ref</code> e <code>display-stream</code>? Essas respostas
          difeririam se tivéssemos implementado
          <code>(delay ⟨exp⟩)</code> simplesmente como
          <code>(lambda () ⟨exp⟩)</code> sem usar a otimização fornecida por
          <code>memo-proc</code>? Explique.
        </p>
      </blockquote>

      <a id="g_t3_002e5_002e2"></a>
      <a id="Infinite-Streams"></a>
      <h4 class="subsection">
        <span class="secnum">3.5.2</span
        ><span class="sectitle">Fluxos Infinitos</span>
      </h4>

      <p>
        Vimos como apoiar a ilusão de manipular fluxos como entidades completas,
        embora, na realidade, computemos apenas o suficiente do fluxo conforme
        necessário para acessar. Podemos explorar essa técnica para representar
        sequências de forma eficiente como fluxos, mesmo que as sequências sejam
        muito longas. O que é mais impressionante, podemos usar fluxos para
        representar sequências que são infinitamente longas. Por exemplo,
        considere a seguinte definição do fluxo de inteiros positivos:
      </p>

      <pre><code class="language-scheme">(define (integers-starting-from n)
  (cons-stream 
   n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))</code></pre>

      <p>
        Isso faz sentido porque <code>integers</code> será um par cujo
        <code>car</code> é 1 e cujo <code>cdr</code> é uma promessa de produzir
        os inteiros começando com 2. Este é um fluxo infinitamente longo, mas em
        qualquer momento dado podemos examinar apenas uma porção finita dele.
        Assim, nossos programas nunca saberão que o fluxo infinito inteiro não
        está lá.
      </p>

      <p>
        Usando <code>integers</code> podemos definir outros fluxos infinitos,
        como o fluxo de inteiros que não são divisíveis por 7:
      </p>

      <pre><code class="language-scheme">(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) 
                   (not (divisible? x 7)))
                 integers))</code></pre>

      <p>
        Então podemos encontrar inteiros não divisíveis por 7 simplesmente
        acessando elementos deste fluxo:
      </p>

      <pre><code class="language-scheme">(stream-ref no-sevens 100)
<i>117</i></code></pre>

      <p>
        Em analogia com <code>integers</code>, podemos definir o fluxo infinito
        de números de Fibonacci:
      </p>

      <pre><code class="language-scheme">(define (fibgen a b)
  (cons-stream a (fibgen b (+ a b))))
(define fibs (fibgen 0 1))</code></pre>

      <p>
        <code>Fibs</code> é um par cujo <code>car</code> é 0 e cujo
        <code>cdr</code> é uma promessa de avaliar <code>(fibgen 1 1)</code>.
        Quando avaliamos esse <code>(fibgen 1 1)</code> atrasado, ele produzirá
        um par cujo <code>car</code> é 1 e cujo <code>cdr</code> é uma promessa
        de avaliar <code>(fibgen 1 2)</code>, e assim por diante.
      </p>

      <p>
        Para uma visão de um fluxo infinito mais emocionante, podemos
        generalizar o exemplo <code>no-sevens</code> para construir o fluxo
        infinito de números primos, usando um método conhecido como
        <a id="index-sieve-of-Eratosthenes"></a>
        <em>crivo de Eratóstenes</em>.<a
          class="footnote_link"
          id="DOCF188"
          href="#FOOT188"
          ><sup>188</sup></a
        >
        Começamos com os inteiros começando com 2, que é o primeiro primo. Para
        obter o resto dos primos, começamos filtrando os múltiplos de 2 do resto
        dos inteiros. Isso deixa um fluxo começando com 3, que é o próximo
        primo. Agora filtramos os múltiplos de 3 do resto deste fluxo. Isso
        deixa um fluxo começando com 5, que é o próximo primo, e assim por
        diante. Em outras palavras, construímos os primos por um processo de
        peneiração, descrito da seguinte forma: Para peneirar um fluxo
        <code>S</code>, forme um fluxo cujo primeiro elemento é o primeiro
        elemento de <code>S</code> e o resto do qual é obtido filtrando todos os
        múltiplos do primeiro elemento de <code>S</code> do resto de
        <code>S</code> e peneirando o resultado. Este processo é prontamente
        descrito em termos de operações de fluxo:
      </p>

      <pre><code class="language-scheme">(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? 
                   x (stream-car stream))))
           (stream-cdr stream)))))

(define primes 
  (sieve (integers-starting-from 2)))</code></pre>

      <p>
        Agora, para encontrar um primo específico, precisamos apenas pedir por
        ele:
      </p>

      <pre><code class="language-scheme">(stream-ref primes 50)
<i>233</i></code></pre>

      <p>
        É interessante contemplar o sistema de processamento de sinais
        configurado por <code>sieve</code>, mostrado no “diagrama de Henderson”
        em <a href="#Figure-3_002e31">Figura 3.31</a>.<a
          class="footnote_link"
          id="DOCF189"
          href="#FOOT189"
          ><sup>189</sup></a
        >
        O fluxo de entrada alimenta um “desconstrutor” que separa o primeiro
        elemento do fluxo do resto do fluxo. O primeiro elemento é usado para
        construir um filtro de divisibilidade, através do qual o resto é
        passado, e a saída do filtro é alimentada para outra caixa de peneira.
        Então, o primeiro elemento original é <code>cons</code>ado na saída da
        peneira interna para formar o fluxo de saída. Assim, não apenas o fluxo
        é infinito, mas o processador de sinal também é infinito, porque a
        peneira contém uma peneira dentro dela.
      </p>

      <figure class="float">
        <a id="Figure-3_002e31"></a>
        <object
          style="width: 54.05ex; height: 27.89ex"
          data="fig/chap3/Fig3.31a.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 3.31:</strong> O crivo de primos visto como um
            sistema de processamento de sinais.
          </p>
        </figcaption>
      </figure>

      <a id="Defining-streams-implicitly"></a>
      <h5 class="subsubheading">Definindo fluxos implicitamente</h5>

      <p>
        Os fluxos <code>integers</code> e <code>fibs</code> acima foram
        definidos especificando procedimentos “geradores” que explicitamente
        computam os elementos do fluxo um por um. Uma maneira alternativa de
        especificar fluxos é aproveitar a avaliação atrasada para definir fluxos
        implicitamente. Por exemplo, a seguinte expressão define o fluxo
        <code>ones</code> como um fluxo infinito de uns:
      </p>

      <pre><code class="language-scheme">(define ones (cons-stream 1 ones))</code></pre>

      <p>
        Isso funciona de forma semelhante à definição de um procedimento
        recursivo: <code>ones</code> é um par cujo <code>car</code> é 1 e cujo
        <code>cdr</code> é uma promessa de avaliar <code>ones</code>. Avaliar o
        <code>cdr</code> nos dá novamente um 1 e uma promessa de avaliar
        <code>ones</code>, e assim por diante.
      </p>

      <p>
        Podemos fazer coisas mais interessantes manipulando fluxos com operações
        como <code>add-streams</code>, que produz a soma elemento a elemento de
        dois fluxos dados:<a class="footnote_link" id="DOCF190" href="#FOOT190"
          ><sup>190</sup></a
        >
      </p>

      <pre><code class="language-scheme">(define (add-streams s1 s2) 
  (stream-map + s1 s2))</code></pre>

      <p>Agora podemos definir os inteiros da seguinte forma:</p>

      <pre><code class="language-scheme">(define integers 
  (cons-stream 1 (add-streams ones integers)))</code></pre>

      <p>
        Isso define <code>integers</code> como um fluxo cujo primeiro elemento é
        1 e o resto do qual é a soma de <code>ones</code> e
        <code>integers</code>. Assim, o segundo elemento de
        <code>integers</code> é 1 mais o primeiro elemento de
        <code>integers</code>, ou 2; o terceiro elemento de
        <code>integers</code> é 1 mais o segundo elemento de
        <code>integers</code>, ou 3; e assim por diante. Essa definição funciona
        porque, em qualquer ponto, o suficiente do fluxo
        <code>integers</code> foi gerado para que possamos alimentá-lo de volta
        na definição para produzir o próximo inteiro.
      </p>

      <p>Podemos definir os números de Fibonacci no mesmo estilo:</p>

      <pre><code class="language-scheme">(define fibs 
  (cons-stream 
   0 (cons-stream
      1 (add-streams 
         (stream-cdr fibs) fibs))))</code></pre>

      <p>
        Esta definição diz que <code>fibs</code> é um fluxo começando com 0 e 1,
        tal que o resto do fluxo pode ser gerado adicionando <code>fibs</code> a
        si mesmo deslocado por um lugar:
      </p>

      <div class="example">
        <pre
          class="example"
        >    1 1 2 3 5  8 13 21 <span class="roman">…</span> = <code>(stream-cdr fibs)</code>
    0 1 1 2 3  5  8 13 <span class="roman">…</span> = <code>fibs</code>
0 1 1 2 3 5 8 13 21 34 <span class="roman">…</span> = <code>fibs</code></pre>
      </div>

      <p>
        <code>Scale-stream</code> é outro procedimento útil na formulação de
        tais definições de fluxo. Isso multiplica cada item em um fluxo por uma
        constante dada:
      </p>

      <pre><code class="language-scheme">(define (scale-stream stream factor)
  (stream-map
   (lambda (x) (* x factor))
   stream))</code></pre>

      <p>Por exemplo,</p>

      <pre><code class="language-scheme">(define double 
  (cons-stream 1 (scale-stream double 2)))</code></pre>

      <p>produz o fluxo de potências de 2: 1, 2, 4, 8, 16, 32, ….</p>

      <p>
        Uma definição alternativa do fluxo de primos pode ser dada começando com
        os inteiros e filtrando-os testando para primalidade. Precisaremos do
        primeiro primo, 2, para começar:
      </p>

      <pre><code class="language-scheme">(define primes
  (cons-stream
   2 (stream-filter 
      prime? (integers-starting-from 3))))</code></pre>

      <p>
        Esta definição não é tão direta quanto parece, porque testaremos se um
        número
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> é
        primo verificando se
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> é
        divisível por um primo (não por qualquer inteiro) menor ou igual a
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><msqrt><mi>n</mi></msqrt></math
        >:
      </p>

      <pre><code class="language-scheme">(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))</code></pre>

      <p>
        Esta é uma definição recursiva, já que <code>primes</code> é definido em
        termos do predicado <code>prime?</code>, que por sua vez usa o fluxo
        <code>primes</code>. A razão pela qual este procedimento funciona é que,
        em qualquer ponto, o suficiente do fluxo <code>primes</code> foi gerado
        para testar a primalidade dos números que precisamos verificar a seguir.
        Ou seja, para cada
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> que
        testamos para primalidade, ou
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> não é
        primo (nesse caso, há um primo já gerado que o divide) ou
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> é
        primo (nesse caso, há um primo já gerado — ou seja, um primo menor que
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> — que
        é maior que
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><msqrt><mi>n</mi></msqrt></math
        >).<a class="footnote_link" id="DOCF191" href="#FOOT191"
          ><sup>191</sup></a
        >
      </p>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e53"></a>Exercício 3.53:</strong> Sem
          executar o programa, descreva os elementos do fluxo definido por:
        </p>
        <pre><code class="language-scheme">(define s (cons-stream 1 (add-streams s s)))</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e54"></a>Exercício 3.54:</strong> Defina
          um procedimento <code>mul-streams</code>, análogo a
          <code>add-streams</code>, que produz o produto elemento a elemento de
          seus dois fluxos de entrada. Use isso junto com o fluxo de
          <code>integers</code> para completar a seguinte definição do fluxo
          cujo
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><msup
              ><mi>n</mi
              ><mrow class="MJX-TeXAtom-ORD"><mtext>th</mtext></mrow></msup
            ></math
          >
          elemento (contando a partir de 0) é
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mrow class="MJX-TeXAtom-ORD"
              ><mi>n</mi><mo>+</mo><mn>1</mn></mrow
            ></math
          >
          fatorial:
        </p>
        <pre><code class="language-scheme">(define factorials 
  (cons-stream 1 (mul-streams ⟨??⟩ ⟨??⟩)))</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e55"></a>Exercício 3.55:</strong> Defina
          um procedimento <code>partial-sums</code> que toma como argumento um
          fluxo
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math> e
          retorna o fluxo cujos elementos são
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><msub><mi>S</mi><mn>0</mn></msub></math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mrow class="MJX-TeXAtom-ORD"
              ><msub><mi>S</mi><mn>0</mn></msub
              ><mo>+</mo><msub><mi>S</mi><mn>1</mn></msub></mrow
            ></math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mrow class="MJX-TeXAtom-ORD"
              ><msub><mi>S</mi><mn>0</mn></msub
              ><mo>+</mo><msub><mi>S</mi><mn>1</mn></msub></mrow
            ><mo>+</mo
            ><mrow class="MJX-TeXAtom-ORD"
              ><msub><mi>S</mi><mn>2</mn></msub
              ><mo>,</mo><mo>…<!-- … --></mo></mrow
            ></math
          >. Por exemplo, <code>(partial-sums integers)</code> deve ser o fluxo
          1, 3, 6, 10, 15, ….
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e56"></a>Exercício 3.56:</strong> Um
          famoso problema, levantado pela primeira vez por R. Hamming, é
          enumerar, em ordem crescente sem repetições, todos os inteiros
          positivos que não têm fatores primos além de 2, 3 ou 5. Uma maneira
          óbvia de fazer isso é simplesmente testar cada inteiro para ver se ele
          tem algum fator além de 2, 3 e 5. Mas isso é muito ineficiente, pois,
          à medida que os inteiros ficam maiores, menos e menos deles se
          encaixam no requisito. Como alternativa, vamos chamar o fluxo
          necessário de números <code>S</code> e observar os seguintes fatos
          sobre ele.
        </p>
        <ul>
          <li><code>S</code> começa com 1.</li>
          <li>
            Os elementos de <code>(scale-stream S 2)</code> também são elementos
            de <code>S</code>.
          </li>
          <li>
            O mesmo é verdade para <code>(scale-stream S 3)</code> e
            <code>(scale-stream S 5)</code>.
          </li>
          <li>Esses são todos os elementos de <code>S</code>.</li>
        </ul>

        <p>
          Agora, tudo o que temos que fazer é combinar elementos dessas fontes.
          Para isso, definimos um procedimento <code>merge</code> que combina
          dois fluxos ordenados em um fluxo de resultado ordenado, eliminando
          repetições:
        </p>
        <pre><code class="language-scheme">(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream 
                   s1car 
                   (merge (stream-cdr s1) 
                          s2)))
                 ((> s1car s2car)
                  (cons-stream 
                   s2car 
                   (merge s1 
                          (stream-cdr s2))))
                 (else
                  (cons-stream 
                   s1car
                   (merge 
                    (stream-cdr s1)
                    (stream-cdr s2)))))))))</code></pre>

        <p>
          Então, o fluxo necessário pode ser construído com <code>merge</code>,
          da seguinte forma:
        </p>
        <pre><code class="language-scheme">(define S (cons-stream 1 (merge ⟨??⟩ ⟨??⟩)))</code></pre>

        <p>
          Preencha as expressões ausentes nos lugares marcados
          <code>⟨??⟩</code> acima.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e57"></a>Exercício 3.57:</strong> Quantas
          adições são realizadas quando calculamos o
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><msup
              ><mi>n</mi
              ><mrow class="MJX-TeXAtom-ORD"><mtext>th</mtext></mrow></msup
            ></math
          >
          número de Fibonacci usando a definição de <code>fibs</code> baseada no
          procedimento <code>add-streams</code>? Mostre que o número de adições
          seria exponencialmente maior se tivéssemos implementado
          <code>(delay ⟨exp⟩)</code> simplesmente como
          <code>(lambda () ⟨exp⟩)</code>, sem usar a otimização fornecida pelo
          procedimento <code>memo-proc</code> descrito em
          <a href="#g_t3_002e5_002e1">3.5.1</a>.<a
            class="footnote_link"
            id="DOCF192"
            href="#FOOT192"
            ><sup>192</sup></a
          >
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e58"></a>Exercício 3.58:</strong> Dê uma
          interpretação do fluxo computado pelo seguinte procedimento:
        </p>
        <pre><code class="language-scheme">(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) 
           den 
           radix)))</code></pre>

        <p>
          (<code>Quotient</code> é um primitivo que retorna o quociente inteiro
          de dois inteiros.) Quais são os elementos sucessivos produzidos por
          <code>(expand 1 7 10)</code>? O que é produzido por
          <code>(expand 3 8 10)</code>?
        </p>
      </blockquote>
      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e59"></a>Exercício 3.59:</strong> Em
          <a href="2_002e5.html#g_t2_002e5_002e3">2.5.3</a> vimos como
          implementar um sistema de aritmética de polinômios representando
          polinômios como listas de termos. De maneira similar, podemos
          trabalhar com <a id="index-power-series"></a>
          <em>séries de potências</em>, como
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable
              columnalign="right center left"
              rowspacing="3pt"
              columnspacing="thickmathspace"
            >
              <mtr>
                <mtd>
                  <msup>
                    <mi>e</mi>
                    <mi>x</mi>
                  </msup>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mn>1</mn>
                  <mo>+</mo>
                  <mi>x</mi>
                  <mo>+</mo>
                  <mfrac>
                    <mn>1</mn>
                    <mn>2</mn>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>2</mn>
                  </msup>
                  <mo>+</mo>
                  <mfrac>
                    <mn>1</mn>
                    <mrow>
                      <mn>3</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>2</mn>
                    </mrow>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>3</mn>
                  </msup>
                  <mo>+</mo>
                  <mfrac>
                    <mn>1</mn>
                    <mrow>
                      <mn>4</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>3</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>2</mn>
                    </mrow>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>4</mn>
                  </msup>
                  <mo>+</mo>
                  <mo>…<!-- … --></mo>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mi>cos</mi>
                  <mo>⁡<!-- ⁡ --></mo>
                  <mi>x</mi>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mn>1</mn>
                  <mo>−<!-- − --></mo>
                  <mfrac>
                    <mn>1</mn>
                    <mn>2</mn>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>2</mn>
                  </msup>
                  <mo>+</mo>
                  <mfrac>
                    <mn>1</mn>
                    <mrow>
                      <mn>4</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>3</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>2</mn>
                    </mrow>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>4</mn>
                  </msup>
                  <mo>−<!-- − --></mo>
                  <mo>…<!-- … --></mo>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mi>sin</mi>
                  <mo>⁡<!-- ⁡ --></mo>
                  <mi>x</mi>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mi>x</mi>
                  <mo>−<!-- − --></mo>
                  <mfrac>
                    <mn>1</mn>
                    <mrow>
                      <mn>3</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>2</mn>
                    </mrow>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>3</mn>
                  </msup>
                  <mo>+</mo>
                  <mfrac>
                    <mn>1</mn>
                    <mrow>
                      <mn>5</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>4</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>3</mn>
                      <mo>⋅<!-- ⋅ --></mo>
                      <mn>2</mn>
                    </mrow>
                  </mfrac>
                  <msup>
                    <mi>x</mi>
                    <mn>5</mn>
                  </msup>
                  <mo>−<!-- − --></mo>
                  <mo>…<!-- … --></mo>
                </mtd>
              </mtr>
            </mtable>
          </math>
          representadas como fluxos infinitos. Representaremos a série
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub>
              <mo>+</mo>
              <msub>
                <mi>a</mi>
                <mn>1</mn>
              </msub>
              <mi>x</mi>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <msub>
                <mi>a</mi>
                <mn>2</mn>
              </msub>
              <msup>
                <mi>x</mi>
                <mn>2</mn>
              </msup>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <msub>
                <mi>a</mi>
                <mn>3</mn>
              </msub>
              <msup>
                <mi>x</mi>
                <mn>3</mn>
              </msup>
              <mo>+</mo>
              <mo>…<!-- … --></mo>
            </mrow>
          </math>
          como o fluxo cujos elementos são os coeficientes
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>a</mi>
              <mn>0</mn>
            </msub> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>a</mi>
              <mn>1</mn>
            </msub> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>a</mi>
              <mn>2</mn>
            </msub> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>a</mi>
              <mn>3</mn>
            </msub> </math
          >, ….
        </p>
        <ol>
          <li>
            A integral da série
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>+</mo>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mi>x</mi>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <msup>
                  <mi>x</mi>
                  <mn>2</mn>
                </msup>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>a</mi>
                  <mn>3</mn>
                </msub>
                <msup>
                  <mi>x</mi>
                  <mn>3</mn>
                </msup>
                <mo>+</mo>
                <mo>…<!-- … --></mo>
              </mrow>
            </math>
            é a série
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
              <mi>c</mi>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mi>x</mi>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <mn>1</mn>
                  <mn>2</mn>
                </mfrac>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <msup>
                  <mi>x</mi>
                  <mn>2</mn>
                </msup>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <mn>1</mn>
                  <mn>3</mn>
                </mfrac>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <msup>
                  <mi>x</mi>
                  <mn>3</mn>
                </msup>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <mn>1</mn>
                  <mn>4</mn>
                </mfrac>
                <msub>
                  <mi>a</mi>
                  <mn>3</mn>
                </msub>
                <msup>
                  <mi>x</mi>
                  <mn>4</mn>
                </msup>
                <mo>+</mo>
                <mo>…<!-- … --></mo>
                <mo>,</mo>
              </mrow>
            </math>
            onde
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>c</mi>
            </math>
            é qualquer constante. Defina um procedimento
            <code>integrate-series</code> que recebe como entrada um fluxo
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub> </math
            >,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mn>1</mn>
              </msub> </math
            >,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mn>2</mn>
              </msub> </math
            >, … representando uma série de potências e retorna o fluxo
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub> </math
            >,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mrow class="MJX-TeXAtom-ORD">
                  <mfrac>
                    <mn>1</mn>
                    <mn>2</mn>
                  </mfrac>
                </mrow>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
              </mrow> </math
            >,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mrow class="MJX-TeXAtom-ORD">
                  <mfrac>
                    <mn>1</mn>
                    <mn>3</mn>
                  </mfrac>
                </mrow>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
              </mrow> </math
            >, … de coeficientes dos termos não constantes da integral da série.
            (Como o resultado não tem termo constante, ele não representa uma
            série de potências; quando usamos <code>integrate-series</code>,
            vamos <code>cons</code> na constante apropriada.)
          </li>
          <li>
            A função
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>x</mi>
                <mo stretchy="false">↦<!-- ↦ --></mo>
                <msup>
                  <mi>e</mi>
                  <mi>x</mi>
                </msup>
              </mrow>
            </math>
            é sua própria derivada. Isso implica que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mi>e</mi>
                <mi>x</mi>
              </msup>
            </math>
            e a integral de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mi>e</mi>
                <mi>x</mi>
              </msup>
            </math>
            são a mesma série, exceto pelo termo constante, que é
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msup>
                  <mi>e</mi>
                  <mn>0</mn>
                </msup>
                <mo>=</mo>
                <mn>1</mn>
              </mrow> </math
            >. Assim, podemos gerar a série para
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mi>e</mi>
                <mi>x</mi>
              </msup>
            </math>
            como

            <pre><code class="language-scheme">(define exp-series
            (cons-stream 
             1 (integrate-series exp-series)))</code></pre>

            <p>
              Mostre como gerar as séries para seno e cosseno, começando dos
              fatos que a derivada do seno é o cosseno e a derivada do cosseno é
              o negativo do seno:
            </p>
            <pre><code class="language-scheme">(define cosine-series 
            (cons-stream 1 ⟨??⟩))
          
          (define sine-series
            (cons-stream 0 ⟨??⟩))</code></pre>
          </li>
        </ol>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e60"></a>Exercício 3.60:</strong> Com
          séries de potências representadas como fluxos de coeficientes como em
          <a href="#Exercise-3_002e59">Exercício 3.59</a>, adicionar séries é
          implementado por <code>add-streams</code>. Complete a definição do
          seguinte procedimento para multiplicar séries:
        </p>
        <pre><code class="language-scheme">(define (mul-series s1 s2)
            (cons-stream ⟨??⟩ (add-streams ⟨??⟩ ⟨??⟩)))</code></pre>

        <p>
          Você pode testar seu procedimento verificando que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>sin</mi>
                <mn>2</mn>
              </msup>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>x</mi>
              <mo>+</mo>
              <msup>
                <mi>cos</mi>
                <mn>2</mn>
              </msup>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>x</mi>
              <mo>=</mo>
              <mn>1</mn>
              <mo>,</mo>
            </mrow>
          </math>
          usando as séries de <a href="#Exercise-3_002e59">Exercício 3.59</a>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e61"></a>Exercício 3.61:</strong> Seja
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>S</mi>
          </math>
          uma série de potências (<a href="#Exercise-3_002e59">Exercício 3.59</a
          >) cujo termo constante é 1. Suponha que queremos encontrar a série de
          potências
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mn>1</mn>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>S</mi>
            </mrow> </math
          >, isto é, a série
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>X</mi>
          </math>
          tal que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>S</mi>
              <mi>X</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow> </math
          >. Escreva
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>S</mi>
              <mo>=</mo>
              <mn>1</mn>
              <mo>+</mo>
              <msub>
                <mi>S</mi>
                <mi>R</mi>
              </msub>
            </mrow>
          </math>
          onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>S</mi>
              <mi>R</mi>
            </msub>
          </math>
          é a parte de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>S</mi>
          </math>
          após o termo constante. Então podemos resolver para
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>X</mi>
          </math>
          da seguinte forma:
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable
              columnalign="right center left"
              rowspacing="3pt"
              columnspacing="thickmathspace"
            >
              <mtr>
                <mtd>
                  <mi>S</mi>
                  <mo>⋅<!-- ⋅ --></mo>
                  <mi>X</mi>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mn>1</mn>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mo stretchy="false">(</mo>
                  <mn>1</mn>
                  <mo>+</mo>
                  <msub>
                    <mi>S</mi>
                    <mi>R</mi>
                  </msub>
                  <mo stretchy="false">)</mo>
                  <mo>⋅<!-- ⋅ --></mo>
                  <mi>X</mi>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mn>1</mn>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mi>X</mi>
                  <mo>+</mo>
                  <msub>
                    <mi>S</mi>
                    <mi>R</mi>
                  </msub>
                  <mo>⋅<!-- ⋅ --></mo>
                  <mi>X</mi>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mn>1</mn>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mi>X</mi>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mn>1</mn>
                  <mo>−<!-- − --></mo>
                  <msub>
                    <mi>S</mi>
                    <mi>R</mi>
                  </msub>
                  <mo>⋅<!-- ⋅ --></mo>
                  <mi>X</mi>
                  <mo>.</mo>
                </mtd>
              </mtr>
            </mtable>
          </math>
          Em outras palavras,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>X</mi>
          </math>
          é a série de potências cujo termo constante é 1 e cujos termos de
          ordem superior são dados pelo negativo de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>S</mi>
              <mi>R</mi>
            </msub>
          </math>
          vezes
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>X</mi> </math
          >. Use essa ideia para escrever um procedimento
          <code>invert-unit-series</code> que calcula
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mn>1</mn>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>S</mi>
            </mrow>
          </math>
          para uma série de potências
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>S</mi>
          </math>
          com termo constante 1. Você precisará usar <code>mul-series</code> de
          <a href="#Exercise-3_002e60">Exercício 3.60</a>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e62"></a>Exercício 3.62:</strong> Use os
          resultados de <a href="#Exercise-3_002e60">Exercício 3.60</a> e
          <a href="#Exercise-3_002e61">Exercício 3.61</a> para definir um
          procedimento <code>div-series</code> que divide duas séries de
          potências. <code>Div-series</code> deve funcionar para quaisquer duas
          séries, desde que a série do denominador comece com um termo constante
          diferente de zero. (Se o denominador tiver um termo constante zero,
          então <code>div-series</code> deve sinalizar um erro.) Mostre como
          usar <code>div-series</code> junto com o resultado de
          <a href="#Exercise-3_002e59">Exercício 3.59</a> para gerar a série de
          potências para a tangente.
        </p>
      </blockquote>

      <a id="g_t3_002e5_002e3"></a>
      <a id="Exploiting-the-Stream-Paradigm"></a>
      <h4 class="subsection">
        <span class="secnum">3.5.3</span
        ><span class="sectitle">Explorando o Paradigma de Fluxos</span>
      </h4>

      <p>
        Fluxos com avaliação atrasada podem ser uma ferramenta poderosa de
        modelagem, fornecendo muitos dos benefícios do estado local e da
        atribuição. Além disso, eles evitam alguns dos emaranhados teóricos que
        acompanham a introdução da atribuição em uma linguagem de programação.
      </p>
      <p>
        A abordagem de fluxos pode ser esclarecedora porque nos permite
        construir sistemas com diferentes limites de módulos do que sistemas
        organizados em torno da atribuição a variáveis de estado. Por exemplo,
        podemos pensar em uma série temporal inteira (ou sinal) como um foco de
        interesse, em vez dos valores das variáveis de estado em momentos
        individuais. Isso torna conveniente combinar e comparar componentes de
        estado de diferentes momentos.
      </p>
      <a id="Formulating-iterations-as-stream-processes"></a>
      <h5 class="subsubheading">
        Formulando iterações como processos de fluxo
      </h5>

      <p>
        Na seção <a href="1_002e2.html#g_t1_002e2_002e1">1.2.1</a>,
        introduzimos processos iterativos, que prosseguem atualizando variáveis
        de estado. Sabemos agora que podemos representar o estado como um fluxo
        "atemporal" de valores, em vez de como um conjunto de variáveis a serem
        atualizadas. Vamos adotar essa perspectiva ao revisitar o procedimento
        de raiz quadrada de <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a>.
        Lembre-se de que a ideia é gerar uma sequência de melhores e melhores
        palpites para a raiz quadrada de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        aplicando repetidamente o procedimento que melhora os palpites:
      </p>
      <pre><code class="language-scheme">(define (sqrt-improve guess x)
            (average guess (/ x guess)))</code></pre>

      <p>
        Em nosso procedimento <code>sqrt</code> original, fizemos esses palpites
        serem os valores sucessivos de uma variável de estado. Em vez disso,
        podemos gerar o fluxo infinito de palpites, começando com um palpite
        inicial de 1:<a class="footnote_link" id="DOCF193" href="#FOOT193"
          ><sup>193</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (sqrt-stream x)
            (define guesses
              (cons-stream 
               1.0 (stream-map
                    (lambda (guess)
                      (sqrt-improve guess x))
                    guesses)))
            guesses)
          
          (display-stream (sqrt-stream 2))
          1.
          1.5
          1.4166666666666665
          1.4142156862745097
          1.4142135623746899
          …
          </code></pre>

      <p>
        Podemos gerar mais e mais termos do fluxo para obter palpites cada vez
        melhores. Se quisermos, podemos escrever um procedimento que continua
        gerando termos até que a resposta seja boa o suficiente. (Veja
        <a href="#Exercise-3_002e64">Exercício 3.64</a>.)
      </p>
      <p>
        Outra iteração que podemos tratar da mesma forma é gerar uma aproximação
        para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >, baseada na série alternada que vimos em
        <a href="1_002e3.html#g_t1_002e3_002e1">1.3.1</a>:
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mi>π<!-- π --></mi>
              <mn>4</mn>
            </mfrac>
          </mrow>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mn>1</mn>
          <mo>−<!-- − --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mn>1</mn>
              <mn>3</mn>
            </mfrac>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mn>1</mn>
              <mn>5</mn>
            </mfrac>
          </mrow>
          <mo>−<!-- − --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mn>1</mn>
              <mn>7</mn>
            </mfrac>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mo>…<!-- … --></mo>
            <mo>.</mo>
          </mrow>
        </math>
        Primeiro geramos o fluxo de termos da série (os recíprocos dos inteiros
        ímpares, com sinais alternados). Então pegamos o fluxo de somas de mais
        e mais termos (usando o procedimento <code>partial-sums</code> de
        <a href="#Exercise-3_002e55">Exercício 3.55</a>) e escalamos o resultado
        por 4:
      </p>
      <pre><code class="language-scheme">(define (pi-summands n)
            (cons-stream 
             (/ 1.0 n)
             (stream-map - (pi-summands (+ n 2)))))
          
          (define pi-stream
            (scale-stream 
             (partial-sums (pi-summands 1)) 4))
          
          (display-stream pi-stream)
          4.
          2.666666666666667
          3.466666666666667
          2.8952380952380956
          3.3396825396825403
          2.9760461760461765
          3.2837384837384844
          3.017071817071818
          …
          </code></pre>

      <p>
        Isso nos dá um fluxo de aproximações cada vez melhores para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >, embora as aproximações convirjam de forma bastante lenta. Oito termos
        da sequência limitam o valor de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi>
        </math>
        entre 3.284 e 3.017.
      </p>
      <p>
        Até agora, nosso uso da abordagem de fluxo de estados não é muito
        diferente de atualizar variáveis de estado. Mas os fluxos nos dão a
        oportunidade de fazer alguns truques interessantes. Por exemplo, podemos
        transformar um fluxo com um
        <a id="index-sequence-accelerator"></a>
        <em>acelerador de sequência</em> que converte uma sequência de
        aproximações em uma nova sequência que converge para o mesmo valor que a
        original, só que mais rápido.
      </p>
      <p>
        Um desses aceleradores, devido ao matemático suíço do século XVIII
        Leonhard Euler, funciona bem com sequências que são somas parciais de
        séries alternadas (séries de termos com sinais alternados). Na técnica
        de Euler, se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>S</mi>
            <mi>n</mi>
          </msub>
        </math>
        é o
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>n</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mtext>th</mtext>
            </mrow>
          </msup>
        </math>
        termo da sequência de soma original, então a sequência acelerada tem
        termos
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <msub>
            <mi>S</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>−<!-- − --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mrow>
                  <mo stretchy="false">(</mo>
                  <msub>
                    <mi>S</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>n</mi>
                      <mo>+</mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                  <mo>−<!-- − --></mo>
                  <msub>
                    <mi>S</mi>
                    <mi>n</mi>
                  </msub>
                  <msup>
                    <mo stretchy="false">)</mo>
                    <mn>2</mn>
                  </msup>
                </mrow>
                <mrow>
                  <msub>
                    <mi>S</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>n</mi>
                      <mo>−<!-- − --></mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                  <mo>−<!-- − --></mo>
                  <mn>2</mn>
                  <msub>
                    <mi>S</mi>
                    <mi>n</mi>
                  </msub>
                  <mo>+</mo>
                  <msub>
                    <mi>S</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>n</mi>
                      <mo>+</mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                </mrow>
              </mfrac>
            </mrow>
            <mo>.</mo>
          </mrow>
        </math>
        Assim, se a sequência original é representada como um fluxo de valores,
        a sequência transformada é dada por
      </p>
      <pre><code class="language-scheme">(define (euler-transform s)
            (let ((s0 (stream-ref s 0))     ; Sₙ₋₁
                  (s1 (stream-ref s 1))     ; Sₙ
                  (s2 (stream-ref s 2)))    ; Sₙ₊₁
              (cons-stream 
               (- s2 (/ (square (- s2 s1))
                        (+ s0 (* -2 s1) s2)))
               (euler-transform (stream-cdr s)))))</code></pre>

      <p>
        Podemos demonstrar a aceleração de Euler com nossa sequência de
        aproximações para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >:
      </p>
      <pre><code class="language-scheme">(display-stream 
           (euler-transform pi-stream))
          3.166666666666667
          3.1333333333333337
          3.1452380952380956
          3.13968253968254
          3.1427128427128435
          3.1408813408813416
          3.142071817071818
          3.1412548236077655
          …
          </code></pre>

      <p>
        Podemos até acelerar a sequência acelerada, e recursivamente acelerar
        essa, e assim por diante. Ou seja, criamos um fluxo de fluxos (uma
        estrutura que chamaremos de <a id="index-tableau"></a> <em>tableau</em>)
        em que cada fluxo é a transformação do precedente:
      </p>
      <pre><code class="language-scheme">(define (make-tableau transform s)
            (cons-stream 
             s
             (make-tableau
              transform
              (transform s))))</code></pre>

      <p>
        O tableau tem a forma
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable
            columnalign="center center center center center center"
            rowspacing="4pt"
            columnspacing="1em"
          >
            <mtr>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>00</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>01</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>02</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>03</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>04</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>10</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>11</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>12</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>13</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd />
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>20</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>21</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <msub>
                  <mi>s</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mn>22</mn>
                  </mrow>
                </msub>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd />
              <mtd />
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
              <mtd />
              <mtd />
            </mtr>
          </mtable>
        </math>
        Finalmente, formamos uma sequência tomando o primeiro termo em cada
        linha do tableau:
      </p>
      <pre><code class="language-scheme">(define (accelerated-sequence transform s)
            (stream-map stream-car
                        (make-tableau transform s)))</code></pre>

      <p>
        Podemos demonstrar esse tipo de "super-aceleração" da sequência de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >:
      </p>
      <pre><code class="language-scheme">(display-stream 
           (accelerated-sequence euler-transform
                                 pi-stream))
          4.
          3.166666666666667
          3.142105263157895
          3.141599357319005
          3.1415927140337785
          3.1415926539752927
          3.1415926535911765
          3.141592653589778
          …
          </code></pre>

      <p>
        O resultado é impressionante. Tomando oito termos da sequência, obtemos
        o valor correto de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi>
        </math>
        com 14 casas decimais. Se tivéssemos usado apenas a sequência original
        de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >, precisaríamos calcular da ordem de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mn>10</mn>
            <mrow class="MJX-TeXAtom-ORD">
              <mn>13</mn>
            </mrow>
          </msup>
        </math>
        termos (ou seja, expandindo a série o suficiente para que os termos
        individuais sejam menores que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mn>10</mn>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>−<!-- − --></mo>
              <mn>13</mn>
            </mrow>
          </msup> </math
        >) para obter essa precisão!
      </p>
      <p>
        Poderíamos ter implementado essas técnicas de aceleração sem usar
        fluxos. Mas a formulação de fluxos é particularmente elegante e
        conveniente porque a sequência inteira de estados está disponível para
        nós como uma estrutura de dados que pode ser manipulada com um conjunto
        uniforme de operações.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e63"></a>Exercício 3.63:</strong> Louis
          Reasoner pergunta por que o procedimento <code>sqrt-stream</code> não
          foi escrito da seguinte forma mais direta, sem a variável local
          <code>guesses</code>:
        </p>
        <pre><code class="language-scheme">(define (sqrt-stream x)
            (cons-stream 
             1.0
             (stream-map (lambda (guess)
                           (sqrt-improve guess x))
                         (sqrt-stream x))))</code></pre>

        <p>
          Alyssa P. Hacker responde que esta versão do procedimento é
          consideravelmente menos eficiente porque realiza computação
          redundante. Explique a resposta de Alyssa. As duas versões ainda
          difeririam em eficiência se nossa implementação de
          <code>delay</code> usasse apenas
          <code>(lambda () ⟨<var>exp</var>⟩)</code> sem usar a otimização
          fornecida por <code>memo-proc</code> (<a href="#g_t3_002e5_002e1"
            >3.5.1</a
          >)?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e64"></a>Exercício 3.64:</strong> Escreva
          um procedimento <code>stream-limit</code> que recebe como argumentos
          um fluxo e um número (a tolerância). Ele deve examinar o fluxo até
          encontrar dois elementos sucessivos que diferem em valor absoluto por
          menos que a tolerância e retornar o segundo dos dois elementos. Usando
          isso, poderíamos calcular raízes quadradas até uma dada tolerância por
        </p>
        <pre><code class="language-scheme">(define (sqrt x tolerance)
            (stream-limit (sqrt-stream x) tolerance))</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e65"></a>Exercício 3.65:</strong> Use a
          série
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mi>ln</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mn>2</mn>
            <mspace width="thinmathspace" />
            <mo>=</mo>
            <mspace width="thinmathspace" />
            <mn>1</mn>
            <mo>−<!-- − --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mn>2</mn>
              </mfrac>
            </mrow>
            <mo>+</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mn>3</mn>
              </mfrac>
            </mrow>
            <mo>−<!-- − --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mn>4</mn>
              </mfrac>
            </mrow>
            <mo>+</mo>
            <mo>…<!-- … --></mo>
          </math>
          para calcular três sequências de aproximações para o logaritmo natural
          de 2, da mesma forma que fizemos acima para
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>π<!-- π --></mi> </math
          >. Quão rapidamente essas sequências convergem?
        </p>
      </blockquote>

      <a id="Infinite-streams-of-pairs"></a>
      <h5 class="subsubheading">Fluxos infinitos de pares</h5>

      <p>
        Em <a href="2_002e2.html#g_t2_002e2_002e3">2.2.3</a>, vimos como o
        paradigma de sequência lida com loops aninhados tradicionais como
        processos definidos em sequências de pares. Se generalizarmos essa
        técnica para fluxos infinitos, então podemos escrever programas que não
        são facilmente representados como loops, porque o "looping" deve variar
        sobre um conjunto infinito.
      </p>
      <p>
        Por exemplo, suponha que queremos generalizar o procedimento
        <code>prime-sum-pairs</code> de
        <a href="2_002e2.html#g_t2_002e2_002e3">2.2.3</a> para produzir o fluxo
        de pares de <em>todos</em> os inteiros
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        com
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>≤<!-- ≤ --></mo>
            <mi>j</mi>
          </mrow>
        </math>
        tal que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>+</mo>
            <mi>j</mi>
          </mrow>
        </math>
        é primo. Se <code>int-pairs</code> é a sequência de todos os pares de
        inteiros
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        com
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>≤<!-- ≤ --></mo>
            <mi>j</mi>
          </mrow> </math
        >, então o fluxo necessário é simplesmente<a
          class="footnote_link"
          id="DOCF194"
          href="#FOOT194"
          ><sup>194</sup></a
        >
      </p>
      <pre><code class="language-scheme">(stream-filter 
           (lambda (pair)
             (prime? (+ (car pair) (cadr pair))))
           int-pairs)</code></pre>

      <p>
        Nosso problema, então, é produzir o fluxo <code>int-pairs</code>. Mais
        geralmente, suponha que temos dois fluxos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>S</mi>
            <mo>=</mo>
            <mo stretchy="false">(</mo>
            <msub>
              <mi>S</mi>
              <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>T</mi>
            <mo>=</mo>
            <mo stretchy="false">(</mo>
            <msub>
              <mi>T</mi>
              <mi>j</mi>
            </msub>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, e imagine o array retangular infinito
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable
            columnalign="center center center center"
            rowspacing="4pt"
            columnspacing="1em"
          >
            <mtr>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>0</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>0</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>0</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
              <mtd />
              <mtd />
              <mtd />
            </mtr>
          </mtable>
        </math>
        Queremos gerar um fluxo que contenha todos os pares no array que estão
        na diagonal ou acima dela, ou seja, os pares
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable
            columnalign="center center center center"
            rowspacing="4pt"
            columnspacing="1em"
          >
            <mtr>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>0</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd />
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd />
              <mtd />
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
          </mtable>
        </math>
        (Se tomarmos ambos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>S</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>T</mi>
        </math>
        como o fluxo de inteiros, então isso será nosso fluxo desejado
        <code>int-pairs</code>.)
      </p>
      <p>
        Chame o fluxo geral de pares <code>(pairs S T)</code>, e considere que
        ele é composto de três partes: o par
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <msub>
              <mi>S</mi>
              <mn>0</mn>
            </msub>
            <mo>,</mo>
            <msub>
              <mi>T</mi>
              <mn>0</mn>
            </msub>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, o resto dos pares na primeira linha, e os pares restantes:<a
          class="footnote_link"
          id="DOCF195"
          href="#FOOT195"
          ><sup>195</sup></a
        >
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mtable
            columnalign="center center center center"
            rowspacing="4pt"
            columnspacing="1em"
            rowlines="solid none"
            columnlines="solid none none"
          >
            <mtr>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>0</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>0</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>1</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd />
              <mtd>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>S</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>T</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd />
              <mtd />
              <mtd />
              <mtd>
                <mo>…<!-- … --></mo>
              </mtd>
            </mtr>
          </mtable>
        </math>
        Observe que a terceira peça nesta decomposição (pares que não estão na
        primeira linha) é (recursivamente) os pares formados a partir de
        <code>(stream-cdr S)</code> e <code>(stream-cdr T)</code>. Além disso,
        note que a segunda peça (o resto da primeira linha) é
      </p>
      <pre><code class="language-scheme">(stream-map (lambda (x) 
                        (list (stream-car s) x))
                      (stream-cdr t))</code></pre>

      <p>Assim, podemos formar nosso fluxo de pares da seguinte forma:</p>
      <pre><code class="language-scheme">(define (pairs s t)
            (cons-stream
             (list (stream-car s) (stream-car t))
             (⟨combine-in-some-way⟩
              (stream-map (lambda (x) 
                            (list (stream-car s) x))
                          (stream-cdr t))
              (pairs (stream-cdr s)
                     (stream-cdr t)))))</code></pre>

      <p>
        Para completar o procedimento, devemos escolher alguma forma de combinar
        os dois fluxos internos. Uma ideia é usar o análogo de fluxo do
        procedimento <code>append</code> de
        <a href="2_002e2.html#g_t2_002e2_002e1">2.2.1</a>:
      </p>
      <pre><code class="language-scheme">(define (stream-append s1 s2)
            (if (stream-null? s1)
                s2
                (cons-stream 
                 (stream-car s1)
                 (stream-append (stream-cdr s1) s2))))</code></pre>

      <p>
        Isso é inadequado para fluxos infinitos, no entanto, porque ele pega
        todos os elementos do primeiro fluxo antes de incorporar o segundo
        fluxo. Em particular, se tentarmos gerar todos os pares de inteiros
        positivos usando
      </p>
      <pre><code class="language-scheme">(pairs integers integers)</code></pre>

      <p>
        nosso fluxo de resultados primeiro tentará percorrer todos os pares com
        o primeiro inteiro igual a 1 e, portanto, nunca produzirá pares com
        qualquer outro valor do primeiro inteiro.
      </p>
      <p>
        Para lidar com fluxos infinitos, precisamos elaborar uma ordem de
        combinação que garanta que cada elemento será eventualmente alcançado se
        deixarmos nosso programa rodar o tempo suficiente. Uma maneira elegante
        de realizar isso é com o seguinte procedimento
        <code>interleave</code>:<a
          class="footnote_link"
          id="DOCF196"
          href="#FOOT196"
          ><sup>196</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (interleave s1 s2)
            (if (stream-null? s1)
                s2
                (cons-stream 
                 (stream-car s1)
                 (interleave s2 (stream-cdr s1)))))</code></pre>

      <p>
        Como <code>interleave</code> pega elementos alternadamente dos dois
        fluxos, todo elemento do segundo fluxo eventualmente encontrará seu
        caminho no fluxo intercalado, mesmo que o primeiro fluxo seja infinito.
      </p>
      <p>Podemos, portanto, gerar o fluxo necessário de pares como</p>
      <pre><code class="language-scheme">(define (pairs s t)
            (cons-stream
             (list (stream-car s) (stream-car t))
             (interleave
              (stream-map (lambda (x) 
                            (list (stream-car s) x))
                          (stream-cdr t))
              (pairs (stream-cdr s) (stream-cdr t)))))</code></pre>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e66"></a>Exercício 3.66:</strong> Examine
          o fluxo <code>(pairs integers integers)</code>. Você pode fazer algum
          comentário geral sobre a ordem em que os pares são colocados no fluxo?
          Por exemplo, aproximadamente quantos pares precedem o par (1, 100)? o
          par (99, 100)? o par (100, 100)? (Se você puder fazer afirmações
          matemáticas precisas aqui, tanto melhor. Mas sinta-se à vontade para
          dar respostas mais qualitativas se você se sentir sobrecarregado.)
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e67"></a>Exercício 3.67:</strong>
          Modifique o procedimento <code>pairs</code> para que
          <code>(pairs integers integers)</code> produza o fluxo de
          <em>todos</em> os pares de inteiros
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo>,</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          (sem a condição
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>i</mi>
              <mo>≤<!-- ≤ --></mo>
              <mi>j</mi>
            </mrow> </math
          >). Dica: Você precisará misturar um fluxo adicional.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e68"></a>Exercício 3.68:</strong> Louis
          Reasoner pensa que construir um fluxo de pares a partir de três partes
          é desnecessariamente complicado. Em vez de separar o par
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msub>
                <mi>S</mi>
                <mn>0</mn>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>T</mi>
                <mn>0</mn>
              </msub>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          do resto dos pares na primeira linha, ele propõe trabalhar com a
          primeira linha inteira, da seguinte forma:
        </p>
        <pre><code class="language-scheme">(define (pairs s t)
            (interleave
             (stream-map
              (lambda (x) 
                (list (stream-car s) x))
              t)
             (pairs (stream-cdr s)
                    (stream-cdr t))))</code></pre>

        <p>
          Isso funciona? Considere o que acontece se avaliamos
          <code>(pairs integers integers)</code> usando a definição de
          <code>pairs</code> de Louis.
        </p>
      </blockquote>
      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e69"></a>Exercício 3.69:</strong> Escreva
          um procedimento <code>triples</code> que recebe três fluxos infinitos,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>S</mi> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>T</mi> </math
          >, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>U</mi> </math
          >, e produz o fluxo de triplas
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msub>
                <mi>S</mi>
                <mi>i</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>T</mi>
                <mi>j</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>U</mi>
                <mi>k</mi>
              </msub>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          tal que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>i</mi>
              <mo>≤<!-- ≤ --></mo>
              <mi>j</mi>
              <mo>≤<!-- ≤ --></mo>
              <mi>k</mi>
            </mrow> </math
          >. Use <code>triples</code> para gerar o fluxo de todas as triplas
          pitagóricas de inteiros positivos, ou seja, as triplas
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo>,</mo>
              <mi>j</mi>
              <mo>,</mo>
              <mi>k</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          tais que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>i</mi>
              <mo>≤<!-- ≤ --></mo>
              <mi>j</mi>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>i</mi>
                <mn>2</mn>
              </msup>
              <mo>+</mo>
              <msup>
                <mi>j</mi>
                <mn>2</mn>
              </msup>
              <mo>=</mo>
              <msup>
                <mi>k</mi>
                <mn>2</mn>
              </msup>
            </mrow> </math
          >.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e70"></a>Exercício 3.70:</strong> Seria
          bom poder gerar fluxos em que os pares aparecem em alguma ordem útil,
          em vez de na ordem que resulta de um processo de intercalação
          <em>ad hoc</em>. Podemos usar uma técnica semelhante ao procedimento
          <code>merge</code> do <a href="#Exercise-3_002e56">Exercício 3.56</a>,
          se definirmos uma maneira de dizer que um par de inteiros é “menor
          que” outro. Uma maneira de fazer isso é definir uma “função de
          ponderação”
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>W</mi>
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo>,</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          e estipular que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>j</mi>
                <mn>1</mn>
              </msub>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          é menor que
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>j</mi>
                <mn>2</mn>
              </msub>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>W</mi>
              <mo stretchy="false">(</mo>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>j</mi>
                <mn>1</mn>
              </msub>
              <mo stretchy="false">)</mo>
              <mo>&lt;</mo>
            </mrow>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>W</mi>
              <mo stretchy="false">(</mo>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>j</mi>
                <mn>2</mn>
              </msub>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. Escreva um procedimento <code>merge-weighted</code> que é
          semelhante a <code>merge</code>, exceto que
          <code>merge-weighted</code> recebe um argumento adicional
          <code>weight</code>, que é um procedimento que calcula o peso de um
          par, e é usado para determinar a ordem em que os elementos devem
          aparecer no fluxo resultante.<a
            class="footnote_link"
            id="DOCF197"
            href="#FOOT197"
            ><sup>197</sup></a
          >
          Usando isso, generalize <code>pairs</code> para um procedimento
          <code>weighted-pairs</code> que recebe dois fluxos, junto com um
          procedimento que calcula uma função de ponderação, e gera o fluxo de
          pares, ordenados de acordo com o peso. Use seu procedimento para gerar
        </p>
        <ol>
          <li>
            o fluxo de todos os pares de inteiros positivos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">)</mo>
              </mrow>
            </math>
            com
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>i</mi>
                <mo>≤<!-- ≤ --></mo>
                <mi>j</mi>
              </mrow>
            </math>
            ordenados de acordo com a soma
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>i</mi>
                <mo>+</mo>
                <mi>j</mi>
              </mrow> </math
            >,
          </li>
          <li>
            o fluxo de todos os pares de inteiros positivos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">)</mo>
              </mrow>
            </math>
            com
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>i</mi>
                <mo>≤<!-- ≤ --></mo>
                <mi>j</mi>
              </mrow> </math
            >, onde nem
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>i</mi>
            </math>
            nem
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>j</mi>
            </math>
            é divisível por 2, 3 ou 5, e os pares são ordenados de acordo com a
            soma
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mn>2</mn>
                <mi>i</mi>
                <mo>+</mo>
                <mn>3</mn>
                <mi>j</mi>
                <mo>+</mo>
                <mn>5</mn>
                <mi>i</mi>
                <mi>j</mi>
              </mrow> </math
            >.
          </li>
        </ol>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e71"></a>Exercício 3.71:</strong> Números
          que podem ser expressos como a soma de dois cubos de mais de uma
          maneira são às vezes chamados de
          <a id="index-Ramanujan-numbers"></a>
          <em>números de Ramanujan</em>, em homenagem ao matemático Srinivasa
          Ramanujan.<a class="footnote_link" id="DOCF198" href="#FOOT198"
            ><sup>198</sup></a
          >
          Fluxos ordenados de pares fornecem uma solução elegante para o
          problema de calcular esses números. Para encontrar um número que pode
          ser escrito como a soma de dois cubos de duas maneiras diferentes,
          precisamos apenas gerar o fluxo de pares de inteiros
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo>,</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          ponderados de acordo com a soma
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>i</mi>
                <mn>3</mn>
              </msup>
              <mo>+</mo>
              <msup>
                <mi>j</mi>
                <mn>3</mn>
              </msup>
            </mrow>
          </math>
          (veja <a href="#Exercise-3_002e70">Exercício 3.70</a>), então procure
          no fluxo por dois pares consecutivos com o mesmo peso. Escreva um
          procedimento para gerar os números de Ramanujan. O primeiro desses
          números é 1,729. Quais são os próximos cinco?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e72"></a>Exercício 3.72:</strong> De
          maneira semelhante ao <a href="#Exercise-3_002e71">Exercício 3.71</a>,
          gere um fluxo de todos os números que podem ser escritos como a soma
          de dois quadrados de três maneiras diferentes (mostrando como eles
          podem ser escritos dessa forma).
        </p>
      </blockquote>

      <a id="Streams-as-signals"></a>
      <h5 class="subsubheading">Fluxos como sinais</h5>

      <p>
        Começamos nossa discussão sobre fluxos descrevendo-os como análogos
        computacionais dos “sinais” em sistemas de processamento de sinais. Na
        verdade, podemos usar fluxos para modelar sistemas de processamento de
        sinais de maneira muito direta, representando os valores de um sinal em
        intervalos de tempo sucessivos como elementos consecutivos de um fluxo.
        Por exemplo, podemos implementar um <a id="index-integrator"></a>
        <em>integrador</em> ou
        <a id="index-summer"></a>
        <em>somador</em> que, para um fluxo de entrada
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mo>=</mo>
            <mo stretchy="false">(</mo>
            <msub>
              <mi>x</mi>
              <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, um valor inicial
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>C</mi> </math
        >, e um pequeno incremento
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>t</mi>
          </mrow> </math
        >, acumula a soma
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <msub>
            <mi>S</mi>
            <mi>i</mi>
          </msub>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mi>C</mi>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <munderover>
              <mo>∑<!-- ∑ --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>i</mi>
            </munderover>
            <msub>
              <mi>x</mi>
              <mi>j</mi>
            </msub>
            <mspace width="thinmathspace" />
            <mi>d</mi>
            <mi>t</mi>
          </mrow>
        </math>
        e retorna o fluxo de valores
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>S</mi>
            <mo>=</mo>
            <mo stretchy="false">(</mo>
            <msub>
              <mi>S</mi>
              <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. O seguinte procedimento <code>integral</code> é reminiscente da
        definição de “estilo implícito” do fluxo de inteiros (<a
          href="#g_t3_002e5_002e2"
          >3.5.2</a
        >):
      </p>
      <pre><code class="language-scheme">(define (integral integrand initial-value dt)
              (define int
                (cons-stream 
                 initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
              int)</code></pre>

      <p>
        <a href="#Figure-3_002e32">Figura 3.32</a> é uma imagem de um sistema de
        processamento de sinais que corresponde ao procedimento
        <code>integral</code>. O fluxo de entrada é escalado por
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>t</mi>
          </mrow>
        </math>
        e passado por um somador, cuja saída é passada de volta pelo mesmo
        somador. A autorreferência na definição de <code>int</code> é refletida
        na figura pelo loop de feedback que conecta a saída do somador a uma das
        entradas.
      </p>
      <figure class="float">
        <a id="Figure-3_002e32"></a>
        <object
          style="width: 59.32ex; height: 20.2ex"
          data="fig/chap3/Fig3.32a.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>

        <figcaption class="float-caption">
          <p>
            <strong>Figura 3.32:</strong> O procedimento
            <code>integral</code> visto como um sistema de processamento de
            sinais.
          </p>
        </figcaption>
      </figure>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e73"></a>Exercício 3.73:</strong> Podemos
          modelar circuitos elétricos usando fluxos para representar os valores
          de correntes ou tensões em uma sequência de tempos. Por exemplo,
          suponha que temos um <a id="index-RC-circuit"></a>
          <em>circuito RC</em> consistindo de um resistor de resistência
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>R</mi>
          </math>
          e um capacitor de capacitância
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>C</mi>
          </math>
          em série. A resposta de tensão
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>v</mi>
          </math>
          do circuito a uma corrente injetada
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>i</mi>
          </math>
          é determinada pela fórmula na
          <a href="#Figure-3_002e33">Figura 3.33</a>, cuja estrutura é mostrada
          pelo diagrama de fluxo de sinais.
        </p>
        <figure class="float">
          <a id="Figure-3_002e33"></a>
          <object
            style="width: 50.08ex; height: 37.47ex"
            data="fig/chap3/Fig3.33a.std.svg"
            type="image/svg+xml"
          >
            SVG
          </object>

          <figcaption class="float-caption">
            <p>
              <strong>Figura 3.33:</strong> Um circuito RC e o diagrama de fluxo
              de sinais associado.
            </p>
          </figcaption>
        </figure>

        <p>
          Escreva um procedimento <code>RC</code> que modela esse circuito.
          <code>RC</code> deve receber como entradas os valores de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>R</mi> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>C</mi> </math
          >, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>t</mi>
            </mrow>
          </math>
          e deve retornar um procedimento que recebe como entradas um fluxo
          representando a corrente
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>i</mi>
          </math>
          e um valor inicial para a tensão do capacitor
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>v</mi>
              <mn>0</mn>
            </msub>
          </math>
          e produz como saída o fluxo de tensões
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>v</mi> </math
          >. Por exemplo, você deve ser capaz de usar <code>RC</code> para
          modelar um circuito RC com
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>R</mi>
          </math>
          = 5 ohms,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>C</mi>
          </math>
          = 1 farad, e um passo de tempo de 0,5 segundos por avaliação de
          <code>(define RC1 (RC 5 1 0.5))</code>. Isso define
          <code>RC1</code> como um procedimento que recebe um fluxo
          representando a sequência temporal de correntes e uma tensão inicial
          do capacitor e produz o fluxo de saída de tensões.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e74"></a>Exercício 3.74:</strong> Alyssa
          P. Hacker está projetando um sistema para processar sinais vindos de
          sensores físicos. Uma característica importante que ela deseja
          produzir é um sinal que descreve os <a id="index-zero-crossings"></a>
          <em>cruzamentos por zero</em>
          do sinal de entrada. Ou seja, o sinal resultante deve ser
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </math>
          sempre que o sinal de entrada mudar de negativo para positivo,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo>−<!-- − --></mo>
              <mn>1</mn>
            </mrow>
          </math>
          sempre que o sinal de entrada mudar de positivo para negativo, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mn>0</mn>
          </math>
          caso contrário. (Assuma que o sinal de um
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mn>0</mn>
          </math>
          de entrada é positivo.) Por exemplo, um sinal de entrada típico com
          seu sinal de cruzamento por zero associado seria
        </p>
        <pre><code class="language-scheme">… 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 …
              … 0 0  0  0  0   -1   0  0  0   0   1  0 0 …</code></pre>

        <p>
          No sistema de Alyssa, o sinal do sensor é representado como um fluxo
          <code>sense-data</code> e o fluxo <code>zero-crossings</code> é o
          fluxo correspondente de cruzamentos por zero. Alyssa primeiro escreve
          um procedimento <code>sign-change-detector</code> que recebe dois
          valores como argumentos e compara os sinais dos valores para produzir
          um
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mn>0</mn> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mn>1</mn> </math
          >, ou
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo>−<!-- − --></mo>
              <mn>1</mn>
            </mrow>
          </math>
          apropriado. Ela então constrói seu fluxo de cruzamentos por zero da
          seguinte forma:
        </p>
        <pre><code class="language-scheme">(define (make-zero-crossings
                       input-stream last-value)
                (cons-stream
                 (sign-change-detector 
                  (stream-car input-stream) 
                  last-value)
                 (make-zero-crossings 
                  (stream-cdr input-stream)
                  (stream-car input-stream))))
              
              (define zero-crossings 
                (make-zero-crossings sense-data 0))</code></pre>

        <p>
          O chefe de Alyssa, Eva Lu Ator, passa por perto e sugere que este
          programa é aproximadamente equivalente ao seguinte, que usa a versão
          generalizada de <code>stream-map</code> do
          <a href="#Exercise-3_002e50">Exercício 3.50</a>:
        </p>
        <pre><code class="language-scheme">(define zero-crossings
                (stream-map sign-change-detector 
                            sense-data 
                            ⟨expression⟩))</code></pre>

        <p>
          Complete o programa fornecendo a <code>⟨</code><var>expressão</var
          ><code>⟩</code> indicada.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e75"></a>Exercício 3.75:</strong>
          Infelizmente, o detector de cruzamentos por zero de Alyssa em
          <a href="#Exercise-3_002e74">Exercício 3.74</a> prova ser
          insuficiente, porque o sinal ruidoso do sensor leva a cruzamentos por
          zero espúrios. Lem E. Tweakit, um especialista em hardware, sugere que
          Alyssa suavize o sinal para filtrar o ruído antes de extrair os
          cruzamentos por zero. Alyssa aceita seu conselho e decide extrair os
          cruzamentos por zero do sinal construído pela média de cada valor dos
          dados do sensor com o valor anterior. Ela explica o problema ao seu
          assistente, Louis Reasoner, que tenta implementar a ideia, alterando o
          programa de Alyssa da seguinte forma:
        </p>
        <pre><code class="language-scheme">(define (make-zero-crossings 
                       input-stream last-value)
                (let ((avpt 
                       (/ (+ (stream-car input-stream) 
                             last-value) 
                          2)))
                  (cons-stream 
                   (sign-change-detector avpt last-value)
                   (make-zero-crossings 
                    (stream-cdr input-stream) avpt))))</code></pre>

        <p>
          Isso não implementa corretamente o plano de Alyssa. Encontre o bug que
          Louis instalou e corrija-o sem alterar a estrutura do programa. (Dica:
          Você precisará aumentar o número de argumentos para
          <code>make-zero-crossings</code>.)
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e76"></a>Exercício 3.76:</strong> Eva Lu
          Ator tem uma crítica ao abordagem de Louis no
          <a href="#Exercise-3_002e75">Exercício 3.75</a>. O programa que ele
          escreveu não é modular, porque mistura a operação de suavização com a
          extração de cruzamentos por zero. Por exemplo, o extrator não deveria
          ter que ser alterado se Alyssa encontrar uma maneira melhor de
          condicionar seu sinal de entrada. Ajude Louis escrevendo um
          procedimento <code>smooth</code> que recebe um fluxo como entrada e
          produz um fluxo em que cada elemento é a média de dois elementos
          sucessivos do fluxo de entrada. Em seguida, use
          <code>smooth</code> como um componente para implementar o detector de
          cruzamentos por zero de uma maneira mais modular.
        </p>
      </blockquote>

      <a id="g_t3_002e5_002e4"></a>
      <a id="Streams-and-Delayed-Evaluation"></a>
      <h4 class="subsection">
        <span class="secnum">3.5.4</span
        ><span class="sectitle">Fluxos e Avaliação Atrasada</span>
      </h4>

      <p>
        O procedimento <code>integral</code> no final da seção anterior mostra
        como podemos usar fluxos para modelar sistemas de processamento de
        sinais que contêm loops de feedback. O loop de feedback para o somador
        mostrado na <a href="#Figure-3_002e32">Figura 3.32</a> é modelado pelo
        fato de que o fluxo interno <code>int</code> de <code>integral</code> é
        definido em termos de si mesmo:
      </p>
      <pre><code class="language-scheme">(define int
                (cons-stream 
                 initial-value
                 (add-streams 
                  (scale-stream integrand dt) int)))</code></pre>

      <p>
        A capacidade do interpretador de lidar com tal definição implícita
        depende do <code>delay</code> que é incorporado ao
        <code>cons-stream</code>. Sem esse <code>delay</code>, o interpretador
        não poderia construir <code>int</code> antes de avaliar ambos os
        argumentos para <code>cons-stream</code>, o que exigiria que
        <code>int</code> já estivesse definido. Em geral, <code>delay</code> é
        crucial para usar fluxos para modelar sistemas de processamento de
        sinais que contêm loops. Sem <code>delay</code>, nossos modelos teriam
        que ser formulados de forma que as entradas para qualquer componente de
        processamento de sinais fossem totalmente avaliadas antes que a saída
        pudesse ser produzida. Isso proibiria loops.
      </p>
      <p>
        Infelizmente, modelos de fluxo de sistemas com loops podem exigir usos
        de <code>delay</code> além do <code>delay</code> “oculto” fornecido por
        <code>cons-stream</code>. Por exemplo,
        <a href="#Figure-3_002e34">Figura 3.34</a> mostra um sistema de
        processamento de sinais para resolver a equação diferencial
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>y</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>d</mi>
            <mi>t</mi>
            <mo>=</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        onde
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        é uma dada função. A figura mostra um componente de mapeamento, que
        aplica
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        ao seu sinal de entrada, ligado em um loop de feedback a um integrador
        de uma maneira muito semelhante aos circuitos de computadores analógicos
        que são realmente usados para resolver tais equações.
      </p>
      <figure class="float">
        <a id="Figure-3_002e34"></a>
        <object
          style="width: 44.98ex; height: 18.91ex"
          data="fig/chap3/Fig3.34.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>

        <figcaption class="float-caption">
          <p>
            <strong>Figura 3.34:</strong> Um “circuito de computador analógico”
            que resolve a equação
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>d</mi>
                <mi>y</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mi>d</mi>
                <mi>t</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mo stretchy="false">(</mo>
                <mi>y</mi>
                <mo stretchy="false">)</mo>
              </mrow> </math
            >.
          </p>
        </figcaption>
      </figure>

      <p>
        Assumindo que temos um valor inicial
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>y</mi>
            <mn>0</mn>
          </msub>
        </math>
        para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi> </math
        >, poderíamos tentar modelar este sistema usando o procedimento
      </p>
      <pre><code class="language-scheme">(define (solve f y0 dt)
                (define y (integral dy y0 dt))
                (define dy (stream-map f y))
                y)</code></pre>

      <p>
        Este procedimento não funciona, porque na primeira linha de
        <code>solve</code> a chamada para <code>integral</code> requer que a
        entrada <code>dy</code> seja definida, o que não acontece até a segunda
        linha de <code>solve</code>.
      </p>
      <p>
        Por outro lado, a intenção de nossa definição faz sentido, porque
        podemos, em princípio, começar a gerar o fluxo <code>y</code> sem
        conhecer <code>dy</code>. De fato, <code>integral</code> e muitas outras
        operações de fluxo têm propriedades semelhantes às de
        <code>cons-stream</code>, no sentido de que podemos gerar parte da
        resposta dada apenas informações parciais sobre os argumentos. Para
        <code>integral</code>, o primeiro elemento do fluxo de saída é o
        <code>initial-value</code> especificado. Assim, podemos gerar o primeiro
        elemento do fluxo de saída sem avaliar o integrando <code>dy</code>. Uma
        vez que conhecemos o primeiro elemento de <code>y</code>, o
        <code>stream-map</code> na segunda linha de <code>solve</code> pode
        começar a trabalhar para gerar o primeiro elemento de <code>dy</code>,
        que produzirá o próximo elemento de <code>y</code>, e assim por diante.
      </p>
      <!--Aqui-->
      <p>
        Para aproveitar essa ideia, vamos redefinir <code>integral</code> para
        esperar que o integrando seja um <a id="index-delayed-argument"></a>
        <em>argumento atrasado</em>. <code>Integral</code> irá
        <code>forçar</code> o integrando a ser avaliado apenas quando for
        necessário gerar mais do que o primeiro elemento do fluxo de saída:
      </p>
      <pre><code class="language-scheme">(define (integral
                         delayed-integrand initial-value dt)
                  (define int
                    (cons-stream 
                     initial-value
                     (let ((integrand 
                            (force delayed-integrand)))
                       (add-streams 
                        (scale-stream integrand dt)
                        int))))
                  int)</code></pre>

      <p>
        Agora podemos implementar nosso procedimento
        <code>solve</code> atrasando a avaliação de <code>dy</code> na definição
        de <code>y</code>:<a class="footnote_link" id="DOCF199" href="#FOOT199"
          ><sup>199</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (solve f y0 dt)
                  (define y (integral (delay dy) y0 dt))
                  (define dy (stream-map f y))
                  y)</code></pre>

      <p>
        Em geral, todo chamador de <code>integral</code> deve agora
        <code>atrasar</code> o argumento do integrando. Podemos demonstrar que o
        procedimento <code>solve</code> funciona aproximando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>e</mi>
            <mo>≈<!-- ≈ --></mo>
            <mn>2.718</mn>
          </mrow>
        </math>
        ao calcular o valor em
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
        </math>
        da solução para a equação diferencial
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>y</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>d</mi>
            <mi>t</mi>
            <mo>=</mo>
            <mi>y</mi>
          </mrow>
        </math>
        com a condição inicial
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">(</mo>
            <mn>0</mn>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <mn>1</mn>
          </mrow> </math
        >:
      </p>
      <pre><code class="language-scheme">(stream-ref 
                 (solve (lambda (y) y) 1 0.001) 1000)
                <i>2.716924</i></code></pre>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e77"></a>Exercício 3.77:</strong> O
          procedimento <code>integral</code> usado acima era análogo à definição
          “implícita” do fluxo infinito de inteiros em
          <a href="#g_t3_002e5_002e2">3.5.2</a>. Alternativamente, podemos dar
          uma definição de <code>integral</code> que é mais parecida com
          <code>integers-starting-from</code> (também em
          <a href="#g_t3_002e5_002e2">3.5.2</a>):
        </p>
        <pre><code class="language-scheme">(define (integral
                         integrand initial-value dt)
                  (cons-stream 
                   initial-value
                   (if (stream-null? integrand)
                       the-empty-stream
                       (integral 
                        (stream-cdr integrand)
                        (+ (* dt (stream-car integrand))
                           initial-value)
                        dt))))</code></pre>

        <p>
          Quando usado em sistemas com loops, este procedimento tem o mesmo
          problema que nossa versão original de <code>integral</code>. Modifique
          o procedimento para que ele espere o <code>integrand</code> como um
          argumento atrasado e, portanto, possa ser usado no procedimento
          <code>solve</code> mostrado acima.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e78"></a>Exercício 3.78:</strong>
          Considere o problema de projetar um sistema de processamento de sinais
          para estudar a equação diferencial linear homogênea de segunda ordem
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mfrac>
              <mrow>
                <msup>
                  <mi>d</mi>
                  <mn>2</mn>
                </msup>
                <mi>y</mi>
              </mrow>
              <mrow>
                <mi>d</mi>
                <msup>
                  <mi>t</mi>
                  <mn>2</mn>
                </msup>
              </mrow>
            </mfrac>
            <mo>−<!-- − --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>a</mi>
              <mfrac>
                <mrow>
                  <mi>d</mi>
                  <mi>y</mi>
                </mrow>
                <mrow>
                  <mi>d</mi>
                  <mi>t</mi>
                </mrow>
              </mfrac>
            </mrow>
            <mo>−<!-- − --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>b</mi>
              <mi>y</mi>
            </mrow>
            <mspace width="thinmathspace" />
            <mo>=</mo>
            <mspace width="thinmathspace" />
            <mrow class="MJX-TeXAtom-ORD">
              <mn>0.</mn>
            </mrow>
          </math>
          O fluxo de saída, modelando
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>y</mi> </math
          >, é gerado por uma rede que contém um loop. Isso ocorre porque o
          valor de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>d</mi>
                <mn>2</mn>
              </msup>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>d</mi>
              <msup>
                <mi>t</mi>
                <mn>2</mn>
              </msup>
            </mrow>
          </math>
          depende dos valores de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>y</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>d</mi>
              <mi>t</mi>
            </mrow>
          </math>
          e ambos são determinados por integração de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>d</mi>
                <mn>2</mn>
              </msup>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>d</mi>
              <msup>
                <mi>t</mi>
                <mn>2</mn>
              </msup>
            </mrow> </math
          >. O diagrama que gostaríamos de codificar é mostrado em
          <a href="#Figure-3_002e35">Figura 3.35</a>. Escreva um procedimento
          <code>solve-2nd</code> que recebe como argumentos as constantes
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi> </math
          >, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>t</mi>
            </mrow>
          </math>
          e os valores iniciais
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>y</mi>
              <mn>0</mn>
            </msub>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <msub>
                <mi>y</mi>
                <mn>0</mn>
              </msub>
            </mrow>
          </math>
          para
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>y</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>d</mi>
              <mi>t</mi>
            </mrow>
          </math>
          e gera o fluxo de valores sucessivos de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>y</mi> </math
          >.
        </p>
      </blockquote>

      <figure class="float">
        <a id="Figure-3_002e35"></a>
        <object
          style="width: 44.72ex; height: 38.94ex"
          data="fig/chap3/Fig3.35b.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>

        <figcaption class="float-caption">
          <p>
            <strong>Figura 3.35:</strong> Diagrama de fluxo de sinal para a
            solução de uma equação diferencial linear de segunda ordem.
          </p>
        </figcaption>
      </figure>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e79"></a>Exercício 3.79:</strong>
          Generalize o procedimento <code>solve-2nd</code> do
          <a href="#Exercise-3_002e78">Exercício 3.78</a> para que ele possa ser
          usado para resolver equações diferenciais de segunda ordem gerais
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>d</mi>
                <mn>2</mn>
              </msup>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>d</mi>
              <msup>
                <mi>t</mi>
                <mn>2</mn>
              </msup>
            </mrow>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>d</mi>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>d</mi>
              <mi>t</mi>
              <mo>,</mo>
              <mi>y</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >.
        </p>
      </blockquote>

      <figure class="float">
        <a id="Figure-3_002e36"></a>
        <object
          style="width: 40.49ex; height: 21.76ex"
          data="fig/chap3/Fig3.36.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>

        <figcaption class="float-caption">
          <p><strong>Figura 3.36:</strong> Um circuito RLC em série.</p>
        </figcaption>
      </figure>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e80"></a>Exercício 3.80:</strong> Um
          <a id="index-series-RLC-circuit"></a>
          <em>circuito RLC em série</em>
          consiste em um resistor, um capacitor e um indutor conectados em
          série, como mostrado em <a href="#Figure-3_002e36">Figura 3.36</a>. Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>R</mi> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>L</mi> </math
          >, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>C</mi>
          </math>
          são a resistência, indutância e capacitância, então as relações entre
          a tensão
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>v</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          e corrente
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </math>
          para os três componentes são descritas pelas equações
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable
              columnalign="right center left"
              rowspacing="3pt"
              columnspacing="thickmathspace"
            >
              <mtr>
                <mtd>
                  <msub>
                    <mi>v</mi>
                    <mi>R</mi>
                  </msub>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <msub>
                    <mi>i</mi>
                    <mi>R</mi>
                  </msub>
                  <mi>R</mi>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>v</mi>
                    <mi>L</mi>
                  </msub>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mi>L</mi>
                  <mspace width="thinmathspace" />
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <mrow>
                        <mi>d</mi>
                        <msub>
                          <mi>i</mi>
                          <mi>L</mi>
                        </msub>
                      </mrow>
                      <mrow>
                        <mi>d</mi>
                        <mi>t</mi>
                      </mrow>
                    </mfrac>
                  </mrow>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>i</mi>
                    <mi>C</mi>
                  </msub>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mi>C</mi>
                  <mspace width="thinmathspace" />
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <mrow>
                        <mi>d</mi>
                        <msub>
                          <mi>v</mi>
                          <mi>C</mi>
                        </msub>
                      </mrow>
                      <mrow>
                        <mi>d</mi>
                        <mi>t</mi>
                      </mrow>
                    </mfrac>
                  </mrow>
                  <mo>,</mo>
                </mtd>
              </mtr>
            </mtable>
          </math>
          e as conexões do circuito ditam as relações
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable
              columnalign="right center left"
              rowspacing="3pt"
              columnspacing="thickmathspace"
            >
              <mtr>
                <mtd>
                  <msub>
                    <mi>i</mi>
                    <mi>R</mi>
                  </msub>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <msub>
                    <mi>i</mi>
                    <mi>L</mi>
                  </msub>
                  <mo>=</mo>
                  <mo>−<!-- − --></mo>
                  <msub>
                    <mi>i</mi>
                    <mi>C</mi>
                  </msub>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>v</mi>
                    <mi>C</mi>
                  </msub>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <msub>
                    <mi>v</mi>
                    <mi>L</mi>
                  </msub>
                  <mo>+</mo>
                  <msub>
                    <mi>v</mi>
                    <mi>R</mi>
                  </msub>
                  <mo>.</mo>
                </mtd>
              </mtr>
            </mtable>
          </math>
          Combinando essas equações, mostra-se que o estado do circuito
          (resumido por
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>v</mi>
              <mi>C</mi>
            </msub> </math
          >, a tensão no capacitor, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>i</mi>
              <mi>L</mi>
            </msub> </math
          >, a corrente no indutor) é descrito pelo par de equações diferenciais
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mtable
              columnalign="right center left"
              rowspacing="3pt"
              columnspacing="thickmathspace"
            >
              <mtr>
                <mtd>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <mrow>
                        <mi>d</mi>
                        <msub>
                          <mi>v</mi>
                          <mi>C</mi>
                        </msub>
                      </mrow>
                      <mrow>
                        <mi>d</mi>
                        <mi>t</mi>
                      </mrow>
                    </mfrac>
                  </mrow>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mo>−<!-- − --></mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <msub>
                        <mi>i</mi>
                        <mi>L</mi>
                      </msub>
                      <mi>C</mi>
                    </mfrac>
                  </mrow>
                  <mspace width="thinmathspace" />
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <mrow>
                        <mi>d</mi>
                        <msub>
                          <mi>i</mi>
                          <mi>L</mi>
                        </msub>
                      </mrow>
                      <mrow>
                        <mi>d</mi>
                        <mi>t</mi>
                      </mrow>
                    </mfrac>
                  </mrow>
                </mtd>
                <mtd>
                  <mo>=</mo>
                </mtd>
                <mtd>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <mn>1</mn>
                      <mi>L</mi>
                    </mfrac>
                  </mrow>
                  <mspace width="thinmathspace" />
                  <msub>
                    <mi>v</mi>
                    <mi>C</mi>
                  </msub>
                  <mo>−<!-- − --></mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mfrac>
                      <mi>R</mi>
                      <mi>L</mi>
                    </mfrac>
                  </mrow>
                  <mspace width="thinmathspace" />
                  <msub>
                    <mi>i</mi>
                    <mi>L</mi>
                  </msub>
                  <mo>.</mo>
                </mtd>
              </mtr>
            </mtable>
          </math>
          O diagrama de fluxo de sinal que representa esse sistema de equações
          diferenciais é mostrado em <a href="#Figure-3_002e37">Figura 3.37</a>.
        </p>
      </blockquote>

      <figure class="float">
        <a id="Figure-3_002e37"></a>
        <object
          style="width: 42.48ex; height: 49.3ex"
          data="fig/chap3/Fig3.37.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>

        <figcaption class="float-caption">
          <p>
            <strong>Figura 3.37:</strong> Um diagrama de fluxo de sinal para a
            solução de um circuito RLC em série.
          </p>
        </figcaption>
      </figure>

      <blockquote>
        <p>
          Escreva um procedimento <code>RLC</code> que recebe como argumentos os
          parâmetros
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>R</mi> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>L</mi> </math
          >, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>C</mi>
          </math>
          do circuito e o incremento de tempo
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>t</mi>
            </mrow> </math
          >. De uma maneira semelhante à do procedimento <code>RC</code> do
          <a href="#Exercise-3_002e73">Exercício 3.73</a>, <code>RLC</code> deve
          produzir um procedimento que recebe os valores iniciais das variáveis
          de estado,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>v</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>C</mi>
                  <mn>0</mn>
                </msub>
              </mrow>
            </msub>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>i</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>L</mi>
                  <mn>0</mn>
                </msub>
              </mrow>
            </msub> </math
          >, e produz um par (usando <code>cons</code>) dos fluxos de estados
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>v</mi>
              <mi>C</mi>
            </msub>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>i</mi>
              <mi>L</mi>
            </msub> </math
          >. Usando <code>RLC</code>, gere o par de fluxos que modela o
          comportamento de um circuito RLC em série com
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>R</mi>
          </math>
          = 1 ohm,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>C</mi>
          </math>
          = 0.2 farad,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>L</mi>
          </math>
          = 1 henry,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>t</mi>
            </mrow>
          </math>
          = 0.1 segundo, e valores iniciais
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>i</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>L</mi>
                  <mn>0</mn>
                </msub>
              </mrow>
            </msub>
          </math>
          = 0 amps e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>v</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>C</mi>
                  <mn>0</mn>
                </msub>
              </mrow>
            </msub>
          </math>
          = 10 volts.
        </p>
      </blockquote>

      <a id="Normal_002dorder-evaluation"></a>
      <h5 class="subsubheading">Avaliação de ordem normal</h5>

      <p>
        Os exemplos nesta seção ilustram como o uso explícito de
        <code>delay</code> e <code>force</code> fornece grande flexibilidade de
        programação, mas os mesmos exemplos também mostram como isso pode tornar
        nossos programas mais complexos. Nosso novo procedimento
        <code>integral</code>, por exemplo, nos dá o poder de modelar sistemas
        com loops, mas agora devemos lembrar que <code>integral</code> deve ser
        chamado com um integrando atrasado, e todo procedimento que usa
        <code>integral</code> deve estar ciente disso. Na prática, criamos duas
        classes de procedimentos: procedimentos ordinários e procedimentos que
        recebem argumentos atrasados. Em geral, criar classes separadas de
        procedimentos nos força a criar classes separadas de procedimentos de
        ordem superior também.<a
          class="footnote_link"
          id="DOCF200"
          href="#FOOT200"
          ><sup>200</sup></a
        >
      </p>
      <p>
        Uma maneira de evitar a necessidade de duas classes diferentes de
        procedimentos é fazer com que todos os procedimentos recebam argumentos
        atrasados. Poderíamos adotar um modelo de avaliação em que todos os
        argumentos para procedimentos são automaticamente atrasados e os
        argumentos são forçados apenas quando são realmente necessários (por
        exemplo, quando são exigidos por uma operação primitiva). Isso
        transformaria nossa linguagem para usar avaliação de ordem normal, que
        descrevemos pela primeira vez quando introduzimos o modelo de
        substituição para avaliação em
        <a href="1_002e1.html#g_t1_002e1_002e5">1.1.5</a>. Converter para
        avaliação de ordem normal fornece uma maneira uniforme e elegante de
        simplificar o uso de avaliação atrasada, e essa seria uma estratégia
        natural a adotar se estivéssemos preocupados apenas com o processamento
        de fluxos. Em <a href="4_002e2.html#g_t4_002e2">4.2</a>, depois de
        estudarmos o avaliador, veremos como transformar nossa linguagem
        exatamente dessa maneira. Infelizmente, incluir atrasos em chamadas de
        procedimentos causa estragos com nossa capacidade de projetar programas
        que dependem da ordem dos eventos, como programas que usam atribuição,
        mutação de dados ou realizam entrada ou saída. Mesmo o único
        <code>delay</code> em <code>cons-stream</code> pode causar grande
        confusão, como ilustrado por
        <a href="#Exercise-3_002e51">Exercício 3.51</a> e
        <a href="#Exercise-3_002e52">Exercício 3.52</a>. Até onde se sabe,
        mutabilidade e avaliação atrasada não se misturam bem em linguagens de
        programação, e desenvolver maneiras de lidar com ambos ao mesmo tempo é
        uma área ativa de pesquisa.
      </p>
      <a id="g_t3_002e5_002e5"></a>
      <a id="Modularity-of-Functional-Programs-and-Modularity-of-Objects"></a>
      <h4 class="subsection">
        <span class="secnum">3.5.5</span
        ><span class="sectitle"
          >Modularidade de Programas Funcionais e Modularidade de Objetos</span
        >
      </h4>

      <p>
        Como vimos em <a href="3_002e1.html#g_t3_002e1_002e2">3.1.2</a>, um dos
        principais benefícios de introduzir atribuição é que podemos aumentar a
        modularidade de nossos sistemas ao encapsular, ou “esconder,” partes do
        estado de um grande sistema dentro de variáveis locais. Modelos de fluxo
        podem fornecer uma modularidade equivalente sem o uso de atribuição.
        Como ilustração, podemos reimplementar a estimação de Monte Carlo de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >, que examinamos em <a href="3_002e1.html#g_t3_002e1_002e2">3.1.2</a>,
        a partir de um ponto de vista de processamento de fluxo.
      </p>
      <p>
        A questão chave de modularidade era que queríamos esconder o estado
        interno de um gerador de números aleatórios de programas que usavam
        números aleatórios. Começamos com um procedimento
        <code>rand-update</code>, cujos valores sucessivos forneciam nosso
        suprimento de números aleatórios, e usamos isso para produzir um gerador
        de números aleatórios:
      </p>
      <pre><code class="language-scheme">(define rand
                  (let ((x random-init))
                    (lambda ()
                      (set! x (rand-update x))
                      x)))</code></pre>

      <p>
        Na formulação de fluxo, não há um gerador de números aleatórios
        <em>per se</em>, apenas um fluxo de números aleatórios produzido por
        chamadas sucessivas a <code>rand-update</code>:
      </p>
      <pre><code class="language-scheme">(define random-numbers
                  (cons-stream random-init
                               (stream-map rand-update 
                                           random-numbers)))</code></pre>

      <p>
        Usamos isso para construir o fluxo de resultados do experimento de
        Cesàro realizado em pares consecutivos no fluxo
        <code>random-numbers</code>:
      </p>
      <pre><code class="language-scheme">(define cesaro-stream
                  (map-successive-pairs
                   (lambda (r1 r2) (= (gcd r1 r2) 1))
                   random-numbers))
                
                (define (map-successive-pairs f s)
                  (cons-stream
                   (f (stream-car s) 
                      (stream-car (stream-cdr s)))
                   (map-successive-pairs 
                    f (stream-cdr (stream-cdr s)))))</code></pre>

      <p>
        O <code>cesaro-stream</code> é agora alimentado a um procedimento
        <code>monte-carlo</code>, que produz um fluxo de estimativas de
        probabilidades. Os resultados são então convertidos em um fluxo de
        estimativas de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >. Esta versão do programa não precisa de um parâmetro informando
        quantas tentativas realizar. Estimativas melhores de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi>
        </math>
        (de realizar mais experimentos) são obtidas ao olhar mais longe no fluxo
        <code>pi</code>:
      </p>
      <pre><code class="language-scheme">(define (monte-carlo experiment-stream 
                                     passed 
                                     failed)
                  (define (next passed failed)
                    (cons-stream
                     (/ passed (+ passed failed))
                     (monte-carlo
                      (stream-cdr experiment-stream) 
                      passed 
                      failed)))
                  (if (stream-car experiment-stream)
                      (next (+ passed 1) failed)
                      (next passed (+ failed 1)))))
                
                (define pi
                  (stream-map
                   (lambda (p) (sqrt (/ 6 p)))
                   (monte-carlo cesaro-stream 0 0)))</code></pre>

      <p>
        Há considerável modularidade nesta abordagem, porque ainda podemos
        formular um procedimento <code>monte-carlo</code> geral que pode lidar
        com experimentos arbitrários. No entanto, não há atribuição ou estado
        local.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e81"></a>Exercício 3.81:</strong>
          <a href="3_002e1.html#Exercise-3_002e6">Exercício 3.6</a> discutiu a
          generalização do gerador de números aleatórios para permitir que se
          reinicie a sequência de números aleatórios para produzir sequências
          repetíveis de números “aleatórios”. Produza uma formulação de fluxo
          desse mesmo gerador que opera em um fluxo de entrada de solicitações
          para <code>gerar</code> um novo número aleatório ou para
          <code>reiniciar</code> a sequência para um valor especificado e que
          produz o fluxo desejado de números aleatórios. Não use atribuição em
          sua solução.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-3_002e82"></a>Exercício 3.82:</strong> Refazer
          <a href="3_002e1.html#Exercise-3_002e5">Exercício 3.5</a> sobre
          integração de Monte Carlo em termos de fluxos. A versão de fluxo de
          <code>estimate-integral</code> não terá um argumento informando
          quantas tentativas realizar. Em vez disso, produzirá um fluxo de
          estimativas baseadas em sucessivamente mais tentativas.
        </p>
      </blockquote>

      <a id="A-functional_002dprogramming-view-of-time"></a>
      <h5 class="subsubheading">Uma visão de programação funcional do tempo</h5>

      <p>
        Vamos agora retornar às questões de objetos e estado que foram
        levantadas no início deste capítulo e examiná-las sob uma nova luz.
        Introduzimos atribuição e objetos mutáveis para fornecer um mecanismo
        para construção modular de programas que modelam sistemas com estado.
        Construímos objetos computacionais com variáveis de estado locais e
        usamos atribuição para modificar essas variáveis. Modelamos o
        comportamento temporal dos objetos no mundo pelo comportamento temporal
        dos objetos computacionais correspondentes.
      </p>
      <p>
        Agora vimos que os fluxos fornecem uma maneira alternativa de modelar
        objetos com estado local. Podemos modelar uma quantidade em mudança,
        como o estado local de algum objeto, usando um fluxo que representa a
        história temporal dos estados sucessivos. Em essência, representamos o
        tempo explicitamente, usando fluxos, de modo que desacoplamos o tempo em
        nosso mundo simulado da sequência de eventos que ocorrem durante a
        avaliação. De fato, devido à presença de <code>delay</code>, pode haver
        pouca relação entre o tempo simulado no modelo e a ordem dos eventos
        durante a avaliação.
      </p>
      <p>
        Para contrastar essas duas abordagens de modelagem, vamos reconsiderar a
        implementação de um “processador de saque” que monitora o saldo em uma
        conta bancária. Em
        <a href="3_002e1.html#g_t3_002e1_002e3">3.1.3</a> implementamos uma
        versão simplificada de tal processador:
      </p>
      <pre><code class="language-scheme">(define (make-simplified-withdraw balance)
                  (lambda (amount)
                    (set! balance (- balance amount))
                    balance))</code></pre>

      <p>
        Chamadas para <code>make-simplified-withdraw</code> produzem objetos
        computacionais, cada um com uma variável de estado local
        <code>balance</code> que é decrementada por chamadas sucessivas ao
        objeto. O objeto recebe um <code>amount</code> como argumento e retorna
        o novo saldo. Podemos imaginar o usuário de uma conta bancária digitando
        uma sequência de entradas para tal objeto e observando a sequência de
        valores retornados exibidos em uma tela.
      </p>
      <p>
        Alternativamente, podemos modelar um processador de saque como um
        procedimento que recebe como entrada um saldo e um fluxo de valores para
        sacar e produz o fluxo de saldos sucessivos na conta:
      </p>
      <pre><code class="language-scheme">(define (stream-withdraw balance amount-stream)
                  (cons-stream
                   balance
                   (stream-withdraw 
                    (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))</code></pre>

      <p>
        <code>Stream-withdraw</code> implementa uma função matemática bem
        definida cuja saída é totalmente determinada por sua entrada. Suponha,
        no entanto, que a entrada <code>amount-stream</code> seja o fluxo de
        valores sucessivos digitados pelo usuário e que o fluxo resultante de
        saldos seja exibido. Então, da perspectiva do usuário que está digitando
        valores e observando resultados, o processo de fluxo tem o mesmo
        comportamento que o objeto criado por
        <code>make-simplified-withdraw</code>. No entanto, com a versão de
        fluxo, não há atribuição, nenhuma variável de estado local e,
        consequentemente, nenhuma das dificuldades teóricas que encontramos em
        <a href="3_002e1.html#g_t3_002e1_002e3">3.1.3</a>. No entanto, o
        sistema tem estado!
      </p>
      <p>
        Isso é realmente notável. Mesmo que
        <code>stream-withdraw</code> implemente uma função matemática bem
        definida cujo comportamento não muda, a percepção do usuário aqui é de
        interagir com um sistema que tem um estado em mudança. Uma maneira de
        resolver esse paradoxo é perceber que é a existência temporal do usuário
        que impõe estado ao sistema. Se o usuário pudesse se afastar da
        interação e pensar em termos de fluxos de saldos em vez de transações
        individuais, o sistema pareceria sem estado.<a
          class="footnote_link"
          id="DOCF201"
          href="#FOOT201"
          ><sup>201</sup></a
        >
      </p>
      <p>
        Do ponto de vista de uma parte de um processo complexo, as outras partes
        parecem mudar com o tempo. Elas têm estado local oculto que varia com o
        tempo. Se desejamos escrever programas que modelam esse tipo de
        decomposição natural em nosso mundo (como o vemos do nosso ponto de
        vista como parte desse mundo) com estruturas em nosso computador,
        fazemos objetos computacionais que não são funcionais—eles devem mudar
        com o tempo. Modelamos estado com variáveis de estado locais, e
        modelamos as mudanças de estado com atribuições a essas variáveis. Ao
        fazer isso, fazemos o tempo de execução de uma computação modelar o
        tempo no mundo do qual fazemos parte, e assim obtemos “objetos” em nosso
        computador.
      </p>
      <p>
        Modelar com objetos é poderoso e intuitivo, em grande parte porque isso
        corresponde à percepção de interagir com um mundo do qual fazemos parte.
        No entanto, como vimos repetidamente ao longo deste capítulo, esses
        modelos levantam problemas espinhosos de restringir a ordem dos eventos
        e de sincronizar múltiplos processos. A possibilidade de evitar esses
        problemas estimulou o desenvolvimento de
        <a id="index-functional-programming-languages"></a>
        <em>linguagens de programação funcional</em>, que não incluem nenhum
        provisionamento para atribuição ou dados mutáveis. Em tal linguagem,
        todos os procedimentos implementam funções matemáticas bem definidas de
        seus argumentos, cujo comportamento não muda. A abordagem funcional é
        extremamente atraente para lidar com sistemas concorrentes.<a
          class="footnote_link"
          id="DOCF202"
          href="#FOOT202"
          ><sup>202</sup></a
        >
      </p>
      <p>
        Por outro lado, se olharmos de perto, podemos ver problemas relacionados
        ao tempo surgindo em modelos funcionais também. Uma área particularmente
        problemática surge quando desejamos projetar sistemas interativos,
        especialmente aqueles que modelam interações entre entidades
        independentes. Por exemplo, considere mais uma vez a implementação de um
        sistema bancário que permite contas conjuntas. Em um sistema
        convencional usando atribuição e objetos, modelaríamos o fato de que
        Pedro e Paulo compartilham uma conta fazendo com que ambos enviem suas
        solicitações de transação para o mesmo objeto de conta bancária, como
        vimos em <a href="3_002e1.html#g_t3_002e1_002e3">3.1.3</a>. Do ponto de
        vista de fluxo, onde não há “objetos” <em>per se</em>, já indicamos que
        uma conta bancária pode ser modelada como um processo que opera em um
        fluxo de solicitações de transação para produzir um fluxo de respostas.
        Assim, poderíamos modelar o fato de que Pedro e Paulo têm uma conta
        bancária conjunta mesclando o fluxo de solicitações de transação de
        Pedro com o fluxo de solicitações de Paulo e alimentando o resultado ao
        processo de fluxo de conta bancária, como mostrado em
        <a href="#Figure-3_002e38">Figura 3.38</a>.
      </p>
      <figure class="float">
        <a id="Figure-3_002e38"></a>
        <object
          style="width: 54.65ex; height: 9.76ex"
          data="fig/chap3/Fig3.38a.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>

        <figcaption class="float-caption">
          <p>
            <strong>Figura 3.38:</strong> Uma conta bancária conjunta, modelada
            pela mesclagem de dois fluxos de solicitações de transação.
          </p>
        </figcaption>
      </figure>

      <p>
        O problema com essa formulação está na noção de
        <a id="index-merge"></a> <em>mesclagem</em>. Não adianta mesclar os dois
        fluxos simplesmente alternando uma solicitação de Pedro e uma
        solicitação de Paulo. Suponha que Paulo acesse a conta apenas muito
        raramente. Dificilmente poderíamos forçar Pedro a esperar que Paulo
        acessasse a conta antes que ele pudesse emitir uma segunda transação. No
        entanto, tal mesclagem é implementada, ela deve intercalar os dois
        fluxos de transação de alguma forma que seja restrita pelo “tempo real”
        percebido por Pedro e Paulo, no sentido de que, se Pedro e Paulo se
        encontrarem, eles podem concordar que certas transações foram
        processadas antes do encontro, e outras transações foram processadas
        após o encontro.<a class="footnote_link" id="DOCF203" href="#FOOT203"
          ><sup>203</sup></a
        >
        Esta é exatamente a mesma restrição que tivemos que lidar em
        <a href="3_002e4.html#g_t3_002e4_002e1">3.4.1</a>, onde encontramos a
        necessidade de introduzir sincronização explícita para garantir uma
        ordem “correta” de eventos no processamento concorrente de objetos com
        estado. Assim, em uma tentativa de apoiar o estilo funcional, a
        necessidade de mesclar entradas de diferentes agentes reintroduz os
        mesmos problemas que o estilo funcional pretendia eliminar.
      </p>
      <p>
        Começamos este capítulo com o objetivo de construir modelos
        computacionais cuja estrutura corresponda à nossa percepção do mundo
        real que estamos tentando modelar. Podemos modelar o mundo como uma
        coleção de objetos separados, limitados pelo tempo, interagindo com
        estado, ou podemos modelar o mundo como uma única unidade atemporal, sem
        estado. Cada visão tem vantagens poderosas, mas nenhuma visão é
        completamente satisfatória. Uma grande unificação ainda não surgiu.<a
          class="footnote_link"
          id="DOCF204"
          href="#FOOT204"
          ><sup>204</sup></a
        >
      </p>
      <div class="footnote">
        <h4 class="footnotes-heading">Notas de rodapé</h4>

        <div id="FOOT180">
          <p>
            <a class="footnote_backlink" href="#DOCF180"><sup>180</sup></a>
            Físicos às vezes adotam essa visão ao introduzir as “linhas do
            mundo” de partículas como um dispositivo para raciocinar sobre
            movimento. Também já mencionamos (<a
              href="2_002e2.html#g_t2_002e2_002e3"
              >2.2.3</a
            >) que essa é a maneira natural de pensar sobre sistemas de
            processamento de sinais. Exploraremos aplicações de fluxos ao
            processamento de sinais em <a href="#g_t3_002e5_002e3">3.5.3</a>.
          </p>
        </div>
        <div id="FOOT181">
          <p>
            <a class="footnote_backlink" href="#DOCF181"><sup>181</sup></a>
            Assuma que temos um predicado <code>prime?</code> (por exemplo, como
            em <a href="1_002e2.html#g_t1_002e2_002e6">1.2.6</a>) que testa
            primalidade.
          </p>
        </div>
        <div id="FOOT182">
          <p>
            <a class="footnote_backlink" href="#DOCF182"><sup>182</sup></a> Na
            implementação do <abbr>MIT</abbr>, <code>the-empty-stream</code> é o
            mesmo que a lista vazia <code>'()</code>, e
            <code>stream-null?</code> é o mesmo que <code>null?</code>.
          </p>
        </div>
        <div id="FOOT183">
          <p>
            <a class="footnote_backlink" href="#DOCF183"><sup>183</sup></a> Isso
            deve incomodar você. O fato de estarmos definindo procedimentos tão
            semelhantes para fluxos e listas indica que estamos perdendo alguma
            abstração subjacente. Infelizmente, para explorar essa abstração,
            precisaremos exercer um controle mais fino sobre o processo de
            avaliação do que podemos atualmente. Discutiremos esse ponto mais
            adiante no final de <a href="#g_t3_002e5_002e4">3.5.4</a>. Em
            <a href="4_002e2.html#g_t4_002e2">4.2</a>, desenvolveremos um
            framework que unifica listas e fluxos.
          </p>
        </div>
        <div id="FOOT184">
          <p>
            <a class="footnote_backlink" href="#DOCF184"><sup>184</sup></a>
            Embora <code>stream-car</code> e <code>stream-cdr</code> possam ser
            definidos como procedimentos, <code>cons-stream</code> deve ser uma
            forma especial. Se <code>cons-stream</code> fosse um procedimento,
            então, de acordo com nosso modelo de avaliação, avaliar
            <code>(cons-stream ⟨<var>a</var>⟩ ⟨<var>b</var>⟩)</code> iria
            automaticamente causar a avaliação de <code>⟨</code><var>b</var
            ><code>⟩</code>, o que é exatamente o que não queremos que aconteça.
            Pela mesma razão, <code>delay</code> deve ser uma forma especial,
            embora <code>force</code> possa ser um procedimento ordinário.
          </p>
        </div>
        <div id="FOOT185">
          <p>
            <a class="footnote_backlink" href="#DOCF185"><sup>185</sup></a> Os
            números mostrados aqui não aparecem realmente na expressão atrasada.
            O que realmente aparece é a expressão original, em um ambiente onde
            as variáveis estão vinculadas aos números apropriados. Por exemplo,
            <code>(+ low 1)</code> com <code>low</code> vinculado a 10.000
            aparece onde <code>10001</code> é mostrado.
          </p>
        </div>
        <div id="FOOT186">
          <p>
            <a class="footnote_backlink" href="#DOCF186"><sup>186</sup></a> Há
            muitas possíveis implementações de fluxos além da descrita nesta
            seção. Avaliação atrasada, que é a chave para tornar os fluxos
            práticos, era inerente ao método de passagem de parâmetros
            <a id="index-call_002dby_002dname"></a> <em>call-by-name</em> do
            Algol 60. O uso desse mecanismo para implementar fluxos foi descrito
            pela primeira vez por
            <a href="References.html#Landin-_00281965_0029">Landin (1965)</a>.
            Avaliação atrasada para fluxos foi introduzida no Lisp por
            <a href="References.html#Friedman-and-Wise-_00281976_0029"
              >Friedman e Wise (1976)</a
            >. Em sua implementação, <code>cons</code> sempre atrasa a avaliação
            de seus argumentos, de modo que listas automaticamente se comportam
            como fluxos. A otimização de memoização também é conhecida como
            <a id="index-call_002dby_002dneed"></a> <em>call-by-need</em>. A
            comunidade do Algol se referiria aos nossos objetos atrasados
            originais como <a id="index-call_002dby_002dname-thunks"></a>
            <em>call-by-name thunks</em> e às versões otimizadas como
            <a id="index-call_002dby_002dneed-thunks"></a>
            <em>call-by-need thunks</em>.
          </p>
        </div>
        <div id="FOOT187">
          <p>
            <a class="footnote_backlink" href="#DOCF187"><sup>187</sup></a>
            Exercícios como <a href="#Exercise-3_002e51">Exercício 3.51</a> e
            <a href="#Exercise-3_002e52">Exercício 3.52</a> são valiosos para
            testar nossa compreensão de como <code>delay</code> funciona. Por
            outro lado, misturar avaliação atrasada com impressão—e, pior ainda,
            com atribuição—é extremamente confuso, e instrutores de cursos sobre
            linguagens de computador tradicionalmente atormentam seus alunos com
            questões de exame como as desta seção. Desnecessário dizer, escrever
            programas que dependem de tais sutilezas é um estilo de programação
            odioso. Parte do poder do processamento de fluxos é que ele nos
            permite ignorar a ordem em que os eventos realmente acontecem em
            nossos programas. Infelizmente, isso é exatamente o que não podemos
            nos dar ao luxo de fazer na presença de atribuição, que nos força a
            nos preocupar com tempo e mudança.
          </p>
        </div>
        <div id="FOOT188">
          <p>
            <a class="footnote_backlink" href="#DOCF188"><sup>188</sup></a>
            Eratóstenes, um filósofo grego alexandrino do terceiro século
            <abbr>a.C.</abbr>, é famoso por fornecer a primeira estimativa
            precisa da circunferência da Terra, que ele calculou observando as
            sombras projetadas ao meio-dia no dia do solstício de verão. O
            método do crivo de Eratóstenes, embora antigo, formou a base para
            hardware especializado "crivos" que, até recentemente, eram as
            ferramentas mais poderosas existentes para localizar números primos
            grandes. No entanto, desde os anos 70, esses métodos foram superados
            por desenvolvimentos das técnicas probabilísticas discutidas em
            <a href="1_002e2.html#g_t1_002e2_002e6">1.2.6</a>.
          </p>
        </div>
        <div id="FOOT189">
          <p>
            <a class="footnote_backlink" href="#DOCF189"><sup>189</sup></a> Nós
            nomeamos essas figuras em homenagem a Peter Henderson, que foi a
            primeira pessoa a nos mostrar diagramas desse tipo como uma forma de
            pensar sobre o processamento de fluxos. Cada linha sólida representa
            um fluxo de valores sendo transmitidos. A linha tracejada do
            <code>car</code> para o <code>cons</code> e o
            <code>filter</code> indica que este é um único valor, em vez de um
            fluxo.
          </p>
        </div>
        <div id="FOOT190">
          <p>
            <a class="footnote_backlink" href="#DOCF190"><sup>190</sup></a> Isso
            usa a versão generalizada de <code>stream-map</code> de
            <a href="#Exercise-3_002e50">Exercício 3.50</a>.
          </p>
        </div>
        <div id="FOOT191">
          <p>
            <a class="footnote_backlink" href="#DOCF191"><sup>191</sup></a> Este
            último ponto é muito sutil e depende do fato de que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>p</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mi>n</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </msub>
                <mo>≤<!-- ≤ --></mo>
                <msubsup>
                  <mi>p</mi>
                  <mi>n</mi>
                  <mn>2</mn>
                </msubsup>
              </mrow>
              <mo>.</mo>
            </math>
            (Aqui,
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>p</mi>
                <mi>k</mi>
              </msub>
            </math>
            denota o
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mi>k</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mtext>º</mtext>
                </mrow>
              </msup>
            </math>
            primo.) Estimativas como essas são muito difíceis de estabelecer. A
            prova antiga de Euclides de que há um número infinito de primos
            mostra que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>p</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>n</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≤<!-- ≤ --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <msub>
                  <mi>p</mi>
                  <mn>1</mn>
                </msub>
                <msub>
                  <mi>p</mi>
                  <mn>2</mn>
                </msub>
                <mo>⋯<!-- ⋯ --></mo>
                <msub>
                  <mi>p</mi>
                  <mi>n</mi>
                </msub>
                <mo>+</mo>
                <mn>1</mn>
              </mrow> </math
            >, e nenhum resultado substancialmente melhor foi provado até 1851,
            quando o matemático russo P. L. Chebyshev estabeleceu que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>p</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>n</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>≤<!-- ≤ --></mo>
              <mn>2</mn>
              <msub>
                <mi>p</mi>
                <mi>n</mi>
              </msub>
            </math>
            para todo
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>n</mi> </math
            >. Este resultado, originalmente conjecturado em 1845, é conhecido
            como <a id="index-Bertrand_0027s-hypothesis"></a>
            <em>Hipótese de Bertrand</em>. Uma prova pode ser encontrada na
            seção 22.3 de
            <a href="References.html#Hardy-and-Wright-1960"
              >Hardy e Wright 1960</a
            >.
          </p>
        </div>
        <div id="FOOT192">
          <p>
            <a class="footnote_backlink" href="#DOCF192"><sup>192</sup></a> Este
            exercício mostra como a avaliação por necessidade está intimamente
            relacionada à memoização comum, conforme descrito em
            <a href="3_002e3.html#Exercise-3_002e27">Exercício 3.27</a>.
            Naquele exercício, usamos atribuição para construir explicitamente
            uma tabela local. Nossa otimização de fluxo por necessidade
            efetivamente constrói tal tabela automaticamente, armazenando
            valores nas partes previamente forçadas do fluxo.
          </p>
        </div>
        <div id="FOOT193">
          <p>
            <a class="footnote_backlink" href="#DOCF193"><sup>193</sup></a> Não
            podemos usar <code>let</code> para vincular a variável local
            <code>guesses</code>, porque o valor de <code>guesses</code> depende
            de <code>guesses</code> mesmo.
            <a href="#Exercise-3_002e63">Exercício 3.63</a> aborda por que
            queremos uma variável local aqui.
          </p>
        </div>
        <div id="FOOT194">
          <p>
            <a class="footnote_backlink" href="#DOCF194"><sup>194</sup></a>
            Como em
            <a href="2_002e2.html#g_t2_002e2_002e3">2.2.3</a>, representamos um
            par de inteiros como uma lista em vez de um par Lisp.
          </p>
        </div>
        <div id="FOOT195">
          <p>
            <a class="footnote_backlink" href="#DOCF195"><sup>195</sup></a> Veja
            <a href="#Exercise-3_002e68">Exercício 3.68</a> para alguma visão
            sobre por que escolhemos essa decomposição.
          </p>
        </div>
        <div id="FOOT196">
          <p>
            <a class="footnote_backlink" href="#DOCF196"><sup>196</sup></a>
            A afirmação precisa da propriedade necessária sobre a ordem de
            combinação é a seguinte: Deve haver uma função
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>f</mi>
            </math>
            de dois argumentos tal que o par correspondente ao elemento
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>i</mi>
            </math>
            do primeiro fluxo e o elemento
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>j</mi>
            </math>
            do segundo fluxo aparecerá como elemento número
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>f</mi>
                <mo stretchy="false">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">)</mo>
              </mrow>
            </math>
            do fluxo de saída. O truque de usar <code>interleave</code> para
            realizar isso foi mostrado a nós por David Turner, que o empregou na
            linguagem KRC (<a href="References.html#Turner-1981">Turner 1981</a
            >).
          </p>
        </div>
        <div id="FOOT197">
          <p>
            <a class="footnote_backlink" href="#DOCF197"><sup>197</sup></a>
            Exigiremos que a função de ponderação seja tal que o peso de um par
            aumente à medida que nos movemos ao longo de uma linha ou coluna da
            matriz de pares.
          </p>
        </div>
        <div id="FOOT198">
          <p>
            <a class="footnote_backlink" href="#DOCF198"><sup>198</sup></a> Para
            citar o obituário de G. H. Hardy sobre Ramanujan (<a
              href="References.html#Hardy-1921"
              >Hardy 1921</a
            >): “Foi o Sr. Littlewood (eu acredito) quem observou que ‘todo
            número inteiro positivo era um de seus amigos.’ Lembro-me de uma vez
            ter ido visitá-lo quando ele estava doente em Putney. Eu tinha
            pegado um táxi de número 1729 e comentei que o número me parecia
            bastante sem graça e que esperava que não fosse um mau presságio.
            ‘Não,’ ele respondeu, ‘é um número muito interessante; é o menor
            número expressível como a soma de dois cubos de duas maneiras
            diferentes.’ ” O truque de usar pares ponderados para gerar os
            números de Ramanujan foi mostrado a nós por Charles Leiserson.
          </p>
        </div>
        <div id="FOOT199">
          <p>
            <a class="footnote_backlink" href="#DOCF199"><sup>199</sup></a> Este
            procedimento não é garantido para funcionar em todas as
            implementações de Scheme, embora para qualquer implementação haja
            uma variação simples que funcionará. O problema tem a ver com
            diferenças sutis na forma como as implementações de Scheme lidam com
            definições internas. (Veja
            <a href="4_002e1.html#g_t4_002e1_002e6">4.1.6</a>.)
          </p>
        </div>
        <div id="FOOT200">
          <p>
            <a class="footnote_backlink" href="#DOCF200"><sup>200</sup></a> Esta
            é uma pequena reflexão, em Lisp, das dificuldades que linguagens
            convencionais fortemente tipadas, como Pascal, têm para lidar com
            procedimentos de ordem superior. Nessas linguagens, o programador
            deve especificar os tipos de dados dos argumentos e o resultado de
            cada procedimento: número, valor lógico, sequência e assim por
            diante. Consequentemente, não poderíamos expressar uma abstração
            como “mapear um determinado procedimento <code>proc</code> sobre
            todos os elementos de uma sequência” por um único procedimento de
            ordem superior como <code>stream-map</code>. Em vez disso,
            precisaríamos de um procedimento de mapeamento diferente para cada
            combinação diferente de tipos de dados de argumento e resultado que
            pudesse ser especificada para um <code>proc</code>. Manter uma noção
            prática de “tipo de dados” na presença de procedimentos de ordem
            superior levanta muitas questões difíceis. Uma forma de lidar com
            esse problema é ilustrada pela linguagem ML (<a
              href="References.html#Gordon-et-al_002e-1979"
              >Gordon et al. 1979</a
            >), cujos “tipos de dados polimórficos” incluem modelos para
            transformações de ordem superior entre tipos de dados. Além disso,
            os tipos de dados para a maioria dos procedimentos em ML nunca são
            explicitamente declarados pelo programador. Em vez disso, ML inclui
            um mecanismo de <a id="index-type_002dinferencing"></a>
            <em>inferência de tipos</em> que usa informações no ambiente para
            deduzir os tipos de dados para procedimentos recém-definidos.
          </p>
        </div>
        <div id="FOOT201">
          <p>
            <a class="footnote_backlink" href="#DOCF201"><sup>201</sup></a> Da
            mesma forma na física, quando observamos uma partícula em movimento,
            dizemos que a posição (estado) da partícula está mudando. No
            entanto, da perspectiva da linha do mundo da partícula no
            espaço-tempo, não há mudança envolvida.
          </p>
        </div>
        <div id="FOOT202">
          <p>
            <a class="footnote_backlink" href="#DOCF202"><sup>202</sup></a> John
            Backus, o inventor do Fortran, deu grande visibilidade à programação
            funcional quando foi premiado com o prêmio <abbr>ACM</abbr> Turing
            em 1978. Seu discurso de aceitação (<a
              href="References.html#Backus-1978"
              >Backus 1978</a
            >) defendeu fortemente a abordagem funcional. Uma boa visão geral da
            programação funcional é dada em
            <a href="References.html#Henderson-1980">Henderson 1980</a> e em
            <a href="References.html#Darlington-et-al_002e-1982"
              >Darlington et al. 1982</a
            >.
          </p>
        </div>
        <div id="FOOT203">
          <p>
            <a class="footnote_backlink" href="#DOCF203"><sup>203</sup></a>
            Observe que, para quaisquer dois fluxos, há em geral mais de uma
            ordem aceitável de intercalação. Assim, tecnicamente, “merge” é uma
            relação em vez de uma função—a resposta não é uma função
            determinística dos insumos. Já mencionamos (<a
              href="3_002e4.html#Footnote-167"
              >Nota de rodapé 167</a
            >) que o não determinismo é essencial ao lidar com concorrência. A
            relação de merge ilustra o mesmo não determinismo essencial, da
            perspectiva funcional. Em
            <a href="4_002e3.html#g_t4_002e3">4.3</a>, veremos o não
            determinismo de mais um ponto de vista.
          </p>
        </div>
        <div id="FOOT204">
          <p>
            <a class="footnote_backlink" href="#DOCF204"><sup>204</sup></a> O
            modelo de objeto aproxima o mundo dividindo-o em partes separadas. O
            modelo funcional não modulariza ao longo das fronteiras dos objetos.
            O modelo de objeto é útil quando o estado não compartilhado dos
            “objetos” é muito maior do que o estado que eles compartilham. Um
            exemplo de um lugar onde o ponto de vista do objeto falha é a
            mecânica quântica, onde pensar nas coisas como partículas
            individuais leva a paradoxos e confusões. Unificar a visão de objeto
            com a visão funcional pode ter pouco a ver com programação, mas sim
            com questões epistemológicas fundamentais.
          </p>
        </div>
      </div>
      <nav class="header">
        <p>
          Próximo:
          <a href="Chapter-4.html#Chapter-4" accesskey="n" rel="next"
            >Capítulo 4</a
          >, Anterior:
          <a href="3_002e4.html#g_t3_002e4" accesskey="p" rel="prev">3.4</a>,
          Acima: <a href="#g_t3_002e5" accesskey="u" rel="prev">3.5</a> [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Índice</a
          >]
        </p>
      </nav>
    </section>
    <span class="bottom jump" title="Jump to bottom"
      ><a href="#pagebottom" accesskey="b">⇣</a></span
    ><a id="pagebottom"></a>
  </body>
</html>
