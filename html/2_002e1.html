<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.2"
    />
    <meta
      name="keywords"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.2"
    />
    <title>
      Estrutura e Interpretação de Programas de Computador, 2ª edição: 2.1
    </title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/highlight.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="js/jquery.min.js"></script>
    <script src="js/footnotes.js"></script>
    <script src="js/browsertest.js"></script>
  </head>
  <body>
    <section>
      <span class="top jump" title="Ir para o topo"
        ><a href="#pagetop" accesskey="t">⇡</a></span
      >
      <a id="pagetop"></a>
      <a id="g_t2_002e1"></a>
      <nav class="header">
        <p>
          Próximo:
          <a href="2_002e2.html#g_t2_002e2" accesskey="n" rel="next">2.2</a>,
          Anterior:
          <a href="Chapter-2.html#Chapter-2" accesskey="p" rel="prev"
            >Capítulo 2</a
          >, Acima:
          <a href="Chapter-2.html#Chapter-2" accesskey="u" rel="prev"
            >Capítulo 2</a
          >
          [<a
            href="index.html#SEC_Contents"
            title="Sumário"
            accesskey="c"
            rel="contents"
            >Sumário</a
          >]
        </p>
      </nav>
      <a id="Introduction-to-Data-Abstraction"></a>
      <h3 class="section">
        <span class="secnum">2.1</span
        ><span class="sectitle">Introdução à Abstração de Dados</span>
      </h3>

      <p>
        Em <a href="1_002e1.html#g_t1_002e1_002e8">1.1.8</a>, observamos que um
        procedimento usado como um elemento na criação de um procedimento mais
        complexo poderia ser considerado não apenas como uma coleção de
        operações específicas, mas também como uma abstração procedural. Ou
        seja, os detalhes de como o procedimento foi implementado poderiam ser
        suprimidos, e o próprio procedimento poderia ser substituído por
        qualquer outro procedimento com o mesmo comportamento geral. Em outras
        palavras, poderíamos fazer uma abstração que separaria a maneira como o
        procedimento seria usado dos detalhes de como o procedimento seria
        implementado em termos de procedimentos mais primitivos. A noção análoga
        para dados compostos é chamada de <a id="index-data-abstraction-1"></a>
        <em>abstração de dados</em>. A abstração de dados é uma metodologia que
        nos permite isolar como um objeto de dados composto é usado dos detalhes
        de como ele é construído a partir de objetos de dados mais primitivos.
      </p>
      <p>
        A ideia básica da abstração de dados é estruturar os programas que usam
        objetos de dados compostos para que operem em "dados abstratos". Ou
        seja, nossos programas devem usar dados de forma a não fazer suposições
        sobre os dados que não sejam estritamente necessárias para realizar a
        tarefa em questão. Ao mesmo tempo, uma representação de dados "concreta"
        é definida independentemente dos programas que usam os dados. A
        interface entre essas duas partes do nosso sistema será um conjunto de
        procedimentos, chamados <a id="index-selectors"></a>
        <em>seletores</em> e <a id="index-constructors"></a>
        <em>construtores</em>, que implementam os dados abstratos em termos da
        representação concreta. Para ilustrar essa técnica, consideraremos como
        projetar um conjunto de procedimentos para manipular números racionais.
      </p>

      <a id="g_t2_002e1_002e1"></a>
      <a id="Example_003a-Arithmetic-Operations-for-Rational-Numbers"></a>
      <h4 class="subsection">
        <span class="secnum">2.1.1</span
        ><span class="sectitle"
          >Exemplo: Operações Aritméticas para Números Racionais</span
        >
      </h4>

      <p>
        Suponha que queremos fazer aritmética com números racionais. Queremos
        ser capazes de somar, subtrair, multiplicar e dividir eles e testar se
        dois números racionais são iguais.
      </p>
      <p>
        Vamos começar assumindo que já temos uma maneira de construir um número
        racional a partir de um numerador e um denominador. Também assumimos
        que, dado um número racional, temos uma maneira de extrair (ou
        selecionar) seu numerador e seu denominador. Vamos ainda assumir que o
        construtor e os seletores estão disponíveis como procedimentos:
      </p>
      <ul>
        <li>
          <code>(make-rat ⟨<var>n</var>⟩ ⟨<var>d</var>⟩)</code> retorna o número
          racional cujo numerador é o inteiro <code>⟨<var>n</var>⟩</code> e cujo
          denominador é o inteiro <code>⟨<var>d</var>⟩</code>.
        </li>
        <li>
          <code>(numer ⟨<var>x</var>⟩)</code> retorna o numerador do número
          racional <code>⟨<var>x</var>⟩</code>.
        </li>
        <li>
          <code>(denom ⟨<var>x</var>⟩)</code> retorna o denominador do número
          racional <code>⟨<var>x</var>⟩</code>.
        </li>
      </ul>

      <p>
        Estamos usando aqui uma poderosa estratégia de síntese:
        <a id="index-wishful-thinking"></a> <em>pensamento desejoso</em>. Ainda
        não dissemos como um número racional é representado, ou como os
        procedimentos <code>numer</code>, <code>denom</code> e
        <code>make-rat</code> devem ser implementados. Mesmo assim, se
        tivéssemos esses três procedimentos, poderíamos então somar, subtrair,
        multiplicar, dividir e testar a igualdade usando as seguintes relações:
      </p>
      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <!-- Fórmulas matemáticas aqui -->
      </math>
      <p>Podemos expressar essas regras como procedimentos:</p>
      <pre><code class="language-scheme">(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))</code></pre>

      <p>
        Agora temos as operações sobre números racionais definidas em termos dos
        procedimentos seletor e construtor <code>numer</code>,
        <code>denom</code> e <code>make-rat</code>. Mas ainda não definimos
        esses procedimentos. O que precisamos é de alguma maneira de unir um
        numerador e um denominador para formar um número racional.
      </p>
      <a id="Pairs"></a>
      <h5 class="subsubheading">Pares</h5>

      <p>
        Para nos permitir implementar o nível concreto de nossa abstração de
        dados, nossa linguagem fornece uma estrutura composta chamada
        <a id="index-pair"></a> <em>par</em>, que pode ser construída com o
        procedimento primitivo <code>cons</code>. Este procedimento recebe dois
        argumentos e retorna um objeto de dados composto que contém os dois
        argumentos como partes. Dado um par, podemos extrair as partes usando os
        procedimentos primitivos <code>car</code> e <code>cdr</code>.<a
          class="footnote_link"
          id="DOCF68"
          href="#FOOT68"
          ><sup>68</sup></a
        >
        Assim, podemos usar <code>cons</code>, <code>car</code> e
        <code>cdr</code> da seguinte forma:
      </p>
      <pre><code class="language-scheme">(define x (cons 1 2))

(car x)
1

(cdr x)
2</code></pre>

      <p>
        Observe que um par é um objeto de dados que pode ser nomeado e
        manipulado, assim como um objeto de dados primitivo. Além disso,
        <code>cons</code> pode ser usado para formar pares cujos elementos são
        pares, e assim por diante:
      </p>
      <pre><code class="language-scheme">(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))

(car (car z))
1

(car (cdr z))
3</code></pre>

      <p>
        Em <a href="2_002e2.html#g_t2_002e2">2.2</a> veremos como essa
        capacidade de combinar pares significa que pares podem ser usados como
        blocos de construção de propósito geral para criar todos os tipos de
        estruturas de dados complexas. O único primitivo de dados compostos
        <a id="index-pair-1"></a> <em>par</em>, implementado pelos procedimentos
        <code>cons</code>, <code>car</code> e <code>cdr</code>, é a única cola
        que precisamos. Objetos de dados construídos a partir de pares são
        chamados de <a id="index-list_002dstructured"></a>
        <em>dados estruturados em listas</em>.
      </p>
      <a id="Representing-rational-numbers"></a>
      <h5 class="subsubheading">Representando números racionais</h5>

      <p>
        Pares oferecem uma maneira natural de completar o sistema de números
        racionais. Simplesmente representamos um número racional como um par de
        dois inteiros: um numerador e um denominador. Então
        <code>make-rat</code>, <code>numer</code> e <code>denom</code> são
        facilmente implementados da seguinte forma:<a
          class="footnote_link"
          id="DOCF69"
          href="#FOOT69"
          ><sup>69</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))</code></pre>

      <p>
        Além disso, para exibir os resultados de nossas computações, podemos
        imprimir números racionais imprimindo o numerador, uma barra e o
        denominador:<a class="footnote_link" id="DOCF70" href="#FOOT70"
          ><sup>70</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))</code></pre>

      <p>Agora podemos testar nossos procedimentos de números racionais:</p>
      <pre><code class="language-scheme">(define one-half (make-rat 1 2))
(print-rat one-half)
1/2

(define one-third (make-rat 1 3))
(print-rat
 (add-rat one-half one-third))
5/6

(print-rat
 (mul-rat one-half one-third))
1/6

(print-rat
 (add-rat one-third one-third))
6/9</code></pre>

      <p>
        Como o exemplo final mostra, nossa implementação de números racionais
        não reduz números racionais aos termos mais baixos. Podemos remediar
        isso mudando <code>make-rat</code>. Se tivermos um procedimento
        <code>gcd</code> como o de
        <a href="1_002e2.html#g_t1_002e2_002e5">1.2.5</a> que produz o maior
        divisor comum de dois inteiros, podemos usar <code>gcd</code> para
        reduzir o numerador e o denominador aos termos mais baixos antes de
        construir o par:
      </p>
      <pre><code class="language-scheme">(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) 
          (/ d g))))</code></pre>

      <p>Agora temos</p>
      <pre><code class="language-scheme">(print-rat 
 (add-rat one-third one-third))
2/3</code></pre>

      <p>
        como desejado. Essa modificação foi realizada mudando o construtor
        <code>make-rat</code> sem alterar nenhum dos procedimentos (como
        <code>add-rat</code> e <code>mul-rat</code>) que implementam as
        operações reais.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e1"></a>Exercício 2.1:</strong> Defina
          uma versão melhor de <code>make-rat</code> que lida com argumentos
          positivos e negativos. <code>Make-rat</code> deve normalizar o sinal
          de forma que, se o número racional for positivo, tanto o numerador
          quanto o denominador sejam positivos, e se o número racional for
          negativo, apenas o numerador seja negativo.
        </p>
      </blockquote>

      <a id="g_t2_002e1_002e2"></a>
      <a id="Abstraction-Barriers"></a>
      <h4 class="subsection">
        <span class="secnum">2.1.2</span
        ><span class="sectitle">Barreiras de Abstração</span>
      </h4>

      <p>
        Antes de continuar com mais exemplos de dados compostos e abstração de
        dados, vamos considerar algumas das questões levantadas pelo exemplo dos
        números racionais. Definimos as operações de números racionais em termos
        de um construtor <code>make-rat</code> e seletores <code>numer</code> e
        <code>denom</code>. Em geral, a ideia subjacente da abstração de dados é
        identificar para cada tipo de objeto de dados um conjunto básico de
        operações em termos das quais todas as manipulações de objetos de dados
        desse tipo serão expressas, e então usar apenas essas operações na
        manipulação dos dados.
      </p>
      <p>
        Podemos visualizar a estrutura do sistema de números racionais como
        mostrado na <a href="#Figure-2_002e1">Figura 2.1</a>. As linhas
        horizontais representam <a id="index-abstraction-barriers-1"></a>
        <em>barreiras de abstração</em> que isolam diferentes "níveis" do
        sistema. Em cada nível, a barreira separa os programas (acima) que usam
        a abstração de dados dos programas (abaixo) que implementam a abstração
        de dados. Programas que usam números racionais os manipulam apenas em
        termos dos procedimentos fornecidos "para uso público" pelo pacote de
        números racionais: <code>add-rat</code>, <code>sub-rat</code>,
        <code>mul-rat</code>, <code>div-rat</code> e <code>equal-rat?</code>.
        Estes, por sua vez, são implementados apenas em termos do construtor e
        dos seletores <code>make-rat</code>, <code>numer</code> e
        <code>denom</code>, que por sua vez são implementados em termos de
        pares. Os detalhes de como os pares são implementados são irrelevantes
        para o restante do pacote de números racionais, desde que os pares
        possam ser manipulados pelo uso de <code>cons</code>, <code>car</code> e
        <code>cdr</code>. Na prática, os procedimentos em cada nível são as
        interfaces que definem as barreiras de abstração e conectam os
        diferentes níveis.
      </p>
      <figure class="float">
        <a id="Figure-2_002e1"></a>
        <object
          style="width: 48.87ex; height: 38.08ex"
          data="fig/chap2/Fig2.1d.std.svg"
          type="image/svg+xml"
        >
          SVG
        </object>
        <figcaption class="float-caption">
          <p>
            <strong>Figura 2.1:</strong> Barreiras de abstração de dados no
            pacote de números racionais.
          </p>
        </figcaption>
      </figure>

      <p>
        Essa ideia simples tem muitas vantagens. Uma vantagem é que torna os
        programas muito mais fáceis de manter e modificar. Qualquer estrutura de
        dados complexa pode ser representada de várias maneiras com as
        estruturas de dados primitivas fornecidas por uma linguagem de
        programação. É claro que a escolha da representação influencia os
        programas que operam nela; assim, se a representação fosse alterada em
        algum momento posterior, todos esses programas poderiam ter que ser
        modificados de acordo. Essa tarefa poderia ser demorada e cara no caso
        de programas grandes, a menos que a dependência da representação fosse
        confinada por design a muito poucos módulos de programa.
      </p>
      <p>
        Por exemplo, uma maneira alternativa de abordar o problema de reduzir
        números racionais aos termos mais baixos é realizar a redução sempre que
        acessamos as partes de um número racional, em vez de quando o
        construímos. Isso leva a diferentes procedimentos construtores e
        seletores:
      </p>
      <pre><code class="language-scheme">(define (make-rat n d)
  (cons n d))

(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))

(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))</code></pre>

      <p>
        A diferença entre essa implementação e a anterior está em quando
        calculamos o <code>gcd</code>. Se, em nosso uso típico de números
        racionais, acessarmos os numeradores e denominadores dos mesmos números
        racionais muitas vezes, seria preferível calcular o
        <code>gcd</code> quando os números racionais são construídos. Caso
        contrário, pode ser melhor esperar até o momento do acesso para calcular
        o <code>gcd</code>. Em qualquer caso, quando mudamos de uma
        representação para a outra, os procedimentos <code>add-rat</code>,
        <code>sub-rat</code> e assim por diante não precisam ser modificados.
      </p>
      <p>
        Restringir a dependência da representação a alguns poucos procedimentos
        de interface nos ajuda a projetar programas, bem como a modificá-los,
        porque nos permite manter a flexibilidade de considerar implementações
        alternativas. Para continuar com nosso exemplo simples, suponha que
        estamos projetando um pacote de números racionais e não podemos decidir
        inicialmente se devemos realizar o <code>gcd</code> no momento da
        construção ou no momento da seleção. A metodologia de abstração de dados
        nos dá uma maneira de adiar essa decisão sem perder a capacidade de
        progredir no restante do sistema.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e2"></a>Exercício 2.2:</strong> Considere
          o problema de representar segmentos de linha em um plano. Cada
          segmento é representado como um par de pontos: um ponto inicial e um
          ponto final. Defina um construtor <code>make-segment</code> e
          seletores <code>start-segment</code> e <code>end-segment</code> que
          definem a representação de segmentos em termos de pontos. Além disso,
          um ponto pode ser representado como um par de números: a coordenada
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> e a
          coordenada
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math
          >. Assim, especifique um construtor <code>make-point</code> e
          seletores <code>x-point</code> e <code>y-point</code> que definem essa
          representação. Finalmente, usando seus seletores e construtores,
          defina um procedimento <code>midpoint-segment</code> que recebe um
          segmento de linha como argumento e retorna seu ponto médio (o ponto
          cujas coordenadas são a média das coordenadas dos pontos finais). Para
          testar seus procedimentos, você precisará de uma maneira de imprimir
          pontos:
        </p>
        <pre><code class="language-scheme">(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e3"></a>Exercício 2.3:</strong>
          Implemente uma representação para retângulos em um plano. (Dica: Você
          pode querer fazer uso do
          <a href="#Exercise-2_002e2">Exercício 2.2</a>.) Em termos de seus
          construtores e seletores, crie procedimentos que calculem o perímetro
          e a área de um retângulo dado. Agora implemente uma representação
          diferente para retângulos. Você pode projetar seu sistema com
          barreiras de abstração adequadas, de modo que os mesmos procedimentos
          de perímetro e área funcionem usando qualquer representação?
        </p>
      </blockquote>

      <a id="g_t2_002e1_002e3"></a>
      <a id="What-Is-Meant-by-Data_003f"></a>
      <h4 class="subsection">
        <span class="secnum">2.1.3</span
        ><span class="sectitle">O Que Se Entende por Dados?</span>
      </h4>

      <p>
        Começamos a implementação de números racionais em
        <a href="#g_t2_002e1_002e1">2.1.1</a> implementando as operações de
        números racionais <code>add-rat</code>, <code>sub-rat</code> e assim por
        diante em termos de três procedimentos não especificados:
        <code>make-rat</code>, <code>numer</code> e <code>denom</code>. Naquele
        ponto, poderíamos pensar nas operações como sendo definidas em termos de
        objetos de dados — numeradores, denominadores e números racionais — cujo
        comportamento era especificado por esses três procedimentos.
      </p>
      <p>
        Mas o que exatamente se entende por <a id="index-data-1"></a>
        <em>dados</em>? Não basta dizer "o que quer que seja implementado pelos
        seletores e construtores dados". Claramente, nem todo conjunto
        arbitrário de três procedimentos pode servir como base apropriada para a
        implementação de números racionais. Precisamos garantir que, se
        construirmos um número racional <code>x</code> a partir de um par de
        inteiros <code>n</code> e <code>d</code>, então extrair o
        <code>numer</code> e o <code>denom</code> de <code>x</code> e dividi-los
        deve produzir o mesmo resultado que dividir <code>n</code> por
        <code>d</code>. Em outras palavras, <code>make-rat</code>,
        <code>numer</code> e <code>denom</code> devem satisfazer a condição de
        que, para qualquer inteiro <code>n</code> e qualquer inteiro não nulo
        <code>d</code>, se <code>x</code> for <code>(make-rat n d)</code>, então
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mtext>(numer x)</mtext>
              <mtext>(denom x)</mtext>
            </mfrac>
          </mrow>
          <mo>=</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mtext>n</mtext>
                <mtext>d</mtext>
              </mfrac>
            </mrow>
            <mo>.</mo>
          </mrow>
        </math>
        Na verdade, essa é a única condição que <code>make-rat</code>,
        <code>numer</code> e <code>denom</code> devem cumprir para formar uma
        base adequada para uma representação de números racionais. Em geral,
        podemos pensar em dados como definidos por alguma coleção de seletores e
        construtores, juntamente com condições especificadas que esses
        procedimentos devem cumprir para ser uma representação válida.<a
          class="footnote_link"
          id="DOCF71"
          href="#FOOT71"
          ><sup>71</sup></a
        >
      </p>
      <p>
        Esse ponto de vista pode servir para definir não apenas objetos de dados
        de "alto nível", como números racionais, mas também objetos de nível
        mais baixo. Considere a noção de par, que usamos para definir nossos
        números racionais. Nunca dissemos o que era um par, apenas que a
        linguagem fornecia procedimentos <code>cons</code>, <code>car</code> e
        <code>cdr</code> para operar em pares. Mas a única coisa que precisamos
        saber sobre essas três operações é que, se colarmos dois objetos usando
        <code>cons</code>, podemos recuperar os objetos usando
        <code>car</code> e <code>cdr</code>. Ou seja, as operações satisfazem a
        condição de que, para quaisquer objetos <code>x</code> e <code>y</code>,
        se <code>z</code> for <code>(cons x y)</code>, então
        <code>(car z)</code> é <code>x</code> e <code>(cdr z)</code> é
        <code>y</code>. De fato, mencionamos que esses três procedimentos são
        incluídos como primitivos em nossa linguagem. No entanto, qualquer
        tripla de procedimentos que satisfaça a condição acima pode ser usada
        como base para implementar pares. Esse ponto é ilustrado de forma
        impressionante pelo fato de que poderíamos implementar
        <code>cons</code>, <code>car</code> e <code>cdr</code> sem usar nenhuma
        estrutura de dados, mas apenas usando procedimentos. Aqui estão as
        definições:
      </p>
      <pre><code class="language-scheme">(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else 
           (error "Argument not 0 or 1:
                   CONS" m))))
  dispatch)

(define (car z) (z 0))
(define (cdr z) (z 1))</code></pre>

      <p>
        Esse uso de procedimentos não corresponde a nada parecido com nossa
        noção intuitiva do que dados deveriam ser. No entanto, tudo o que
        precisamos fazer para mostrar que essa é uma maneira válida de
        representar pares é verificar que esses procedimentos satisfazem a
        condição dada acima.
      </p>
      <p>
        O ponto sutil a ser notado é que o valor retornado por
        <code>(cons x y)</code> é um procedimento — ou seja, o procedimento
        internamente definido <code>dispatch</code>, que recebe um argumento e
        retorna <code>x</code> ou <code>y</code> dependendo de se o argumento é
        0 ou 1. Correspondentemente, <code>(car z)</code> é definido para
        aplicar <code>z</code> a 0. Portanto, se <code>z</code> for o
        procedimento formado por <code>(cons x y)</code>, então
        <code>z</code> aplicado a 0 retornará <code>x</code>. Assim, mostramos
        que <code>(car (cons x y))</code> retorna <code>x</code>, como desejado.
        Da mesma forma, <code>(cdr (cons x y))</code> aplica o procedimento
        retornado por <code>(cons x y)</code> a 1, que retorna <code>y</code>.
        Portanto, essa implementação procedural de pares é uma implementação
        válida, e se acessarmos pares usando apenas <code>cons</code>,
        <code>car</code> e <code>cdr</code>, não podemos distinguir essa
        implementação de uma que usa estruturas de dados "reais".
      </p>
      <p>
        O ponto de exibir a representação procedural de pares não é que nossa
        linguagem funcione dessa maneira (Scheme, e sistemas Lisp em geral,
        implementam pares diretamente, por razões de eficiência), mas que
        poderia funcionar dessa maneira. A representação procedural, embora
        obscura, é uma maneira perfeitamente adequada de representar pares, já
        que cumpre as únicas condições que os pares precisam cumprir. Esse
        exemplo também demonstra que a capacidade de manipular procedimentos
        como objetos automaticamente fornece a capacidade de representar dados
        compostos. Isso pode parecer uma curiosidade agora, mas as
        representações procedurais de dados desempenharão um papel central em
        nosso repertório de programação. Esse estilo de programação é
        frequentemente chamado de <a id="index-message-passing"></a>
        <em>passagem de mensagens</em>, e o usaremos como uma ferramenta básica
        no <a href="Chapter-3.html#Chapter-3">Capítulo 3</a> quando abordarmos
        as questões de modelagem e simulação.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e4"></a>Exercício 2.4:</strong> Aqui está
          uma representação procedural alternativa de pares. Para essa
          representação, verifique que <code>(car (cons x y))</code> retorna
          <code>x</code> para quaisquer objetos <code>x</code> e <code>y</code>.
        </p>
        <pre><code class="language-scheme">(define (cons x y) 
  (lambda (m) (m x y)))

(define (car z) 
  (z (lambda (p q) p)))</code></pre>

        <p>
          Qual é a definição correspondente de <code>cdr</code>? (Dica: Para
          verificar que isso funciona, use o modelo de substituição de
          <a href="1_002e1.html#g_t1_002e1_002e5">1.1.5</a>.)
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e5"></a>Exercício 2.5:</strong> Mostre
          que podemos representar pares de inteiros não negativos usando apenas
          números e operações aritméticas se representarmos o par
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math> e
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math>
          como o inteiro que é o produto
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mrow class="MJX-TeXAtom-ORD"
              ><msup><mn>2</mn><mi>a</mi></msup
              ><msup><mn>3</mn><mi>b</mi></msup></mrow
            ></math
          >. Dê as definições correspondentes dos procedimentos
          <code>cons</code>, <code>car</code> e <code>cdr</code>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e6"></a>Exercício 2.6:</strong> No caso
          de representar pares como procedimentos não ser suficientemente
          surpreendente, considere que, em uma linguagem que pode manipular
          procedimentos, podemos nos virar sem números (pelo menos no que diz
          respeito a inteiros não negativos) implementando 0 e a operação de
          adicionar 1 como
        </p>
        <pre><code class="language-scheme">(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))</code></pre>

        <p>
          Essa representação é conhecida como
          <a id="index-Church-numerals"></a> <em>numerais de Church</em>, em
          homenagem ao seu inventor, Alonzo Church, o lógico que inventou o
          λ-cálculo.
        </p>
        <p>
          Defina <code>one</code> e <code>two</code> diretamente (não em termos
          de <code>zero</code> e <code>add-1</code>). (Dica: Use substituição
          para avaliar <code>(add-1 zero)</code>). Dê uma definição direta do
          procedimento de adição <code>+</code> (não em termos de aplicação
          repetida de <code>add-1</code>).
        </p>
      </blockquote>

      <a id="g_t2_002e1_002e4"></a>
      <a id="Extended-Exercise_003a-Interval-Arithmetic"></a>
      <h4 class="subsection">
        <span class="secnum">2.1.4</span
        ><span class="sectitle"
          >Exercício Estendido: Aritmética de Intervalos</span
        >
      </h4>

      <p>
        Alyssa P. Hacker está projetando um sistema para ajudar as pessoas a
        resolver problemas de engenharia. Uma das funcionalidades que ela deseja
        fornecer em seu sistema é a capacidade de manipular quantidades inexatas
        (como parâmetros medidos de dispositivos físicos) com precisão
        conhecida, de modo que, quando os cálculos são feitos com essas
        quantidades aproximadas, os resultados sejam números de precisão
        conhecida.
      </p>
      <p>
        Engenheiros elétricos estarão usando o sistema de Alyssa para calcular
        quantidades elétricas. Às vezes, é necessário para eles calcular o valor
        de uma resistência equivalente em paralelo
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><msub><mi>R</mi><mi>p</mi></msub></math
        >
        de dois resistores
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><msub><mi>R</mi><mn>1</mn></msub></math
        >
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><msub><mi>R</mi><mn>2</mn></msub></math
        >
        usando a fórmula
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <msub>
            <mi>R</mi>
            <mi>p</mi>
          </msub>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mrow>
                  <mn>1</mn>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo>/</mo>
                  </mrow>
                  <msub>
                    <mi>R</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>+</mo>
                  <mn>1</mn>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo>/</mo>
                  </mrow>
                  <msub>
                    <mi>R</mi>
                    <mn>2</mn>
                  </msub>
                </mrow>
              </mfrac>
            </mrow>
            <mo>.</mo>
          </mrow>
        </math>
        Os valores de resistência geralmente são conhecidos apenas até alguma
        tolerância garantida pelo fabricante do resistor. Por exemplo, se você
        comprar um resistor rotulado como "6,8 ohms com 10% de tolerância", você
        só pode ter certeza de que o resistor tem uma resistência entre 6,8
        <math xmlns="http://www.w3.org/1998/Math/MathML"
          ><mo>−<!-- − --></mo></math
        >
        0,68 = 6,12 e 6,8 + 0,68 = 7,48 ohms. Assim, se você tiver um resistor
        de 6,8 ohms com 10% de tolerância em paralelo com um resistor de 4,7
        ohms com 5% de tolerância, a resistência da combinação pode variar de
        cerca de 2,58 ohms (se os dois resistores estiverem nos limites
        inferiores) a cerca de 2,97 ohms (se os dois resistores estiverem nos
        limites superiores).
      </p>
      <p>
        A ideia de Alyssa é implementar "aritmética de intervalos" como um
        conjunto de operações aritméticas para combinar "intervalos" (objetos
        que representam a faixa de valores possíveis de uma quantidade inexata).
        O resultado de somar, subtrair, multiplicar ou dividir dois intervalos é
        ele mesmo um intervalo, representando a faixa do resultado.
      </p>
      <p>
        Alyssa postula a existência de um objeto abstrato chamado "intervalo"
        que tem dois pontos finais: um limite inferior e um limite superior. Ela
        também presume que, dados os pontos finais de um intervalo, ela pode
        construir o intervalo usando o construtor de dados
        <code>make-interval</code>. Alyssa primeiro escreve um procedimento para
        somar dois intervalos. Ela raciocina que o valor mínimo que a soma
        poderia ser é a soma dos dois limites inferiores e o valor máximo que
        poderia ser é a soma dos dois limites superiores:
      </p>
      <pre><code class="language-scheme">(define (add-interval x y)
  (make-interval (+ (lower-bound x) 
                    (lower-bound y))
                 (+ (upper-bound x) 
                    (upper-bound y))))</code></pre>

      <p>
        Alyssa também trabalha no produto de dois intervalos encontrando o
        mínimo e o máximo dos produtos dos limites e usando-os como os limites
        do intervalo resultante. (<code>Min</code> e <code>max</code> são
        primitivas que encontram o mínimo ou o máximo de qualquer número de
        argumentos.)
      </p>
      <pre><code class="language-scheme">(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) 
               (lower-bound y)))
        (p2 (* (lower-bound x) 
               (upper-bound y)))
        (p3 (* (upper-bound x) 
               (lower-bound y)))
        (p4 (* (upper-bound x) 
               (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))</code></pre>

      <p>
        Para dividir dois intervalos, Alyssa multiplica o primeiro pelo inverso
        do segundo. Observe que os limites do intervalo inverso são o inverso do
        limite superior e o inverso do limite inferior, nessa ordem.
      </p>
      <pre><code class="language-scheme">(define (div-interval x y)
  (mul-interval x 
                (make-interval 
                 (/ 1.0 (upper-bound y)) 
                 (/ 1.0 (lower-bound y)))))</code></pre>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e7"></a>Exercício 2.7:</strong> O
          programa de Alyssa está incompleto porque ela não especificou a
          implementação da abstração de intervalo. Aqui está uma definição do
          construtor de intervalo:
        </p>
        <pre><code class="language-scheme">(define (make-interval a b) (cons a b))</code></pre>

        <p>
          Defina seletores <code>upper-bound</code> e
          <code>lower-bound</code> para completar a implementação.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e8"></a>Exercício 2.8:</strong> Usando
          raciocínio análogo ao de Alyssa, descreva como a diferença de dois
          intervalos pode ser calculada. Defina um procedimento de subtração
          correspondente, chamado <code>sub-interval</code>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e9"></a>Exercício 2.9:</strong> A
          <a id="index-width"></a> <em>largura</em> de um intervalo é metade da
          diferença entre seus limites superior e inferior. A largura é uma
          medida da incerteza do número especificado pelo intervalo. Para
          algumas operações aritméticas, a largura do resultado da combinação de
          dois intervalos é uma função apenas das larguras dos intervalos de
          argumento, enquanto para outras a largura da combinação não é uma
          função das larguras dos intervalos de argumento. Mostre que a largura
          da soma (ou diferença) de dois intervalos é uma função apenas das
          larguras dos intervalos sendo somados (ou subtraídos). Dê exemplos
          para mostrar que isso não é verdade para multiplicação ou divisão.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e10"></a>Exercício 2.10:</strong> Ben
          Bitdiddle, um programador de sistemas especialista, olha por cima do
          ombro de Alyssa e comenta que não está claro o que significa dividir
          por um intervalo que abrange zero. Modifique o código de Alyssa para
          verificar essa condição e sinalizar um erro se ela ocorrer.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e11"></a>Exercício 2.11:</strong> De
          passagem, Ben também comenta de forma críptica: "Ao testar os sinais
          dos pontos finais dos intervalos, é possível dividir
          <code>mul-interval</code> em nove casos, apenas um dos quais requer
          mais de duas multiplicações." Reescreva esse procedimento usando a
          sugestão de Ben.
        </p>
        <p>
          Depois de depurar seu programa, Alyssa o mostra a um usuário
          potencial, que reclama que seu programa resolve o problema errado. Ele
          quer um programa que possa lidar com números representados como um
          valor central e uma tolerância aditiva; por exemplo, ele quer
          trabalhar com intervalos como 3,5
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mo>±<!-- ± --></mo></math
          >
          0,15 em vez de [3,35, 3,65]. Alyssa volta para sua mesa e corrige esse
          problema fornecendo um construtor alternativo e seletores
          alternativos:
        </p>
        <pre><code class="language-scheme">(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center i)
  (/ (+ (lower-bound i) 
        (upper-bound i)) 
     2))

(define (width i)
  (/ (- (upper-bound i) 
        (lower-bound i)) 
     2))</code></pre>

        <p>
          Infelizmente, a maioria dos usuários de Alyssa são engenheiros.
          Situações reais de engenharia geralmente envolvem medições com apenas
          uma pequena incerteza, medida como a razão entre a largura do
          intervalo e o ponto médio do intervalo. Engenheiros geralmente
          especificam tolerâncias percentuais nos parâmetros de dispositivos,
          como nas especificações de resistores dadas anteriormente.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e12"></a>Exercício 2.12:</strong> Defina
          um construtor <code>make-center-percent</code> que recebe um centro e
          uma tolerância percentual e produz o intervalo desejado. Você também
          deve definir um seletor <code>percent</code> que produz a tolerância
          percentual para um intervalo dado. O seletor <code>center</code> é o
          mesmo mostrado acima.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e13"></a>Exercício 2.13:</strong> Mostre
          que, sob a suposição de pequenas tolerâncias percentuais, há uma
          fórmula simples para a tolerância percentual aproximada do produto de
          dois intervalos em termos das tolerâncias dos fatores. Você pode
          simplificar o problema assumindo que todos os números são positivos.
        </p>
        <p>
          Após um trabalho considerável, Alyssa P. Hacker entrega seu sistema
          finalizado. Vários anos depois, depois que ela esqueceu tudo sobre
          isso, ela recebe uma ligação frenética de um usuário irritado, Lem E.
          Tweakit. Parece que Lem notou que a fórmula para resistores em
          paralelo pode ser escrita de duas maneiras algebricamente
          equivalentes:
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mrow>
                  <msub>
                    <mi>R</mi>
                    <mn>1</mn>
                  </msub>
                  <msub>
                    <mi>R</mi>
                    <mn>2</mn>
                  </msub>
                </mrow>
                <mrow>
                  <msub>
                    <mi>R</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>+</mo>
                  <msub>
                    <mi>R</mi>
                    <mn>2</mn>
                  </msub>
                </mrow>
              </mfrac>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mrow class="MJX-TeXAtom-ORD">
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <mn>1</mn>
                  <mrow>
                    <mn>1</mn>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mo>/</mo>
                    </mrow>
                    <msub>
                      <mi>R</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mo>/</mo>
                    </mrow>
                    <msub>
                      <mi>R</mi>
                      <mn>2</mn>
                    </msub>
                  </mrow>
                </mfrac>
              </mrow>
              <mo>.</mo>
            </mrow>
          </math>
          Ele escreveu os dois programas a seguir, cada um dos quais calcula a
          fórmula de resistores em paralelo de maneira diferente:
        </p>
        <pre><code class="language-scheme">(define (par1 r1 r2)
  (div-interval 
   (mul-interval r1 r2)
   (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval 
     one
     (add-interval 
      (div-interval one r1) 
      (div-interval one r2)))))</code></pre>

        <p>
          Lem reclama que o programa de Alyssa dá respostas diferentes para as
          duas maneiras de calcular. Essa é uma reclamação séria.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e14"></a>Exercício 2.14:</strong>
          Demonstre que Lem está certo. Investigue o comportamento do sistema em
          uma variedade de expressões aritméticas. Crie alguns intervalos
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math> e
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi></math
          >, e use-os para calcular as expressões
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mrow class="MJX-TeXAtom-ORD"
              ><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow
              ><mi>A</mi></mrow
            ></math
          >
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML"
            ><mrow class="MJX-TeXAtom-ORD"
              ><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow
              ><mi>B</mi></mrow
            ></math
          >. Você obterá mais insights usando intervalos cuja largura é uma
          pequena porcentagem do valor central. Examine os resultados da
          computação na forma de centro e porcentagem (veja
          <a href="#Exercise-2_002e12">Exercício 2.12</a>).
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e15"></a>Exercício 2.15:</strong> Eva Lu
          Ator, outra usuária, também notou os diferentes intervalos computados
          por expressões algebricamente equivalentes. Ela diz que uma fórmula
          para computar com intervalos usando o sistema de Alyssa produzirá
          limites de erro mais apertados se puder ser escrita de forma que
          nenhuma variável que represente um número incerto seja repetida.
          Assim, ela diz, <code>par2</code> é um programa "melhor" para
          resistências em paralelo do que <code>par1</code>. Ela está certa? Por
          quê?
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-2_002e16"></a>Exercício 2.16:</strong>
          Explique, em geral, por que expressões algébricas equivalentes podem
          levar a respostas diferentes. Você pode criar um pacote de aritmética
          de intervalos que não tenha essa deficiência, ou essa tarefa é
          impossível? (Aviso: Este problema é muito difícil.)
        </p>
      </blockquote>

      <div class="footnote">
        <h4 class="footnotes-heading">Notas de Rodapé</h4>

        <div id="FOOT68">
          <p>
            <a class="footnote_backlink" href="#DOCF68"><sup>68</sup></a> O nome
            <code>cons</code> significa "construir". Os nomes <code>car</code> e
            <code>cdr</code> derivam da implementação original do Lisp no IBM
            704. Essa máquina tinha um esquema de endereçamento que permitia
            referenciar as partes "endereço" e "decremento" de uma localização
            de memória. <code>Car</code> significa "Conteúdo da parte de
            Endereço do Registro" e <code>cdr</code> (pronunciado "cú-der")
            significa "Conteúdo da parte de Decremento do Registro".
          </p>
        </div>
        <div id="FOOT69">
          <p>
            <a class="footnote_backlink" href="#DOCF69"><sup>69</sup></a>
            Outra maneira de definir os seletores e o construtor é
          </p>
          <pre><code class="language-scheme">(define make-rat cons)
(define numer car)
(define denom cdr)</code></pre>

          <p>
            A primeira definição associa o nome <code>make-rat</code> ao valor
            da expressão <code>cons</code>, que é o procedimento primitivo que
            constrói pares. Assim, <code>make-rat</code> e <code>cons</code> são
            nomes para o mesmo construtor primitivo.
          </p>
          <p>
            Definir seletores e construtores dessa maneira é eficiente: Em vez
            de <code>make-rat</code> <em>chamar</em> <code>cons</code>,
            <code>make-rat</code> <em>é</em> <code>cons</code>, então há apenas
            um procedimento chamado, não dois, quando <code>make-rat</code> é
            chamado. Por outro lado, fazer isso derrota ferramentas de depuração
            que rastreiam chamadas de procedimentos ou colocam pontos de
            interrupção em chamadas de procedimentos: Você pode querer observar
            <code>make-rat</code> sendo chamado, mas certamente não quer
            observar todas as chamadas para <code>cons</code>.
          </p>
          <p>Escolhemos não usar esse estilo de definição neste livro.</p>
        </div>
        <div id="FOOT70">
          <p>
            <a class="footnote_backlink" href="#DOCF70"><sup>70</sup></a>
            <code>Display</code> é o primitivo do Scheme para imprimir dados. O
            primitivo do Scheme <code>newline</code> inicia uma nova linha para
            impressão. Nenhum desses procedimentos retorna um valor útil, então
            nos usos de <code>print-rat</code> abaixo, mostramos apenas o que
            <code>print-rat</code> imprime, não o que o interpretador imprime
            como o valor retornado por <code>print-rat</code>.
          </p>
        </div>
        <div id="FOOT71">
          <p>
            <a class="footnote_backlink" href="#DOCF71"><sup>71</sup></a>
            Surpreendentemente, essa ideia é muito difícil de formular
            rigorosamente. Existem duas abordagens para dar tal formulação. Uma,
            pioneira de C. A. R.
            <a href="References.html#Hoare-_00281972_0029">Hoare (1972)</a>, é
            conhecida como o método de <a id="index-abstract-models"></a>
            <em>modelos abstratos</em>. Ele formaliza a especificação de
            "procedimentos mais condições" como esboçado no exemplo de números
            racionais acima. Observe que a condição sobre a representação de
            números racionais foi declarada em termos de fatos sobre inteiros
            (igualdade e divisão). Em geral, modelos abstratos definem novos
            tipos de objetos de dados em termos de tipos de objetos de dados
            previamente definidos. Afirmações sobre objetos de dados podem,
            portanto, ser verificadas reduzindo-as a afirmações sobre objetos de
            dados previamente definidos. Outra abordagem, introduzida por Zilles
            no <abbr>MIT</abbr>, por Goguen, Thatcher, Wagner e Wright na IBM
            (veja
            <a href="References.html#Thatcher-et-al_002e-1978"
              >Thatcher et al. 1978</a
            >), e por Guttag em Toronto (veja
            <a href="References.html#Guttag-1977">Guttag 1977</a>), é chamada de
            <a id="index-algebraic-specification"></a>
            <em>especificação algébrica</em>. Ela considera os "procedimentos"
            como elementos de um sistema algébrico abstrato cujo comportamento é
            especificado por axiomas que correspondem às nossas "condições", e
            usa as técnicas de álgebra abstrata para verificar afirmações sobre
            objetos de dados. Ambos os métodos são examinados no artigo de
            <a href="References.html#Liskov-and-Zilles-_00281975_0029"
              >Liskov e Zilles (1975)</a
            >.
          </p>
        </div>
      </div>
      <nav class="header">
        <p>
          Próximo:
          <a href="2_002e2.html#g_t2_002e2" accesskey="n" rel="next">2.2</a>,
          Anterior:
          <a href="Chapter-2.html#Chapter-2" accesskey="p" rel="prev"
            >Capítulo 2</a
          >, Acima: <a href="#g_t2_002e1" accesskey="u" rel="prev">2.1</a> [<a
            href="index.html#SEC_Contents"
            title="Sumário"
            accesskey="c"
            rel="contents"
            >Sumário</a
          >]
        </p>
      </nav>
    </section>
    <span class="bottom jump" title="Ir para o final"
      ><a href="#pagebottom" accesskey="b">⇣</a></span
    >
    <a id="pagebottom"></a>
  </body>
</html>
