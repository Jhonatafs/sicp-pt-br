<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.3"
    />
    <meta
      name="keywords"
      content="Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.3"
    />
    <title>
      Estrutura e Interpretação de Programas de Computador, 2ª edição: 1.3
    </title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/highlight.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="js/jquery.min.js"></script>
    <script src="js/footnotes.js"></script>
    <script src="js/browsertest.js"></script>
  </head>

  <body>
    <section>
      <span class="top jump" title="Jump to top"
        ><a href="#pagetop" accesskey="t">⇡</a></span
      ><a id="pagetop"></a><a id="g_t1_002e3"></a>
      <nav class="header">
        <p>
          Próximo:
          <a href="Chapter-2.html#Chapter-2" accesskey="n" rel="next"
            >Capítulo 2</a
          >, Anterior:
          <a href="1_002e2.html#g_t1_002e2" accesskey="p" rel="prev">1.2</a>,
          Acima:
          <a href="Chapter-1.html#Chapter-1" accesskey="u" rel="prev"
            >Capítulo 1</a
          >
          [<a
            href="index.html#SEC_Contents"
            title="Table of contents"
            accesskey="c"
            rel="contents"
            >Conteúdo</a
          >]
        </p>
      </nav>
      <a id="Formulating-Abstractions-with-Higher_002dOrder-Procedures"></a>
      <h3 class="section">
        <span class="secnum">1.3</span
        ><span class="sectitle"
          >Formulando Abstrações com Procedimentos de Ordem Superior</span
        >
      </h3>

      <p>
        Vimos que procedimentos são, na verdade, abstrações que descrevem
        operações compostas sobre números, independentemente dos números
        particulares. Por exemplo, quando definimos:
      </p>

      <pre><code class="language-scheme">(define (cube x) (* x x x))</code></pre>

      <p>
        Não estamos falando sobre o cubo de um número específico, mas sim sobre
        um método para obter o cubo de qualquer número. Claro, poderíamos viver
        sem nunca definir esse procedimento, sempre escrevendo expressões como:
      </p>

      <pre><code class="language-scheme">(* 3 3 3)
(* x x x)
(* y y y)</code></pre>

      <p>
        E nunca mencionando explicitamente <code>cube</code>. Isso nos colocaria
        em uma séria desvantagem, forçando-nos a trabalhar sempre no nível das
        operações particulares que são primitivas na linguagem (multiplicação,
        neste caso), em vez de termos operações de nível mais alto. Nossos
        programas seriam capazes de calcular cubos, mas nossa linguagem
        careceria da capacidade de expressar o conceito de cubagem. Uma das
        coisas que devemos exigir de uma linguagem de programação poderosa é a
        capacidade de construir abstrações, atribuindo nomes a padrões comuns e,
        em seguida, trabalhar diretamente em termos dessas abstrações.
        Procedimentos fornecem essa capacidade. É por isso que todas as
        linguagens de programação, exceto as mais primitivas, incluem mecanismos
        para definir procedimentos.
      </p>

      <p>
        No entanto, mesmo no processamento numérico, seremos severamente
        limitados em nossa capacidade de criar abstrações se estivermos
        restritos a procedimentos cujos parâmetros devem ser números. Muitas
        vezes, o mesmo padrão de programação será usado com vários procedimentos
        diferentes. Para expressar tais padrões como conceitos, precisaremos
        construir procedimentos que possam aceitar procedimentos como argumentos
        ou retornar procedimentos como valores. Procedimentos que manipulam
        procedimentos são chamados de
        <a id="index-higher_002dorder-procedures"></a>
        <em>procedimentos de ordem superior</em>. Esta seção mostra como
        procedimentos de ordem superior podem servir como mecanismos poderosos
        de abstração, aumentando enormemente o poder expressivo de nossa
        linguagem.
      </p>

      <a id="g_t1_002e3_002e1"></a>
      <a id="Procedures-as-Arguments"></a>
      <h4 class="subsection">
        <span class="secnum">1.3.1</span
        ><span class="sectitle">Procedimentos como Argumentos</span>
      </h4>

      <p>
        Considere os seguintes três procedimentos. O primeiro calcula a soma dos
        inteiros de <code>a</code> até <code>b</code>:
      </p>

      <pre><code class="language-scheme">(define (sum-integers a b)
  (if (> a b) 
      0 
      (+ a (sum-integers (+ a 1) b))))</code></pre>

      <p>O segundo calcula a soma dos cubos dos inteiros no intervalo dado:</p>

      <pre><code class="language-scheme">(define (sum-cubes a b)
  (if (> a b) 
      0 
      (+ (cube a) 
         (sum-cubes (+ a 1) b))))</code></pre>

      <p>O terceiro calcula a soma de uma sequência de termos na série:</p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mfrac>
          <mn>1</mn>
          <mrow>
            <mn>1</mn>
            <mo>⋅<!-- ⋅ --></mo>
            <mn>3</mn>
          </mrow>
        </mfrac>
        <mo>+</mo>
        <mfrac>
          <mn>1</mn>
          <mrow>
            <mn>5</mn>
            <mo>⋅<!-- ⋅ --></mo>
            <mn>7</mn>
          </mrow>
        </mfrac>
        <mo>+</mo>
        <mfrac>
          <mn>1</mn>
          <mrow>
            <mn>9</mn>
            <mo>⋅<!-- ⋅ --></mo>
            <mn>11</mn>
          </mrow>
        </mfrac>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mo>…<!-- … --></mo>
          <mo>,</mo>
        </mrow>
      </math>

      <p>
        que converge para
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>π<!-- π --></mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mn>8</mn>
          </mrow>
        </math>
        (muito lentamente):<a class="footnote_link" id="DOCF49" href="#FOOT49"
          ><sup>49</sup></a
        >
      </p>

      <pre><code class="language-scheme">(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2))) 
         (pi-sum (+ a 4) b))))</code></pre>

      <p>
        Esses três procedimentos compartilham claramente um padrão subjacente
        comum. Eles são, na maior parte, idênticos, diferindo apenas no nome do
        procedimento, na função de <code>a</code> usada para calcular o termo a
        ser adicionado e na função que fornece o próximo valor de
        <code>a</code>. Poderíamos gerar cada um dos procedimentos preenchendo
        espaços no mesmo modelo:
      </p>

      <pre><code class="language-scheme">(define (⟨name⟩ a b)
  (if (> a b)
      0
      (+ (⟨term⟩ a) 
         (⟨name⟩ (⟨next⟩ a) b))))</code></pre>

      <p>
        A presença de tal padrão comum é uma forte evidência de que há uma
        abstração útil esperando para ser trazida à tona. De fato, os
        matemáticos há muito identificaram a abstração da
        <a id="index-summation-of-a-series"></a> <em>somação de uma série</em> e
        inventaram a “notação sigma”, por exemplo:
      </p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mrow class="MJX-TeXAtom-ORD">
          <munderover>
            <mo>∑<!-- ∑ --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>=</mo>
              <mi>a</mi>
            </mrow>
            <mi>b</mi>
          </munderover>
          <mi>f</mi>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
        </mrow>
        <mspace width="thinmathspace" />
        <mo>=</mo>
        <mspace width="thinmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mi>f</mi>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
        </mrow>
        <mo>+</mo>
        <mo>⋯<!-- ⋯ --></mo>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mi>f</mi>
          <mo stretchy="false">(</mo>
          <mi>b</mi>
          <mo stretchy="false">)</mo>
          <mo>,</mo>
        </mrow>
      </math>

      <p>
        para expressar esse conceito. O poder da notação sigma é que ela permite
        que os matemáticos lidem com o conceito de soma em si, em vez de apenas
        com somas particulares — por exemplo, para formular resultados gerais
        sobre somas que são independentes da série particular que está sendo
        somada.
      </p>

      <p>
        Da mesma forma, como projetistas de programas, gostaríamos que nossa
        linguagem fosse poderosa o suficiente para que pudéssemos escrever um
        procedimento que expressasse o conceito de soma em si, em vez de apenas
        procedimentos que calculam somas particulares. Podemos fazer isso
        facilmente em nossa linguagem procedural, tomando o modelo comum
        mostrado acima e transformando os “espaços” em parâmetros formais:
      </p>

      <pre><code class="language-scheme">(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))</code></pre>

      <p>
        Observe que <code>sum</code> recebe como argumentos os limites inferior
        e superior <code>a</code> e <code>b</code>, juntamente com os
        procedimentos <code>term</code> e <code>next</code>. Podemos usar
        <code>sum</code> como usaríamos qualquer procedimento. Por exemplo,
        podemos usá-lo (junto com um procedimento <code>inc</code> que
        incrementa seu argumento em 1) para definir <code>sum-cubes</code>:
      </p>

      <pre><code class="language-scheme">(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))</code></pre>

      <p>
        Usando isso, podemos calcular a soma dos cubos dos inteiros de 1 a 10:
      </p>

      <pre><code class="language-scheme">(sum-cubes 1 10)
<i>3025</i></code></pre>

      <p>
        Com a ajuda de um procedimento de identidade para calcular o termo,
        podemos definir <code>sum-integers</code> em termos de <code>sum</code>:
      </p>

      <pre><code class="language-scheme">(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))</code></pre>

      <p>Então podemos somar os inteiros de 1 a 10:</p>

      <pre><code class="language-scheme">(sum-integers 1 10)
<i>55</i></code></pre>

      <p>
        Também podemos definir <code>pi-sum</code> da mesma maneira:<a
          class="footnote_link"
          id="DOCF50"
          href="#FOOT50"
          ><sup>50</sup></a
        >
      </p>

      <pre><code class="language-scheme">(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))</code></pre>

      <p>
        Usando esses procedimentos, podemos calcular uma aproximação de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi> </math
        >:
      </p>

      <pre><code class="language-scheme">(* 8 (pi-sum 1 1000))
<i>3.139592655589783</i></code></pre>

      <p>
        Uma vez que temos <code>sum</code>, podemos usá-lo como um bloco de
        construção na formulação de conceitos adicionais. Por exemplo, a
        integral definida de uma função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        entre os limites
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        pode ser aproximada numericamente usando a fórmula:
      </p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mrow class="MJX-TeXAtom-ORD">
          <msubsup>
            <mo>∫<!-- ∫ --></mo>
            <mi>a</mi>
            <mi>b</mi>
          </msubsup>
          <mspace width="-0.3em" />
          <mi>f</mi>
        </mrow>
        <mspace width="thickmathspace" />
        <mo>=</mo>
        <mspace width="thickmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mrow>
            <mo>[</mo>
            <mspace width="thickmathspace" />
            <mi>f</mi>
            <mrow>
              <mo>(</mo>
              <mi>a</mi>
              <mo>+</mo>
              <mfrac>
                <mrow>
                  <mi>d</mi>
                  <mi>x</mi>
                </mrow>
                <mn>2</mn>
              </mfrac>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mspace width="thinmathspace" />
        <mo>+</mo>
        <mspace width="thinmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mi>f</mi>
          <mrow>
            <mo>(</mo>
            <mi>a</mi>
            <mo>+</mo>
            <mi>d</mi>
            <mi>x</mi>
            <mo>+</mo>
            <mfrac>
              <mrow>
                <mi>d</mi>
                <mi>x</mi>
              </mrow>
              <mn>2</mn>
            </mfrac>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mspace width="thinmathspace" />
        <mo>+</mo>
        <mspace width="thinmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mrow>
            <mi>f</mi>
            <mrow>
              <mo>(</mo>
              <mi>a</mi>
              <mo>+</mo>
              <mn>2</mn>
              <mi>d</mi>
              <mi>x</mi>
              <mo>+</mo>
              <mfrac>
                <mrow>
                  <mi>d</mi>
                  <mi>x</mi>
                </mrow>
                <mn>2</mn>
              </mfrac>
              <mo>)</mo>
            </mrow>
            <mspace width="thinmathspace" />
            <mo>+</mo>
            <mspace width="thinmathspace" />
            <mo>…<!-- … --></mo>
            <mspace width="thickmathspace" />
            <mo>]</mo>
          </mrow>
          <mi>d</mi>
          <mi>x</mi>
        </mrow>
      </math>

      <p>
        para pequenos valores de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>x</mi>
          </mrow> </math
        >. Podemos expressar isso diretamente como um procedimento:
      </p>

      <pre><code class="language-scheme">(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) 
     dx))

(integral cube 0 1 0.01)
<i>.24998750000000042</i>

(integral cube 0 1 0.001)
<i>.249999875000001</i></code></pre>

      <p>(O valor exato da integral de <code>cube</code> entre 0 e 1 é 1/4.)</p>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e29"></a>Exercício 1.29:</strong> A Regra
          de Simpson é um método mais preciso de integração numérica do que o
          método ilustrado acima. Usando a Regra de Simpson, a integral de uma
          função
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          entre
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi>
          </math>
          é aproximada como:
        </p>

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mfrac>
            <mi>h</mi>
            <mn>3</mn>
          </mfrac>
          <mo stretchy="false">(</mo>
          <msub>
            <mi>y</mi>
            <mn>0</mn>
          </msub>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>4</mn>
            <msub>
              <mi>y</mi>
              <mn>1</mn>
            </msub>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>2</mn>
            <msub>
              <mi>y</mi>
              <mn>2</mn>
            </msub>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>4</mn>
            <msub>
              <mi>y</mi>
              <mn>3</mn>
            </msub>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>2</mn>
            <msub>
              <mi>y</mi>
              <mn>4</mn>
            </msub>
          </mrow>
          <mo>+</mo>
          <mo>⋯<!-- ⋯ --></mo>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>2</mn>
            <msub>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mo>−<!-- − --></mo>
                <mn>2</mn>
              </mrow>
            </msub>
          </mrow>
          <mo>+</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>4</mn>
            <msub>
              <mi>y</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mo>−<!-- − --></mo>
                <mn>1</mn>
              </mrow>
            </msub>
            <mo>+</mo>
            <msub>
              <mi>y</mi>
              <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
            <mo>,</mo>
          </mrow>
        </math>

        <p>
          onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>h</mi>
              <mo>=</mo>
              <mo stretchy="false">(</mo>
              <mi>b</mi>
              <mo>−<!-- − --></mo>
              <mi>a</mi>
              <mo stretchy="false">)</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>n</mi>
            </mrow> </math
          >, para algum inteiro par
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>n</mi> </math>,
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>y</mi>
              <mi>k</mi>
            </msub>
            <mo>=</mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>a</mi>
              <mo>+</mo>
              <mi>k</mi>
              <mi>h</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. (Aumentar
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          aumenta a precisão da aproximação.) Defina um procedimento que recebe
          como argumentos
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi> </math>,
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>a</mi> </math>,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          e retorna o valor da integral, calculado usando a Regra de Simpson.
          Use seu procedimento para integrar <code>cube</code> entre 0 e 1 (com
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>=</mo>
              <mn>100</mn>
            </mrow>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>=</mo>
              <mn>1000</mn>
            </mrow> </math
          >), e compare os resultados com os do procedimento
          <code>integral</code> mostrado acima.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e30"></a>Exercício 1.30:</strong> O
          procedimento <code>sum</code> acima gera uma recursão linear. O
          procedimento pode ser reescrito para que a soma seja realizada
          iterativamente. Mostre como fazer isso preenchendo as expressões
          ausentes na seguinte definição:
        </p>

        <pre><code class="language-scheme">(define (sum term a next b)
  (define (iter a result)
    (if ⟨??⟩
        ⟨??⟩
        (iter ⟨??⟩ ⟨??⟩)))
  (iter ⟨??⟩ ⟨??⟩))</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e31"></a>Exercício 1.31:</strong>
        </p>
        <ol>
          <li>
            O procedimento <code>sum</code> é apenas o mais simples de um vasto
            número de abstrações semelhantes que podem ser capturadas como
            procedimentos de ordem superior.<a
              class="footnote_link"
              id="DOCF51"
              href="#FOOT51"
              ><sup>51</sup></a
            >
            Escreva um procedimento análogo chamado <code>product</code> que
            retorna o produto dos valores de uma função em pontos sobre um
            determinado intervalo. Mostre como definir <code>factorial</code> em
            termos de <code>product</code>. Também use <code>product</code> para
            calcular aproximações de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>π<!-- π --></mi>
            </math>
            usando a fórmula<a class="footnote_link" id="DOCF52" href="#FOOT52"
              ><sup>52</sup></a
            >:
          </li>
        </ol>

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mfrac>
            <mi>π<!-- π --></mi>
            <mn>4</mn>
          </mfrac>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mrow>
                <mn>2</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>4</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>4</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>6</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>6</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>8</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mo>⋯<!-- ⋯ --></mo>
              </mrow>
              <mrow>
                <mn>3</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>3</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>5</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>5</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>7</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mn>7</mn>
                <mo>⋅<!-- ⋅ --></mo>
                <mo>⋯<!-- ⋯ --></mo>
              </mrow>
            </mfrac>
            <mo>.</mo>
          </mrow>
        </math>

        <p>
          Se o seu procedimento <code>product</code> gerar um processo
          recursivo, escreva um que gere um processo iterativo. Se ele gerar um
          processo iterativo, escreva um que gere um processo recursivo.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e32"></a>Exercício 1.32:</strong>
        </p>
        <ol>
          <li>
            Mostre que <code>sum</code> e <code>product</code> (<a
              href="#Exercise-1_002e31"
              >Exercício 1.31</a
            >) são ambos casos especiais de uma noção ainda mais geral chamada
            <code>accumulate</code> que combina uma coleção de termos, usando
            alguma função de acumulação geral:
          </li>
        </ol>

        <pre><code class="language-scheme">(accumulate 
 combiner null-value term a next b)</code></pre>

        <p>
          <code>Accumulate</code> recebe como argumentos as mesmas
          especificações de termo e intervalo que <code>sum</code> e
          <code>product</code>, juntamente com um procedimento
          <code>combiner</code> (de dois argumentos) que especifica como o termo
          atual deve ser combinado com a acumulação dos termos anteriores e um
          <code>null-value</code> que especifica qual valor base usar quando os
          termos se esgotarem. Escreva <code>accumulate</code> e mostre como
          <code>sum</code> e <code>product</code> podem ser definidos como
          chamadas simples para <code>accumulate</code>.
        </p>

        <p>
          Se o seu procedimento <code>accumulate</code> gerar um processo
          recursivo, escreva um que gere um processo iterativo. Se ele gerar um
          processo iterativo, escreva um que gere um processo recursivo.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e33"></a>Exercício 1.33:</strong> Você
          pode obter uma versão ainda mais geral de <code>accumulate</code> (<a
            href="#Exercise-1_002e32"
            >Exercício 1.32</a
          >) introduzindo a noção de um <a id="index-filter"></a>
          <em>filtro</em> nos termos a serem combinados. Ou seja, combine apenas
          os termos derivados de valores no intervalo que satisfazem uma
          condição especificada. A abstração resultante
          <code>filtered-accumulate</code> recebe os mesmos argumentos que
          <code>accumulate</code>, juntamente com um predicado adicional de um
          argumento que especifica o filtro. Escreva
          <code>filtered-accumulate</code> como um procedimento. Mostre como
          expressar o seguinte usando <code>filtered-accumulate</code>:
        </p>
        <ol>
          <li>
            A soma dos quadrados dos números primos no intervalo de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>a</mi>
            </math>
            a
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>b</mi>
            </math>
            (assumindo que você já tenha um predicado
            <code>prime?</code> escrito).
          </li>
          <li>
            O produto de todos os inteiros positivos menores que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>n</mi>
            </math>
            que são relativamente primos a
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>n</mi>
            </math>
            (ou seja, todos os inteiros positivos
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>i</mi>
                <mo>&lt;</mo>
                <mi>n</mi>
              </mrow>
            </math>
            tais que
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>GCD</mtext>
                <mo stretchy="false">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>n</mi>
                <mo stretchy="false">)</mo>
                <mo>=</mo>
                <mn>1</mn>
              </mrow> </math
            >).
          </li>
        </ol>
      </blockquote>

      <a id="g_t1_002e3_002e2"></a>
      <a id="Constructing-Procedures-Using-Lambda"></a>
      <h4 class="subsection">
        <span class="secnum">1.3.2</span
        ><span class="sectitle"
          >Construindo Procedimentos Usando <code>Lambda</code></span
        >
      </h4>

      <p>
        Ao usar <code>sum</code> como em <a href="#g_t1_002e3_002e1">1.3.1</a>,
        parece muito incômodo ter que definir procedimentos triviais como
        <code>pi-term</code> e <code>pi-next</code> apenas para que possamos
        usá-los como argumentos para nosso procedimento de ordem superior. Em
        vez de definir <code>pi-next</code> e <code>pi-term</code>, seria mais
        conveniente ter uma maneira de especificar diretamente “o procedimento
        que retorna sua entrada incrementada em 4” e “o procedimento que retorna
        o recíproco de sua entrada vezes sua entrada mais 2”. Podemos fazer isso
        introduzindo a forma especial <code>lambda</code>, que cria
        procedimentos. Usando <code>lambda</code>, podemos descrever o que
        queremos como:
      </p>

      <pre><code class="language-scheme">(lambda (x) (+ x 4))</code></pre>

      <p>e</p>

      <pre><code class="language-scheme">(lambda (x) (/ 1.0 (* x (+ x 2))))</code></pre>

      <p>
        Então, nosso procedimento <code>pi-sum</code> pode ser expresso sem
        definir nenhum procedimento auxiliar como:
      </p>

      <pre><code class="language-scheme">(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))</code></pre>

      <p>
        Novamente usando <code>lambda</code>, podemos escrever o procedimento
        <code>integral</code> sem ter que definir o procedimento auxiliar
        <code>add-dx</code>:
      </p>

      <pre><code class="language-scheme">(define (integral f a b dx)
  (* (sum f (+ a (/ dx 2.0))
            (lambda (x) (+ x dx))
            b) 
     dx))</code></pre>

      <p>
        Em geral, <code>lambda</code> é usado para criar procedimentos da mesma
        forma que <code>define</code>, exceto que nenhum nome é especificado
        para o procedimento:
      </p>

      <pre><code class="language-scheme">(lambda (⟨formal-parameters⟩) ⟨body⟩)</code></pre>

      <p>
        O procedimento resultante é tão procedimento quanto um que é criado
        usando <code>define</code>. A única diferença é que ele não foi
        associado a nenhum nome no ambiente. Na verdade,
      </p>

      <pre><code class="language-scheme">(define (plus4 x) (+ x 4))</code></pre>

      <p>é equivalente a</p>

      <pre><code class="language-scheme">(define plus4 (lambda (x) (+ x 4)))</code></pre>

      <p>Podemos ler uma expressão <code>lambda</code> da seguinte forma:</p>

      <div class="example">
        <pre class="example">
(lambda                     (x)     (+   x     4))
    |                        |       |   |     |
o procedimento de um argumento x que adiciona x e 4
</pre
        >
      </div>

      <p>
        Como qualquer expressão que tem um procedimento como seu valor, uma
        expressão <code>lambda</code> pode ser usada como o operador em uma
        combinação, como:
      </p>

      <pre><code class="language-scheme">((lambda (x y z) (+ x y (square z))) 1 2 3)
<i>12</i></code></pre>

      <p>
        ou, mais geralmente, em qualquer contexto onde normalmente usaríamos um
        nome de procedimento.<a class="footnote_link" id="DOCF53" href="#FOOT53"
          ><sup>53</sup></a
        >
      </p>

      <a id="Using-let-to-create-local-variables"></a>
      <h5 class="subsubheading">
        Usando <code>let</code> para criar variáveis locais
      </h5>

      <p>
        Outro uso de <code>lambda</code> é na criação de variáveis locais.
        Muitas vezes precisamos de variáveis locais em nossos procedimentos além
        daquelas que foram vinculadas como parâmetros formais. Por exemplo,
        suponha que desejemos calcular a função:
      </p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mrow class="MJX-TeXAtom-ORD">
          <mi>f</mi>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
        </mrow>
        <mspace width="thinmathspace" />
        <mo>=</mo>
        <mspace width="thinmathspace" />
        <mrow class="MJX-TeXAtom-ORD">
          <mi>x</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>+</mo>
          <mi>x</mi>
          <mi>y</mi>
          <msup>
            <mo stretchy="false">)</mo>
            <mn>2</mn>
          </msup>
        </mrow>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mi>y</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>−<!-- − --></mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
        </mrow>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>+</mo>
          <mi>x</mi>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>−<!-- − --></mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
          <mo>,</mo>
        </mrow>
      </math>

      <p>que também poderíamos expressar como:</p>

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mtable
          columnalign="right center left"
          rowspacing="3pt"
          columnspacing="thickmathspace"
        >
          <mtr>
            <mtd>
              <mi>a</mi>
            </mtd>
            <mtd>
              <mo>=</mo>
            </mtd>
            <mtd>
              <mrow class="MJX-TeXAtom-ORD">
                <mn>1</mn>
                <mo>+</mo>
                <mi>x</mi>
                <mi>y</mi>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow class="MJX-TeXAtom-ORD">
                <mpadded height="0" depth="0">
                  <mphantom>
                    <mo stretchy="false">(</mo>
                    <mi>x</mi>
                    <mo>,</mo>
                    <mi>y</mi>
                    <mo stretchy="false">)</mo>
                  </mphantom>
                </mpadded>
              </mrow>
              <mi>b</mi>
            </mtd>
            <mtd>
              <mo>=</mo>
            </mtd>
            <mtd>
              <mrow class="MJX-TeXAtom-ORD">
                <mn>1</mn>
                <mo>−<!-- − --></mo>
                <mi>y</mi>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>f</mi>
                <mo stretchy="false">(</mo>
                <mi>x</mi>
                <mo>,</mo>
                <mi>y</mi>
                <mo stretchy="false">)</mo>
              </mrow>
            </mtd>
            <mtd>
              <mo>=</mo>
            </mtd>
            <mtd>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>x</mi>
                <msup>
                  <mi>a</mi>
                  <mn>2</mn>
                </msup>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>y</mi>
                <mi>b</mi>
              </mrow>
              <mo>+</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>a</mi>
                <mi>b</mi>
                <mo>.</mo>
              </mrow>
            </mtd>
          </mtr>
        </mtable>
      </math>

      <p>
        Ao escrever um procedimento para calcular
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi> </math>,
        gostaríamos de incluir como variáveis locais não apenas
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>y</mi> </math>,
        mas também os nomes de quantidades intermediárias como
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi> </math>.
        Uma maneira de conseguir isso é usar um procedimento auxiliar para
        vincular as variáveis locais:
      </p>

      <pre><code class="language-scheme">(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y)) 
            (- 1 y)))</code></pre>

      <p>
        Claro, poderíamos usar uma expressão <code>lambda</code> para
        especificar um procedimento anônimo para vincular nossas variáveis
        locais. O corpo de <code>f</code> então se torna uma única chamada para
        esse procedimento:
      </p>

      <pre><code class="language-scheme">(define (f x y)
  ((lambda (a b)
     (+ (* x (square a)) 
        (* y b) 
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))</code></pre>

      <p>
        Essa construção é tão útil que há uma forma especial chamada
        <code>let</code> para tornar seu uso mais conveniente. Usando
        <code>let</code>, o procedimento <code>f</code> poderia ser escrito
        como:
      </p>

      <pre><code class="language-scheme">(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))</code></pre>

      <p>A forma geral de uma expressão <code>let</code> é:</p>

      <pre><code class="language-scheme">(let ((⟨var₁⟩ ⟨exp₁⟩)
      (⟨var₂⟩ ⟨exp₂⟩)
      …
      (⟨varₙ⟩ ⟨expₙ⟩))
  ⟨body⟩)</code></pre>

      <p>que pode ser pensada como dizendo:</p>

      <div class="example">
        <pre
          class="example"
        >let ⟨<var>var₁</var>⟩ <span class="roman">tenha o valor</span> ⟨<var>exp₁</var>⟩ <span class="roman">e</span>
    ⟨<var>var₂</var>⟩ <span class="roman">tenha o valor</span> ⟨<var>exp₂</var>⟩ <span class="roman">e</span>
    <span class="roman">…</span>
    ⟨<var>varₙ</var>⟩ <span class="roman">tenha o valor</span> ⟨<var>expₙ</var>⟩
  <span class="roman">em</span> ⟨<var>body</var>⟩
</pre>
      </div>

      <p>
        A primeira parte da expressão <code>let</code> é uma lista de pares
        nome-expressão. Quando o <code>let</code> é avaliado, cada nome é
        associado ao valor da expressão correspondente. O corpo do
        <code>let</code> é avaliado com esses nomes vinculados como variáveis
        locais. A maneira como isso acontece é que a expressão
        <code>let</code> é interpretada como uma sintaxe alternativa para:
      </p>

      <pre><code class="language-scheme">((lambda (⟨var₁⟩ … ⟨varₙ⟩)
   ⟨body⟩)
 ⟨exp₁⟩
 …
 ⟨expₙ⟩)</code></pre>

      <p>
        Nenhum novo mecanismo é necessário no interpretador para fornecer
        variáveis locais. Uma expressão <code>let</code> é simplesmente açúcar
        sintático para a aplicação subjacente de <code>lambda</code>.
      </p>

      <p>
        Podemos ver a partir dessa equivalência que o escopo de uma variável
        especificada por uma expressão <code>let</code> é o corpo do
        <code>let</code>. Isso implica que:
      </p>
      <ul>
        <li>
          <code>Let</code> permite vincular variáveis o mais localmente possível
          ao local onde elas serão usadas. Por exemplo, se o valor de
          <code>x</code> é 5, o valor da expressão:
        </li>
      </ul>

      <pre><code class="language-scheme">(+ (let ((x 3))
     (+ x (* x 10)))
   x)</code></pre>

      <p>
        é 38. Aqui, o <code>x</code> no corpo do <code>let</code> é 3, então o
        valor da expressão <code>let</code> é 33. Por outro lado, o
        <code>x</code> que é o segundo argumento para o <code>+</code> mais
        externo ainda é 5.
      </p>

      <ul>
        <li>
          Os valores das variáveis são computados fora do <code>let</code>. Isso
          importa quando as expressões que fornecem os valores para as variáveis
          locais dependem de variáveis que têm os mesmos nomes que as variáveis
          locais. Por exemplo, se o valor de <code>x</code> é 2, a expressão:
        </li>
      </ul>

      <pre><code class="language-scheme">(let ((x 3)
      (y (+ x 2)))
  (* x y))</code></pre>

      <p>
        terá o valor 12 porque, dentro do corpo do <code>let</code>,
        <code>x</code> será 3 e <code>y</code> será 4 (que é o
        <code>x</code> externo mais 2).
      </p>

      <p>
        Às vezes, podemos usar definições internas para obter o mesmo efeito que
        com <code>let</code>. Por exemplo, poderíamos ter definido o
        procedimento <code>f</code> acima como:
      </p>

      <pre><code class="language-scheme">(define (f x y)
  (define a 
    (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))</code></pre>

      <p>
        No entanto, preferimos usar <code>let</code> em situações como essa e
        usar <code>define</code> interno apenas para procedimentos internos.<a
          class="footnote_link"
          id="DOCF54"
          href="#FOOT54"
          ><sup>54</sup></a
        >
      </p>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e34"></a>Exercício 1.34:</strong> Suponha
          que definamos o procedimento:
        </p>

        <pre><code class="language-scheme">(define (f g) (g 2))</code></pre>

        <p>Então temos:</p>

        <pre><code class="language-scheme">(f square)
<i>4</i>

(f (lambda (z) (* z (+ z 1))))
<i>6</i></code></pre>

        <p>
          O que acontece se (perversamente) pedirmos ao interpretador para
          avaliar a combinação <code>(f f)</code>? Explique.
        </p>
      </blockquote>

      <a id="g_t1_002e3_002e3"></a>
      <a id="Procedures-as-General-Methods"></a>
      <h4 class="subsection">
        <span class="secnum">1.3.3</span
        ><span class="sectitle">Procedimentos como Métodos Gerais</span>
      </h4>

      <p>
        Introduzimos procedimentos compostos em
        <a href="1_002e1.html#g_t1_002e1_002e4">1.1.4</a> como um mecanismo para
        abstrair padrões de operações numéricas, de modo a torná-los
        independentes dos números particulares envolvidos. Com procedimentos de
        ordem superior, como o procedimento <code>integral</code> de
        <a href="#g_t1_002e3_002e1">1.3.1</a>, começamos a ver um tipo mais
        poderoso de abstração: procedimentos usados para expressar métodos
        gerais de computação, independentes das funções particulares envolvidas.
        Nesta seção, discutimos dois exemplos mais elaborados — métodos gerais
        para encontrar zeros e pontos fixos de funções — e mostramos como esses
        métodos podem ser expressos diretamente como procedimentos.
      </p>

      <a id="Finding-roots-of-equations-by-the-half_002dinterval-method"></a>
      <h5 class="subsubheading">
        Encontrando raízes de equações pelo método da bissecção
      </h5>

      <p>
        O <a id="index-half_002dinterval-method"></a>
        <em>método da bissecção</em> é uma técnica simples, mas poderosa, para
        encontrar raízes de uma equação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <mn>0</mn>
          </mrow> </math
        >, onde
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        é uma função contínua. A ideia é que, se nos forem dados pontos
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>b</mi>
        </math>
        tais que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>a</mi>
            <mo stretchy="false">)</mo>
            <mo>&lt;</mo>
            <mn>0</mn>
            <mo>&lt;</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>b</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, então
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        deve ter pelo menos um zero entre
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi></math>
        <!--Aqui-->
      </p>

      <p>
        Para localizar um zero, seja
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        a média de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi> </math>, e
        calcule
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >. Se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>&gt;</mo>
            <mn>0</mn>
          </mrow> </math
        >, então
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        deve ter um zero entre
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>a</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>. Se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>&lt;</mo>
            <mn>0</mn>
          </mrow> </math
        >, então
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        deve ter um zero entre
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>b</mi> </math>.
        Continuando dessa forma, podemos identificar intervalos cada vez menores
        nos quais
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        deve ter um zero. Quando chegamos a um ponto onde o intervalo é pequeno
        o suficiente, o processo para. Como o intervalo de incerteza é reduzido
        pela metade a cada passo do processo, o número de passos necessários
        cresce como
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi mathvariant="normal">Θ<!-- Θ --></mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mo stretchy="false">(</mo>
            <mi>L</mi>
            <mspace width="thinmathspace" />
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mspace width="thinmathspace" />
            <mi>T</mi>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >, onde
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>L</mi>
        </math>
        é o comprimento do intervalo original e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>T</mi>
        </math>
        é a tolerância de erro (ou seja, o tamanho do intervalo que
        consideraremos "pequeno o suficiente"). Aqui está um procedimento que
        implementa essa estratégia:
      </p>
      <pre><code class="language-scheme">(define (search f neg-point pos-point)
  (let ((midpoint 
         (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond 
           ((positive? test-value)
            (search f neg-point midpoint))
           ((negative? test-value)
            (search f midpoint pos-point))
           (else midpoint))))))</code></pre>

      <p>
        Assumimos que inicialmente recebemos a função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        junto com pontos onde seus valores são negativos e positivos. Primeiro
        calculamos o ponto médio dos dois pontos dados. Em seguida, verificamos
        se o intervalo dado é pequeno o suficiente, e se for, simplesmente
        retornamos o ponto médio como nossa resposta. Caso contrário, calculamos
        como valor de teste o valor de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        no ponto médio. Se o valor de teste for positivo, continuamos o processo
        com um novo intervalo que vai do ponto negativo original ao ponto médio.
        Se o valor de teste for negativo, continuamos com o intervalo do ponto
        médio ao ponto positivo. Finalmente, existe a possibilidade de que o
        valor de teste seja 0, caso em que o ponto médio é a própria raiz que
        estamos procurando.
      </p>
      <p>
        Para testar se os pontos finais estão "próximos o suficiente", podemos
        usar um procedimento semelhante ao usado em
        <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a> para calcular raízes
        quadradas:<a class="footnote_link" id="DOCF55" href="#FOOT55"
          ><sup>55</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (close-enough? x y) 
  (&lt; (abs (- x y)) 0.001))</code></pre>

      <p>
        <code>Search</code> é difícil de usar diretamente, porque podemos
        acidentalmente fornecer pontos onde os valores de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        não têm o sinal necessário, caso em que obtemos uma resposta errada. Em
        vez disso, usaremos <code>search</code> através do seguinte
        procedimento, que verifica qual dos pontos finais tem um valor de função
        negativo e qual tem um valor positivo, e chama o procedimento
        <code>search</code> de acordo. Se a função tiver o mesmo sinal nos dois
        pontos dados, o método do intervalo médio não pode ser usado, caso em
        que o procedimento sinaliza um erro.<a
          class="footnote_link"
          id="DOCF56"
          href="#FOOT56"
          ><sup>56</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value) 
                (positive? b-value))
           (search f a b))
          ((and (negative? b-value) 
                (positive? a-value))
           (search f b a))
          (else
           (error "Values are not of 
                   opposite sign" a b)))))</code></pre>

      <p>
        O exemplo a seguir usa o método do intervalo médio para aproximar
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>π<!-- π --></mi>
        </math>
        como a raiz entre 2 e 4 de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>sin</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>x</mi>
            <mo>=</mo>
            <mn>0</mn>
          </mrow> </math
        >:
      </p>
      <pre><code class="language-scheme">(half-interval-method sin 2.0 4.0)
<i>3.14111328125</i></code></pre>

      <p>
        Aqui está outro exemplo, usando o método do intervalo médio para
        procurar uma raiz da equação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msup>
              <mi>x</mi>
              <mn>3</mn>
            </msup>
            <mo>−<!-- − --></mo>
            <mn>2</mn>
            <mi>x</mi>
            <mo>−<!-- − --></mo>
            <mn>3</mn>
            <mo>=</mo>
            <mn>0</mn>
          </mrow>
        </math>
        entre 1 e 2:
      </p>
      <pre><code class="language-scheme">(half-interval-method 
 (lambda (x) (- (* x x x) (* 2 x) 3))
 1.0
 2.0)
<i>1.89306640625</i></code></pre>

      <a id="Finding-fixed-points-of-functions"></a>
      <h5 class="subsubheading">Encontrando pontos fixos de funções</h5>

      <p>
        Um número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        é chamado de <a id="index-fixed-point"></a> <em>ponto fixo</em> de uma
        função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        satisfaz a equação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <mi>x</mi>
          </mrow> </math
        >. Para algumas funções
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        podemos localizar um ponto fixo começando com uma estimativa inicial e
        aplicando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>f</mi>
        </math>
        repetidamente,

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>,</mo>
          </mrow>
          <mspace width="1em" />
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo>,</mo>
          </mrow>
          <mspace width="1em" />
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo stretchy="false">)</mo>
            <mo>,</mo>
          </mrow>
          <mspace width="1em" />
          <mrow class="MJX-TeXAtom-ORD">
            <mo>…<!-- … --></mo>
            <mo>,</mo>
          </mrow>
        </math>

        até que o valor não mude muito. Usando essa ideia, podemos criar um
        procedimento <code>fixed-point</code> que recebe como entradas uma
        função e uma estimativa inicial e produz uma aproximação de um ponto
        fixo da função. Aplicamos a função repetidamente até encontrarmos dois
        valores sucessivos cuja diferença é menor que alguma tolerância
        prescrita:
      </p>
      <pre><code class="language-scheme">(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))</code></pre>

      <p>
        Por exemplo, podemos usar este método para aproximar o ponto fixo da
        função cosseno, começando com 1 como uma aproximação inicial:<a
          class="footnote_link"
          id="DOCF57"
          href="#FOOT57"
          ><sup>57</sup></a
        >
      </p>
      <pre><code class="language-scheme">(fixed-point cos 1.0)
<i>.7390822985224023</i></code></pre>

      <p>
        Da mesma forma, podemos encontrar uma solução para a equação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo>=</mo>
            <mi>sin</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>y</mi>
            <mo>+</mo>
            <mi>cos</mi>
            <mo>⁡<!-- ⁡ --></mo>
            <mi>y</mi>
          </mrow> </math
        >:
      </p>
      <pre><code class="language-scheme">(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
<i>1.2587315962971173</i></code></pre>

      <p>
        O processo de ponto fixo é semelhante ao processo que usamos para
        encontrar raízes quadradas em
        <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a>. Ambos são baseados na
        ideia de repetidamente melhorar uma estimativa até que o resultado
        satisfaça algum critério. Na verdade, podemos facilmente formular o
        cálculo da raiz quadrada como uma busca por ponto fixo. Calcular a raiz
        quadrada de algum número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        requer encontrar um
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        tal que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msup>
              <mi>y</mi>
              <mn>2</mn>
            </msup>
            <mo>=</mo>
            <mi>x</mi>
          </mrow> </math
        >. Colocando essa equação na forma equivalente
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo>=</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >, reconhecemos que estamos procurando um ponto fixo da função<a
          class="footnote_link"
          id="DOCF58"
          href="#FOOT58"
          ><sup>58</sup></a
        >
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >, e podemos, portanto, tentar calcular raízes quadradas como
      </p>
      <pre><code class="language-scheme">(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))</code></pre>

      <p>
        Infelizmente, essa busca por ponto fixo não converge. Considere uma
        estimativa inicial
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>y</mi>
            <mn>1</mn>
          </msub> </math
        >. A próxima estimativa é
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <msub>
              <mi>y</mi>
              <mn>2</mn>
            </msub>
            <mo>=</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <msub>
              <mi>y</mi>
              <mn>1</mn>
            </msub>
          </mrow>
        </math>
        e a próxima estimativa é
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>y</mi>
            <mn>3</mn>
          </msub>
          <mo>=</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <msub>
              <mi>y</mi>
              <mn>2</mn>
            </msub>
          </mrow>
          <mo>=</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <msub>
              <mi>y</mi>
              <mn>1</mn>
            </msub>
            <mo stretchy="false">)</mo>
          </mrow>
          <mo>=</mo>
          <msub>
            <mi>y</mi>
            <mn>1</mn>
          </msub> </math
        >. Isso resulta em um loop infinito em que as duas estimativas
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>y</mi>
            <mn>1</mn>
          </msub>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mi>y</mi>
            <mn>2</mn>
          </msub>
        </math>
        se repetem continuamente, oscilando em torno da resposta.
      </p>
      <p>
        Uma maneira de controlar essas oscilações é evitar que as estimativas
        mudem tanto. Como a resposta está sempre entre nossa estimativa
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >, podemos fazer uma nova estimativa que não esteja tão longe de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        quanto
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow>
        </math>
        calculando a média de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        com
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >, de modo que a próxima estimativa após
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        seja
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mn>2</mn>
              </mfrac>
            </mrow>
            <mo stretchy="false">(</mo>
            <mi>y</mi>
            <mo>+</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        em vez de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >. O processo de fazer tal sequência de estimativas é simplesmente o
        processo de procurar um ponto fixo de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
          <mo stretchy="false">↦<!-- ↦ --></mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mn>2</mn>
              </mfrac>
            </mrow>
            <mo stretchy="false">(</mo>
            <mi>y</mi>
            <mo>+</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >:
      </p>
      <pre><code class="language-scheme">(define (sqrt x)
  (fixed-point 
   (lambda (y) (average y (/ x y)))
   1.0))</code></pre>

      <p>
        (Note que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
          <mo>=</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mn>1</mn>
                <mn>2</mn>
              </mfrac>
            </mrow>
            <mo stretchy="false">(</mo>
            <mi>y</mi>
            <mo>+</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        é uma transformação simples da equação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo>=</mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
            <mo>;</mo>
          </mrow>
        </math>
        para derivá-la, adicione
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>y</mi>
        </math>
        a ambos os lados da equação e divida por 2.)
      </p>
      <p>
        Com essa modificação, o procedimento de raiz quadrada funciona. Na
        verdade, se desvendarmos as definições, podemos ver que a sequência de
        aproximações para a raiz quadrada gerada aqui é precisamente a mesma que
        a gerada por nosso procedimento original de raiz quadrada de
        <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a>. Essa abordagem de
        média de aproximações sucessivas para uma solução, uma técnica que
        chamamos de
        <a id="index-average-damping"></a>
        <em>amortecimento médio</em>, frequentemente ajuda a convergência de
        buscas por ponto fixo.
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e35"></a>Exercício 1.35:</strong> Mostre
          que a proporção áurea
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>φ<!-- φ --></mi>
          </math>
          (<a href="1_002e2.html#g_t1_002e2_002e2">1.2.2</a>) é um ponto fixo da
          transformação
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>x</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mn>1</mn>
              <mo>+</mo>
              <mn>1</mn>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>x</mi>
            </mrow> </math
          >, e use esse fato para calcular
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>φ<!-- φ --></mi>
          </math>
          por meio do procedimento <code>fixed-point</code>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e36"></a>Exercício 1.36:</strong>
          Modifique <code>fixed-point</code> para que ele imprima a sequência de
          aproximações que gera, usando as primitivas <code>newline</code> e
          <code>display</code> mostradas em
          <a href="1_002e2.html#Exercise-1_002e22">Exercício 1.22</a>. Em
          seguida, encontre uma solução para
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>x</mi>
                <mi>x</mi>
              </msup>
              <mo>=</mo>
              <mn>1000</mn>
            </mrow>
          </math>
          encontrando um ponto fixo de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>x</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>log</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mo stretchy="false">(</mo>
              <mn>1000</mn>
              <mo stretchy="false">)</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>log</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. (Use a primitiva <code>log</code> do Scheme, que calcula logaritmos
          naturais.) Compare o número de passos que isso leva com e sem
          amortecimento médio. (Observe que você não pode começar
          <code>fixed-point</code> com uma estimativa de 1, pois isso causaria
          divisão por
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>log</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mo stretchy="false">(</mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
              <mo>=</mo>
              <mn>0</mn>
            </mrow> </math
          >.)
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e37"></a>Exercício 1.37:</strong>
        </p>
        <ol>
          <li>
            Uma <a id="index-continued-fraction"></a>
            <em>fração contínua</em> infinita é uma expressão da forma

            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
              <mi>f</mi>
              <mspace width="thinmathspace" />
              <mo>=</mo>
              <mspace width="thinmathspace" />
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <msub>
                    <mi>N</mi>
                    <mn>1</mn>
                  </msub>
                  <mrow>
                    <msub>
                      <mi>D</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>+</mo>
                    <mfrac>
                      <msub>
                        <mi>N</mi>
                        <mn>2</mn>
                      </msub>
                      <mrow>
                        <msub>
                          <mi>D</mi>
                          <mn>2</mn>
                        </msub>
                        <mo>+</mo>
                        <mfrac>
                          <msub>
                            <mi>N</mi>
                            <mn>3</mn>
                          </msub>
                          <mrow>
                            <msub>
                              <mi>D</mi>
                              <mn>3</mn>
                            </msub>
                            <mo>+</mo>
                            <mo>…<!-- … --></mo>
                          </mrow>
                        </mfrac>
                      </mrow>
                    </mfrac>
                  </mrow>
                </mfrac>
                <mo>.</mo>
              </mrow>
            </math>

            Como exemplo, pode-se mostrar que a expansão de fração contínua
            infinita com os
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>N</mi>
                <mi>i</mi>
              </msub>
            </math>
            e os
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>D</mi>
                <mi>i</mi>
              </msub>
            </math>
            todos iguais a 1 produz
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mn>1</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mi>φ<!-- φ --></mi>
              </mrow> </math
            >, onde
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>φ<!-- φ --></mi>
            </math>
            é a proporção áurea (descrita em
            <a href="1_002e2.html#g_t1_002e2_002e2">1.2.2</a>). Uma maneira de
            aproximar uma fração contínua infinita é truncar a expansão após um
            dado número de termos. Tal truncamento—uma chamada
            <a id="index-k_002dterm"></a>
            fração contínua finita
            <em><i>k</i>-term finite continued fraction</em>—tem a forma

            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <msub>
                    <mi>N</mi>
                    <mn>1</mn>
                  </msub>
                  <mrow>
                    <msub>
                      <mi>D</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>+</mo>
                    <mfrac>
                      <msub>
                        <mi>N</mi>
                        <mn>2</mn>
                      </msub>
                      <mrow>
                        <mo>⋱<!-- ⋱ --></mo>
                        <mo>+</mo>
                        <mfrac>
                          <msub>
                            <mi>N</mi>
                            <mi>k</mi>
                          </msub>
                          <msub>
                            <mi>D</mi>
                            <mi>k</mi>
                          </msub>
                        </mfrac>
                      </mrow>
                    </mfrac>
                  </mrow>
                </mfrac>
                <mo>.</mo>
              </mrow>
            </math>

            Suponha que <code>n</code> e <code>d</code> sejam procedimentos de
            um argumento (o índice do termo
            <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>i</mi> </math
            >) que retornam o
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>N</mi>
                <mi>i</mi>
              </msub>
            </math>
            e o
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>D</mi>
                <mi>i</mi>
              </msub>
            </math>
            dos termos da fração contínua. Defina um procedimento
            <code>cont-frac</code> tal que avaliar
            <code>(cont-frac n d k)</code> calcule o valor da fração contínua
            finita de
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>k</mi>
            </math>
            termos. Verifique seu procedimento aproximando
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mn>1</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mi>φ<!-- φ --></mi>
              </mrow>
            </math>
            usando

            <pre><code class="language-scheme">(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)</code></pre>

            <p>
              para valores sucessivos de <code>k</code>. Quão grande você deve
              fazer <code>k</code> para obter uma aproximação que seja precisa
              até 4 casas decimais?
            </p>
          </li>
          <li>
            Se o seu procedimento <code>cont-frac</code> gerar um processo
            recursivo, escreva um que gere um processo iterativo. Se ele gerar
            um processo iterativo, escreva um que gere um processo recursivo.
          </li>
        </ol>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e38"></a>Exercício 1.38:</strong> Em
          1737, o matemático suíço Leonhard Euler publicou um artigo
          <cite>De Fractionibus Continuis</cite>, que incluía uma expansão de
          fração contínua para
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>e</mi>
              <mo>−<!-- − --></mo>
              <mn>2</mn>
            </mrow> </math
          >, onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>e</mi>
          </math>
          é a base dos logaritmos naturais. Nessa fração, os
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>N</mi>
              <mi>i</mi>
            </msub>
          </math>
          são todos 1, e os
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msub>
              <mi>D</mi>
              <mi>i</mi>
            </msub>
          </math>
          são sucessivamente 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, …. Escreva um
          programa que use o seu procedimento <code>cont-frac</code> do
          <a href="#Exercise-1_002e37">Exercício 1.37</a> para aproximar
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>e</mi> </math>,
          com base na expansão de Euler.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e39"></a>Exercício 1.39:</strong> Uma
          representação de fração contínua da função tangente foi publicada em
          1770 pelo matemático alemão J.H. Lambert:

          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>tan</mi>
              <mo>⁡<!-- ⁡ --></mo>
              <mi>x</mi>
            </mrow>
            <mspace width="thinmathspace" />
            <mo>=</mo>
            <mspace width="thinmathspace" />
            <mrow class="MJX-TeXAtom-ORD">
              <mfrac>
                <mi>x</mi>
                <mrow>
                  <mn>1</mn>
                  <mo>−<!-- − --></mo>
                  <mfrac>
                    <msup>
                      <mi>x</mi>
                      <mn>2</mn>
                    </msup>
                    <mrow>
                      <mn>3</mn>
                      <mo>−<!-- − --></mo>
                      <mfrac>
                        <msup>
                          <mi>x</mi>
                          <mn>2</mn>
                        </msup>
                        <mrow>
                          <mn>5</mn>
                          <mo>−<!-- − --></mo>
                          <mo>…<!-- … --></mo>
                        </mrow>
                      </mfrac>
                    </mrow>
                  </mfrac>
                </mrow>
              </mfrac>
              <mspace width="thinmathspace" />
              <mo>,</mo>
            </mrow>
          </math>

          onde
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>x</mi>
          </math>
          está em radianos. Defina um procedimento <code>(tan-cf x k)</code> que
          calcula uma aproximação da função tangente com base na fórmula de
          Lambert. <code>k</code> especifica o número de termos a serem
          calculados, como no <a href="#Exercise-1_002e37">Exercício 1.37</a>.
        </p>
      </blockquote>

      <a id="g_t1_002e3_002e4"></a>
      <a id="Procedures-as-Returned-Values"></a>
      <h4 class="subsection">
        <span class="secnum">1.3.4</span
        ><span class="sectitle">Procedimentos como Valores Retornados</span>
      </h4>

      <p>
        Os exemplos acima demonstram como a capacidade de passar procedimentos
        como argumentos aumenta significativamente o poder expressivo de nossa
        linguagem de programação. Podemos alcançar ainda mais poder expressivo
        criando procedimentos cujos valores retornados são eles mesmos
        procedimentos.
      </p>
      <p>
        Podemos ilustrar essa ideia olhando novamente para o exemplo de ponto
        fixo descrito no final de <a href="#g_t1_002e3_002e3">1.3.3</a>.
        Formulamos uma nova versão do procedimento de raiz quadrada como uma
        busca por ponto fixo, começando com a observação de que
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msqrt>
            <mi>x</mi>
          </msqrt>
        </math>
        é um ponto fixo da função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >. Então usamos o amortecimento médio para fazer as aproximações
        convergirem. O amortecimento médio é uma técnica geral útil por si só.
        Ou seja, dada uma função
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi> </math>,
        consideramos a função cujo valor em
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        é igual à média de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
          </mrow> </math
        >.
      </p>
      <p>
        Podemos expressar a ideia de amortecimento médio por meio do seguinte
        procedimento:
      </p>
      <pre><code class="language-scheme">(define (average-damp f)
  (lambda (x) 
    (average x (f x))))</code></pre>

      <p>
        <code>Average-damp</code> é um procedimento que recebe como argumento um
        procedimento <code>f</code> e retorna como valor um procedimento
        (produzido pelo <code>lambda</code>) que, quando aplicado a um número
        <code>x</code>, produz a média de <code>x</code> e <code>(f x)</code>.
        Por exemplo, aplicando <code>average-damp</code> ao procedimento
        <code>square</code> produz um procedimento cujo valor em algum número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        é a média de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msup>
            <mi>x</mi>
            <mn>2</mn>
          </msup> </math
        >. Aplicando esse procedimento resultante a 10 retorna a média de 10 e
        100, ou 55:<a class="footnote_link" id="DOCF59" href="#FOOT59"
          ><sup>59</sup></a
        >
      </p>
      <pre><code class="language-scheme">((average-damp square) 10)
<i>55</i></code></pre>

      <p>
        Usando <code>average-damp</code>, podemos reformular o procedimento de
        raiz quadrada da seguinte forma:
      </p>
      <pre><code class="language-scheme">(define (sqrt x)
  (fixed-point 
   (average-damp 
    (lambda (y) (/ x y)))
   1.0))</code></pre>

      <p>
        Observe como essa formulação torna explícitas as três ideias do método:
        busca por ponto fixo, amortecimento médio e a função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >. É instrutivo comparar essa formulação do método de raiz quadrada com
        a versão original dada em
        <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a>. Lembre-se de que
        esses procedimentos expressam o mesmo processo e observe como a ideia
        fica mais clara quando expressamos o processo em termos dessas
        abstrações. Em geral, existem muitas maneiras de formular um processo
        como um procedimento. Programadores experientes sabem como escolher
        formulações procedurais que são particularmente perspicazes e onde
        elementos úteis do processo são expostos como entidades separadas que
        podem ser reutilizadas em outras aplicações. Como um exemplo simples de
        reutilização, observe que a raiz cúbica de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        é um ponto fixo da função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <msup>
              <mi>y</mi>
              <mn>2</mn>
            </msup>
          </mrow> </math
        >, então podemos imediatamente generalizar nosso procedimento de raiz
        quadrada para um que extrai raízes cúbicas:<a
          class="footnote_link"
          id="DOCF60"
          href="#FOOT60"
          ><sup>60</sup></a
        >
      </p>
      <pre><code class="language-scheme">(define (cube-root x)
  (fixed-point 
   (average-damp 
    (lambda (y) 
      (/ x (square y))))
   1.0))</code></pre>

      <a id="Newton_0027s-method"></a>
      <h5 class="subsubheading">Método de Newton</h5>

      <p>
        Quando introduzimos o procedimento de raiz quadrada, em
        <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a>, nós mencionamos que
        este era um caso especial do <a id="index-Newton_0027s-method"></a>
        <em>método de Newton</em>. Se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>g</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        é uma função diferenciável, então uma solução da equação
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>g</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <mn>0</mn>
          </mrow>
        </math>
        é um ponto fixo da função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        onde

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
          </mrow>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mi>x</mi>
          <mo>−<!-- − --></mo>
          <mfrac>
            <mrow>
              <mi>g</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
            </mrow>
            <mrow>
              <mi>D</mi>
              <mi>g</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
            </mrow>
          </mfrac>
        </math>

        e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>D</mi>
            <mi>g</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </math>
        é a derivada de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>g</mi>
        </math>
        avaliada em
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>. O
        método de Newton é o uso do método de ponto fixo que vimos acima para
        aproximar uma solução da equação encontrando um ponto fixo da função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>f</mi>
          </mrow> </math
        >.<a class="footnote_link" id="DOCF61" href="#FOOT61"><sup>61</sup></a>
      </p>
      <p>
        Para muitas funções
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>g</mi>
        </math>
        e para estimativas iniciais suficientemente boas para
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>, o
        método de Newton converge muito rapidamente para uma solução de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>g</mi>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <mn>0</mn>
          </mrow> </math
        >.<a class="footnote_link" id="DOCF62" href="#FOOT62"><sup>62</sup></a>
      </p>
      <p>
        Para implementar o método de Newton como um procedimento, devemos
        primeiro expressar a ideia de derivada. Observe que "derivada", como o
        amortecimento médio, é algo que transforma uma função em outra função.
        Por exemplo, a derivada da função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <msup>
              <mi>x</mi>
              <mn>3</mn>
            </msup>
          </mrow>
        </math>
        é a função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mn>3</mn>
            <msup>
              <mi>x</mi>
              <mn>2</mn>
            </msup>
          </mrow> </math
        >. Em geral, se
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>g</mi>
        </math>
        é uma função e
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>x</mi>
          </mrow>
        </math>
        é um número pequeno, então a derivada
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>D</mi>
            <mi>g</mi>
          </mrow>
        </math>
        de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>g</mi>
        </math>
        é a função cujo valor em qualquer número
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>x</mi>
        </math>
        é dado (no limite de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>x</mi>
          </mrow>
        </math>
        pequeno) por

        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mi>D</mi>
          <mi>g</mi>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
          <mspace width="thinmathspace" />
          <mo>=</mo>
          <mspace width="thinmathspace" />
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mrow>
                <mi>g</mi>
                <mo stretchy="false">(</mo>
                <mi>x</mi>
                <mo>+</mo>
                <mi>d</mi>
                <mi>x</mi>
                <mo stretchy="false">)</mo>
                <mo>−<!-- − --></mo>
                <mi>g</mi>
                <mo stretchy="false">(</mo>
                <mi>x</mi>
                <mo stretchy="false">)</mo>
              </mrow>
              <mrow>
                <mi>d</mi>
                <mi>x</mi>
              </mrow>
            </mfrac>
            <mo>.</mo>
          </mrow>
        </math>

        Assim, podemos expressar a ideia de derivada (tomando
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>d</mi>
            <mi>x</mi>
          </mrow>
        </math>
        como, por exemplo, 0.00001) como o procedimento
      </p>
      <pre><code class="language-scheme">(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))</code></pre>

      <p>junto com a definição</p>
      <pre><code class="language-scheme">(define dx 0.00001)</code></pre>

      <p>
        Como <code>average-damp</code>, <code>deriv</code> é um procedimento que
        recebe um procedimento como argumento e retorna um procedimento como
        valor. Por exemplo, para aproximar a derivada de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>x</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <msup>
              <mi>x</mi>
              <mn>3</mn>
            </msup>
          </mrow>
        </math>
        em 5 (cujo valor exato é 75) podemos avaliar
      </p>
      <pre><code class="language-scheme">(define (cube x) (* x x x))

((deriv cube) 5)
<i>75.00014999664018</i></code></pre>

      <p>
        Com a ajuda de <code>deriv</code>, podemos expressar o método de Newton
        como um processo de ponto fixo:
      </p>
      <pre><code class="language-scheme">(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) 
            ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) 
               guess))</code></pre>

      <p>
        O procedimento <code>newton-transform</code> expressa a fórmula no
        início desta seção, e <code>newtons-method</code> é facilmente definido
        em termos disso. Ele recebe como argumentos um procedimento que calcula
        a função para a qual queremos encontrar um zero, junto com uma
        estimativa inicial. Por exemplo, para encontrar a raiz quadrada de
        <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>x</mi> </math>,
        podemos usar o método de Newton para encontrar um zero da função
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <msup>
              <mi>y</mi>
              <mn>2</mn>
            </msup>
            <mo>−<!-- − --></mo>
            <mi>x</mi>
          </mrow>
        </math>
        começando com uma estimativa inicial de 1.<a
          class="footnote_link"
          id="DOCF63"
          href="#FOOT63"
          ><sup>63</sup></a
        >
      </p>
      <p>Isso fornece mais uma forma do procedimento de raiz quadrada:</p>
      <pre><code class="language-scheme">(define (sqrt x)
  (newtons-method 
   (lambda (y) 
     (- (square y) x)) 
   1.0))</code></pre>

      <a id="Abstractions-and-first_002dclass-procedures"></a>
      <h5 class="subsubheading">
        Abstrações e procedimentos de primeira classe
      </h5>

      <p>
        Vimos duas maneiras de expressar o cálculo da raiz quadrada como uma
        instância de um método mais geral, uma como uma busca por ponto fixo e
        outra usando o método de Newton. Como o método de Newton foi ele mesmo
        expresso como um processo de ponto fixo, na verdade vimos duas maneiras
        de calcular raízes quadradas como pontos fixos. Cada método começa com
        uma função e encontra um ponto fixo de alguma transformação da função.
        Podemos expressar essa ideia geral como um procedimento:
      </p>
      <pre><code class="language-scheme">(define (fixed-point-of-transform 
         g transform guess)
  (fixed-point (transform g) guess))</code></pre>

      <p>
        Este procedimento muito geral recebe como argumentos um procedimento
        <code>g</code> que calcula alguma função, um procedimento que transforma
        <code>g</code> e uma estimativa inicial. O resultado retornado é um
        ponto fixo da função transformada.
      </p>
      <p>
        Usando essa abstração, podemos reformular o primeiro cálculo de raiz
        quadrada desta seção (onde procuramos um ponto fixo da versão amortecida
        de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <mi>x</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>y</mi>
          </mrow> </math
        >) como uma instância desse método geral:
      </p>
      <pre><code class="language-scheme">(define (sqrt x)
  (fixed-point-of-transform 
   (lambda (y) (/ x y))
   average-damp
   1.0))</code></pre>

      <p>
        Da mesma forma, podemos expressar o segundo cálculo de raiz quadrada
        desta seção (uma instância do método de Newton que encontra um ponto
        fixo da transformação de Newton de
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow class="MJX-TeXAtom-ORD">
            <mi>y</mi>
            <mo stretchy="false">↦<!-- ↦ --></mo>
            <msup>
              <mi>y</mi>
              <mn>2</mn>
            </msup>
            <mo>−<!-- − --></mo>
            <mi>x</mi>
          </mrow> </math
        >) como
      </p>
      <pre><code class="language-scheme">(define (sqrt x)
  (fixed-point-of-transform 
   (lambda (y) (- (square y) x))
   newton-transform
   1.0))</code></pre>

      <p>
        Começamos a seção <a href="#g_t1_002e3">1.3</a> com a observação de que
        procedimentos compostos são um mecanismo crucial de abstração, porque
        nos permitem expressar métodos gerais de computação como elementos
        explícitos em nossa linguagem de programação. Agora vimos como
        procedimentos de ordem superior nos permitem manipular esses métodos
        gerais para criar mais abstrações.
      </p>
      <p>
        Como programadores, devemos estar atentos a oportunidades para
        identificar as abstrações subjacentes em nossos programas e construir
        sobre elas e generalizá-las para criar abstrações mais poderosas. Isso
        não significa que devemos sempre escrever programas da maneira mais
        abstrata possível; programadores experientes sabem como escolher o nível
        de abstração apropriado para sua tarefa. Mas é importante ser capaz de
        pensar em termos dessas abstrações, para que possamos estar prontos para
        aplicá-las em novos contextos. A importância dos procedimentos de ordem
        superior é que eles nos permitem representar essas abstrações
        explicitamente como elementos em nossa linguagem de programação, para
        que possam ser manipulados como outros elementos computacionais.
      </p>
      <p>
        Em geral, as linguagens de programação impõem restrições sobre as
        maneiras pelas quais elementos computacionais podem ser manipulados.
        Elementos com as menores restrições são ditos ter
        <a id="index-first_002dclass"></a> <em>status de primeira classe</em>.
        Alguns dos "direitos e privilégios" dos elementos de primeira classe
        são:<a class="footnote_link" id="DOCF64" href="#FOOT64"
          ><sup>64</sup></a
        >
      </p>
      <ul>
        <li>Eles podem ser nomeados por variáveis.</li>
        <li>Eles podem ser passados como argumentos para procedimentos.</li>
        <li>Eles podem ser retornados como resultados de procedimentos.</li>
        <li>
          Eles podem ser incluídos em estruturas de dados.<a
            class="footnote_link"
            id="DOCF65"
            href="#FOOT65"
            ><sup>65</sup></a
          >
        </li>
      </ul>

      <p>
        Lisp, ao contrário de outras linguagens de programação comuns, concede
        aos procedimentos status completo de primeira classe. Isso impõe
        desafios para uma implementação eficiente, mas o ganho resultante em
        poder expressivo é enorme.<a
          class="footnote_link"
          id="DOCF66"
          href="#FOOT66"
          ><sup>66</sup></a
        >
      </p>
      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e40"></a>Exercício 1.40:</strong> Defina
          um procedimento <code>cubic</code> que pode ser usado junto com o
          procedimento <code>newtons-method</code> em expressões da forma
        </p>
        <pre><code class="language-scheme">(newtons-method (cubic a b c) 1)</code></pre>

        <p>
          para aproximar zeros do cúbico
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mi>x</mi>
                <mn>3</mn>
              </msup>
              <mo>+</mo>
              <mi>a</mi>
              <msup>
                <mi>x</mi>
                <mn>2</mn>
              </msup>
              <mo>+</mo>
              <mi>b</mi>
              <mi>x</mi>
              <mo>+</mo>
              <mi>c</mi>
            </mrow> </math
          >.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e41"></a>Exercício 1.41:</strong> Defina
          um procedimento <code>double</code> que recebe um procedimento de um
          argumento como argumento e retorna um procedimento que aplica o
          procedimento original duas vezes. Por exemplo, se <code>inc</code> é
          um procedimento que adiciona 1 ao seu argumento, então
          <code>(double inc)</code> deve ser um procedimento que adiciona 2.
          Qual valor é retornado por
        </p>
        <pre><code class="language-scheme">(((double (double double)) inc) 5)</code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e42"></a>Exercício 1.42:</strong> Sejam
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>g</mi>
          </math>
          duas funções de um argumento. A <a id="index-composition"></a>
          <em>composição</em>
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          após
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>g</mi>
          </math>
          é definida como a função
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>x</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>g</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. Defina um procedimento <code>compose</code> que implementa a
          composição. Por exemplo, se <code>inc</code> é um procedimento que
          adiciona 1 ao seu argumento,
        </p>
        <pre><code class="language-scheme">((compose square inc) 6)
<i>49</i></code></pre>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e43"></a>Exercício 1.43:</strong> Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é uma função numérica e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          é um inteiro positivo, então podemos formar a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>th</mtext>
              </mrow>
            </msup>
          </math>
          aplicação repetida de
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi> </math>,
          que é definida como a função cujo valor em
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>x</mi>
          </math>
          é
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mo>…<!-- … --></mo>
              <mo stretchy="false">(</mo>
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
              <mo stretchy="false">)</mo>
              <mo>…<!-- … --></mo>
              <mo stretchy="false">)</mo>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. Por exemplo, se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é a função
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>x</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow> </math
          >, então a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>th</mtext>
              </mrow>
            </msup>
          </math>
          aplicação repetida de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é a função
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>x</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mo>+</mo>
              <mi>n</mi>
            </mrow> </math
          >. Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é a operação de elevar um número ao quadrado, então a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>th</mtext>
              </mrow>
            </msup>
          </math>
          aplicação repetida de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é a função que eleva seu argumento à
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <msup>
                <mn>2</mn>
                <mi>n</mi>
              </msup>
              <mtext>-th</mtext>
            </mrow>
          </math>
          potência. Escreva um procedimento que recebe como entradas um
          procedimento que calcula
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          e um inteiro positivo
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>n</mi>
          </math>
          e retorna o procedimento que calcula a
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>th</mtext>
              </mrow>
            </msup>
          </math>
          aplicação repetida de
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi> </math>.
          Seu procedimento deve ser capaz de ser usado da seguinte forma:
        </p>
        <pre><code class="language-scheme">((repeated square 2) 5)
<i>625</i></code></pre>

        <p>
          Dica: Você pode achar conveniente usar <code>compose</code> do
          <a href="#Exercise-1_002e42">Exercício 1.42</a>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e44"></a>Exercício 1.44:</strong> A ideia
          de <a id="index-smoothing"></a> <em>suavização</em> de uma função é um
          conceito importante no processamento de sinais. Se
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é uma função e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </math>
          é algum número pequeno, então a versão suavizada de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          é a função cujo valor em um ponto
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>x</mi>
          </math>
          é a média de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo>−<!-- − --></mo>
              <mi>d</mi>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >,
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >, e
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>f</mi>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo>+</mo>
              <mi>d</mi>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
            </mrow> </math
          >. Escreva um procedimento <code>smooth</code> que recebe como entrada
          um procedimento que calcula
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>f</mi>
          </math>
          e retorna um procedimento que calcula a versão suavizada de
          <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi> </math>.
          Às vezes é valioso suavizar repetidamente uma função (ou seja,
          suavizar a função suavizada, e assim por diante) para obter a
          <a id="index-n_002dfold-smoothed-function"></a>
          <em>função suavizada <i>n</i>-vezes</em>. Mostre como gerar a função
          suavizada <i>n</i>-vezes de qualquer função dada usando
          <code>smooth</code> e <code>repeated</code> do
          <a href="#Exercise-1_002e43">Exercício 1.43</a>.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e45"></a>Exercício 1.45:</strong> Vimos
          em <a href="#g_t1_002e3_002e3">1.3.3</a>
          que tentar calcular raízes quadradas encontrando ingenuamente um ponto
          fixo de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>y</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <mi>y</mi>
            </mrow>
          </math>
          não converge, e que isso pode ser corrigido pelo amortecimento médio.
          O mesmo método funciona para encontrar raízes cúbicas como pontos
          fixos da função amortecida
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>y</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <msup>
                <mi>y</mi>
                <mn>2</mn>
              </msup>
            </mrow> </math
          >. Infelizmente, o processo não funciona para raízes quartas—um único
          amortecimento médio não é suficiente para fazer uma busca por ponto
          fixo para
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>y</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <msup>
                <mi>y</mi>
                <mn>3</mn>
              </msup>
            </mrow>
          </math>
          convergir. Por outro lado, se amortecermos a média duas vezes (ou
          seja, usarmos o amortecimento médio do amortecimento médio de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>y</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <msup>
                <mi>y</mi>
                <mn>3</mn>
              </msup>
            </mrow> </math
          >) a busca por ponto fixo converge. Faça alguns experimentos para
          determinar quantos amortecimentos médios são necessários para calcular
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>th</mtext>
              </mrow>
            </msup>
          </math>
          raízes como uma busca por ponto fixo baseada em amortecimento médio
          repetido de
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow class="MJX-TeXAtom-ORD">
              <mi>y</mi>
              <mo stretchy="false">↦<!-- ↦ --></mo>
              <mi>x</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mo>/</mo>
              </mrow>
              <msup>
                <mi>y</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mspace width="0.1em" />
                  <mi>n</mi>
                  <mo>−<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
            </mrow> </math
          >. Use isso para implementar um procedimento simples para calcular
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
              <mi>n</mi>
              <mrow class="MJX-TeXAtom-ORD">
                <mtext>th</mtext>
              </mrow>
            </msup>
          </math>
          raízes usando <code>fixed-point</code>, <code>average-damp</code>, e o
          procedimento <code>repeated</code> do
          <a href="#Exercise-1_002e43">Exercício 1.43</a>. Assuma que quaisquer
          operações aritméticas necessárias estão disponíveis como primitivas.
        </p>
      </blockquote>

      <blockquote>
        <p>
          <strong><a id="Exercise-1_002e46"></a>Exercício 1.46:</strong> Vários
          dos métodos numéricos descritos neste capítulo são instâncias de uma
          estratégia computacional extremamente geral conhecida como
          <a id="index-iterative-improvement"></a> <em>melhoria iterativa</em>.
          A melhoria iterativa diz que, para calcular algo, começamos com uma
          estimativa inicial para a resposta, testamos se a estimativa é boa o
          suficiente, e caso contrário, melhoramos a estimativa e continuamos o
          processo usando a estimativa melhorada como a nova estimativa. Escreva
          um procedimento <code>iterative-improve</code> que recebe dois
          procedimentos como argumentos: um método para dizer se uma estimativa
          é boa o suficiente e um método para melhorar uma estimativa.
          <code>Iterative-improve</code> deve retornar como seu valor um
          procedimento que recebe uma estimativa como argumento e continua
          melhorando a estimativa até que ela seja boa o suficiente. Reescreva o
          procedimento <code>sqrt</code> de
          <a href="1_002e1.html#g_t1_002e1_002e7">1.1.7</a> e o procedimento
          <code>fixed-point</code> de <a href="#g_t1_002e3_002e3">1.3.3</a> em
          termos de <code>iterative-improve</code>.
        </p>
      </blockquote>

      <div class="footnote">
        <h4 class="footnotes-heading">Notas de rodapé</h4>

        <div id="FOOT49">
          <p>
            <a class="footnote_backlink" href="#DOCF49"><sup>49</sup></a>
            Esta série, geralmente escrita na forma equivalente
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mfrac>
                  <mi>π<!-- π --></mi>
                  <mn>4</mn>
                </mfrac>
              </mrow>
              <mo>=</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mn>1</mn>
                <mo>−<!-- − --></mo>
                <mrow class="MJX-TeXAtom-ORD">
                  <mfrac>
                    <mn>1</mn>
                    <mn>3</mn>
                  </mfrac>
                </mrow>
                <mo>+</mo>
                <mrow class="MJX-TeXAtom-ORD">
                  <mfrac>
                    <mn>1</mn>
                    <mn>5</mn>
                  </mfrac>
                </mrow>
              </mrow>
              <mo>−<!-- − --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mrow class="MJX-TeXAtom-ORD">
                  <mfrac>
                    <mn>1</mn>
                    <mn>7</mn>
                  </mfrac>
                </mrow>
                <mo>+</mo>
                <mo>…<!-- … --></mo>
              </mrow> </math
            >, é devida a Leibniz. Veremos como usar isso como base para alguns
            truques numéricos sofisticados em
            <a href="3_002e5.html#g_t3_002e5_002e3">3.5.3</a>.
          </p>
        </div>
        <div id="FOOT50">
          <p>
            <a class="footnote_backlink" href="#DOCF50"><sup>50</sup></a>
            Observe que usamos estrutura de bloco (<a
              href="1_002e1.html#g_t1_002e1_002e8"
              >1.1.8</a
            >) para incorporar as definições de <code>pi-next</code> e
            <code>pi-term</code> dentro de <code>pi-sum</code>, já que esses
            procedimentos são improváveis de serem úteis para qualquer outro
            propósito. Veremos como nos livrar deles completamente em
            <a href="#g_t1_002e3_002e2">1.3.2</a>.
          </p>
        </div>
        <div id="FOOT51">
          <p>
            <a class="footnote_backlink" href="#DOCF51"><sup>51</sup></a>
            A intenção dos
            <a href="#Exercise-1_002e31">Exercício 1.31</a> a
            <a href="#Exercise-1_002e33">Exercício 1.33</a> é demonstrar o poder
            expressivo que é alcançado ao usar uma abstração apropriada para
            consolidar muitas operações aparentemente díspares. No entanto,
            embora acumulação e filtragem sejam ideias elegantes, nossas mãos
            estão um pouco atadas ao usá-las neste ponto, já que ainda não temos
            estruturas de dados para fornecer meios adequados de combinação para
            essas abstrações. Voltaremos a essas ideias em
            <a href="2_002e2.html#g_t2_002e2_002e3">2.2.3</a> quando mostrarmos
            como usar <a id="index-sequences"></a> <em>sequências</em> como
            interfaces para combinar filtros e acumuladores para construir
            abstrações ainda mais poderosas. Veremos lá como esses métodos
            realmente se destacam como uma abordagem poderosa e elegante para
            projetar programas.
          </p>
        </div>
        <div id="FOOT52">
          <p>
            <a class="footnote_backlink" href="#DOCF52"><sup>52</sup></a> Esta
            fórmula foi descoberta pelo matemático inglês do século XVII John
            Wallis.
          </p>
        </div>
        <div id="FOOT53">
          <p>
            <a class="footnote_backlink" href="#DOCF53"><sup>53</sup></a> Seria
            mais claro e menos intimidante para as pessoas aprendendo Lisp se um
            nome mais óbvio que <code>lambda</code>, como
            <code>make-procedure</code>, fosse usado. Mas a convenção está
            firmemente estabelecida. A notação é adotada do cálculo λ, um
            formalismo matemático introduzido pelo lógico matemático Alonzo
            <a href="References.html#Church-_00281941_0029">Church (1941)</a>.
            Church desenvolveu o cálculo λ para fornecer uma base rigorosa para
            estudar as noções de função e aplicação de função. O cálculo λ
            tornou-se uma ferramenta básica para investigações matemáticas da
            semântica de linguagens de programação.
          </p>
        </div>
        <div id="FOOT54">
          <p>
            <a class="footnote_backlink" href="#DOCF54"><sup>54</sup></a>
            Entender definições internas bem o suficiente para ter certeza de
            que um programa significa o que pretendemos que ele significa requer
            um modelo mais elaborado do processo de avaliação do que
            apresentamos neste capítulo. As sutilezas não surgem com definições
            internas de procedimentos, no entanto. Voltaremos a essa questão em
            <a href="4_002e1.html#g_t4_002e1_002e6">4.1.6</a>, depois de
            aprendermos mais sobre avaliação.
          </p>
        </div>
        <div id="FOOT55">
          <p>
            <a class="footnote_backlink" href="#DOCF55"><sup>55</sup></a> Usamos
            0.001 como um número "pequeno" representativo para indicar uma
            tolerância para o erro aceitável em um cálculo. A tolerância
            apropriada para um cálculo real depende do problema a ser resolvido
            e das limitações do computador e do algoritmo. Isso é frequentemente
            uma consideração muito sutil, exigindo ajuda de um analista numérico
            ou algum outro tipo de mágico.
          </p>
        </div>
        <div id="FOOT56">
          <p>
            <a class="footnote_backlink" href="#DOCF56"><sup>56</sup></a> Isso
            pode ser feito usando <code>error</code>, que recebe como argumentos
            um número de itens que são impressos como mensagens de erro.
          </p>
        </div>
        <div id="FOOT57">
          <p>
            <a class="footnote_backlink" href="#DOCF57"><sup>57</sup></a> Tente
            isso durante uma aula chata: Coloque sua calculadora no modo de
            radianos e então pressione repetidamente o botão
            <code>cos</code> até obter o ponto fixo.
          </p>
        </div>
        <div id="FOOT58">
          <p>
            <a class="footnote_backlink" href="#DOCF58"><sup>58</sup></a>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mo stretchy="false">↦<!-- ↦ --></mo>
            </math>
            (pronunciado "mapeia para") é a maneira do matemático de escrever
            <code>lambda</code>.
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>y</mi>
                <mo stretchy="false">↦<!-- ↦ --></mo>
                <mi>x</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mi>y</mi>
              </mrow>
            </math>
            significa <code>(lambda (y) (/ x y))</code>, ou seja, a função cujo
            valor em
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>y</mi>
            </math>
            é
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mrow class="MJX-TeXAtom-ORD">
                <mi>x</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mi>y</mi>
              </mrow> </math
            >.
          </p>
        </div>
        <div id="FOOT59">
          <p>
            <a class="footnote_backlink" href="#DOCF59"><sup>59</sup></a>
            Observe que esta é uma combinação cujo operador é ele mesmo uma
            combinação.
            <a href="1_002e1.html#Exercise-1_002e4">Exercício 1.4</a> já
            demonstrou a capacidade de formar tais combinações, mas isso foi
            apenas um exemplo de brinquedo. Aqui começamos a ver a real
            necessidade de tais combinações—ao aplicar um procedimento que é
            obtido como o valor retornado por um procedimento de ordem superior.
          </p>
        </div>
        <div id="FOOT60">
          <p>
            <a class="footnote_backlink" href="#DOCF60"><sup>60</sup></a>
            Veja
            <a href="#Exercise-1_002e45">Exercício 1.45</a> para uma
            generalização adicional.
          </p>
        </div>
        <div id="FOOT61">
          <p>
            <a class="footnote_backlink" href="#DOCF61"><sup>61</sup></a> Livros
            de cálculo elementar geralmente descrevem o método de Newton em
            termos da sequência de aproximações
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>x</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>n</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <mo>=</mo>
              <msub>
                <mi>x</mi>
                <mi>n</mi>
              </msub>
              <mo>−<!-- − --></mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>g</mi>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>x</mi>
                  <mi>n</mi>
                </msub>
                <mo stretchy="false">)</mo>
                <mspace width="thinmathspace" />
                <mrow class="MJX-TeXAtom-ORD">
                  <mo>/</mo>
                </mrow>
                <mi>D</mi>
                <mi>g</mi>
                <mo stretchy="false">(</mo>
                <msub>
                  <mi>x</mi>
                  <mi>n</mi>
                </msub>
                <mo stretchy="false">)</mo>
              </mrow> </math
            >. Ter linguagem para falar sobre processos e usar a ideia de pontos
            fixos simplifica a descrição do método.
          </p>
        </div>
        <div id="FOOT62">
          <p>
            <a class="footnote_backlink" href="#DOCF62"><sup>62</sup></a> O
            método de Newton nem sempre converge para uma resposta, mas pode ser
            mostrado que, em casos favoráveis, cada iteração dobra o número de
            dígitos de precisão da aproximação para a solução. Em tais casos, o
            método de Newton convergirá muito mais rapidamente que o método do
            intervalo médio.
          </p>
        </div>
        <div id="FOOT63">
          <p>
            <a class="footnote_backlink" href="#DOCF63"><sup>63</sup></a> Para
            encontrar raízes quadradas, o método de Newton converge rapidamente
            para a solução correta de qualquer ponto de partida.
          </p>
        </div>
        <div id="FOOT64">
          <p>
            <a class="footnote_backlink" href="#DOCF64"><sup>64</sup></a> A
            noção de status de primeira classe de elementos de linguagem de
            programação é devida ao cientista da computação britânico
            Christopher Strachey (1916-1975).
          </p>
        </div>
        <div id="FOOT65">
          <p>
            <a class="footnote_backlink" href="#DOCF65"><sup>65</sup></a>
            Veremos exemplos disso depois de introduzirmos estruturas de dados
            em <a href="Chapter-2.html#Chapter-2">Capítulo 2<!-- /@w --></a>.
          </p>
        </div>
        <div id="FOOT66">
          <p>
            <a class="footnote_backlink" href="#DOCF66"><sup>66</sup></a> O
            principal custo de implementação de procedimentos de primeira classe
            é que permitir que procedimentos sejam retornados como valores
            requer reservar armazenamento para as variáveis livres de um
            procedimento mesmo enquanto o procedimento não está sendo executado.
            Na implementação do Scheme que estudaremos em
            <a href="4_002e1.html#g_t4_002e1">4.1</a>, essas variáveis são
            armazenadas no ambiente do procedimento.
          </p>
        </div>
      </div>
      <nav class="header">
        <p>
          Próximo:
          <a href="Chapter-2.html#Chapter-2" accesskey="n" rel="next"
            >Capítulo 2</a
          >, Anterior:
          <a href="1_002e2.html#g_t1_002e2" accesskey="p" rel="prev">1.2</a>,
          Acima: <a href="#g_t1_002e3" accesskey="u" rel="prev">1.3</a> [<a
            href="index.html#SEC_Contents"
            title="Índice"
            accesskey="c"
            rel="contents"
            >Conteúdo</a
          >]
        </p>
      </nav>
    </section>
    <span class="bottom jump" title="Jump to bottom"
      ><a href="#pagebottom" accesskey="b">⇣</a></span
    ><a id="pagebottom"></a>
  </body>
</html>
